L 1 "USBD_User_CDC_ACM_0.c"
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB:Device:CDC
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    USBD_User_CDC_ACM_n.c
N * Purpose: USB Device Communication Device Class (CDC)
N *          Abstract Control Model (ACM) User module
N * Rev.:    V6.4.0
N *----------------------------------------------------------------------------*/
N 
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 12 "USBD_User_CDC_ACM_0.c" 2
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 13 "USBD_User_CDC_ACM_0.c" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 14 "USBD_User_CDC_ACM_0.c" 2
N 
N#include "rl_usb.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_usb.h
N * Purpose: USB User API
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_USB_H__
N#define __RL_USB_H__
N
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N
N#include "usb_os.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_os.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    usb_os.h
N * Purpose: USB OS Header
N *----------------------------------------------------------------------------*/
N
N#ifndef __USB_OS_H__
N#define __USB_OS_H__
N
N#include "RTE_Components.h"
L 1 ".\RTE\_Target_1\RTE_Components.h" 1
N
N/*
N * Auto generated Run-Time-Environment Component Configuration File
N *      *** Do not modify ! ***
N *
N * Project: 'freehandcmsisrtosbluepill' 
N * Target:  'Target 1' 
N */
N
N#ifndef RTE_COMPONENTS_H
N#define RTE_COMPONENTS_H
N
N
N/*
N * Define the Device Header File: 
N */
N#define CMSIS_device_header "stm32f10x.h"
N
N#define RTE_CMSIS_RTOS                  /* CMSIS-RTOS */
N        #define RTE_CMSIS_RTOS_RTX              /* CMSIS-RTOS Keil RTX */
N#define RTE_Compiler_IO_STDERR          /* Compiler I/O: STDERR */
N          #define RTE_Compiler_IO_STDERR_ITM      /* Compiler I/O: STDERR ITM */
N#define RTE_Compiler_IO_STDIN           /* Compiler I/O: STDIN */
N          #define RTE_Compiler_IO_STDIN_ITM       /* Compiler I/O: STDIN ITM */
N#define RTE_Compiler_IO_STDOUT          /* Compiler I/O: STDOUT */
N          #define RTE_Compiler_IO_STDOUT_ITM      /* Compiler I/O: STDOUT ITM */
N#define RTE_DEVICE_STDPERIPH_DBGMCU
N#define RTE_DEVICE_STDPERIPH_FRAMEWORK
N#define RTE_Drivers_SPI1                /* Driver SPI1 */
N        #define RTE_Drivers_SPI2                /* Driver SPI2 */
N        #define RTE_Drivers_SPI3                /* Driver SPI3 */
N#define RTE_Drivers_USBD0               /* Driver USBD0 */
N#define RTE_USB_Core                    /* USB Core */
N          #define RTE_USB_Core_Release            /* USB Core Release Version */
N#define RTE_USB_Device_0                /* USB Device 0 */
N#define RTE_USB_Device_CDC_0            /* USB Device CDC instance 0 */
N
N#endif /* RTE_COMPONENTS_H */
L 13 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_os.h" 2
N
N
N#if defined(RTE_CMSIS_RTOS2)
X#if 0L
S  #include "cmsis_os2.h"
S  #define  USB_CMSIS_RTOS2         (1U)
S#if defined(RTE_CMSIS_RTOS2_RTX5)
S  #include "rtx_os.h"
S  #define  USB_CMSIS_RTOS2_RTX5    (1U)
S#endif
N#endif
N#if defined(RTE_CMSIS_RTOS)
X#if 1L
N  #include "cmsis_os.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\RTOS\RTX\INC\cmsis_os.h" 1
N/* ----------------------------------------------------------------------
N * $Date:        5. February 2013
N * $Revision:    V1.02
N *
N * Project:      CMSIS-RTOS API
N * Title:        cmsis_os.h RTX header file
N *
N * Version 0.02
N *    Initial Proposal Phase
N * Version 0.03
N *    osKernelStart added, optional feature: main started as thread
N *    osSemaphores have standard behavior
N *    osTimerCreate does not start the timer, added osTimerStart
N *    osThreadPass is renamed to osThreadYield
N * Version 1.01
N *    Support for C++ interface
N *     - const attribute removed from the osXxxxDef_t typedef's
N *     - const attribute added to the osXxxxDef macros
N *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
N *    Added: osKernelInitialize
N * Version 1.02
N *    Control functions for short timeouts in microsecond resolution:
N *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
N *    Removed: osSignalGet 
N *----------------------------------------------------------------------------
N *
N * Copyright (c) 2013-2017 ARM LIMITED. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *---------------------------------------------------------------------------*/
N
N
N#ifndef _CMSIS_OS_H
N#define _CMSIS_OS_H
N
N#define osCMSIS           0x10002U     ///< CMSIS-RTOS API version (main [31:16] .sub [15:0])
N
N#define osCMSIS_RTX     ((4<<16)|82)   ///< RTOS identification and version (main [31:16] .sub [15:0])
N
N#define osKernelSystemId "RTX V4.82"   ///< RTOS identification string
N
N
N#define osFeature_MainThread   1       ///< main can be thread
N#define osFeature_Pool         1       ///< Memory Pools available
N#define osFeature_MailQ        1       ///< Mail Queues available
N#define osFeature_MessageQ     1       ///< Message Queues available
N#define osFeature_Signals      16      ///< 16 Signal Flags available per thread
N#define osFeature_Semaphore    65535   ///< Maximum count for \ref osSemaphoreCreate function
N#define osFeature_Wait         0       ///< osWait not available
N#define osFeature_SysTick      1       ///< osKernelSysTick functions available
N
N#if defined(__CC_ARM)
X#if 1L
N#define os_InRegs __value_in_regs      // Compiler specific: force struct in registers
N#else
S#define os_InRegs
N#endif
N
N#if   defined(__CC_ARM)
X#if   1L
N#define __NO_RETURN __declspec(noreturn)
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S#define __NO_RETURN __attribute__((noreturn))
S#elif defined(__GNUC__)
S#define __NO_RETURN __attribute__((noreturn))
S#elif defined(__ICCARM__)
S#define __NO_RETURN __noreturn
S#else
S#define __NO_RETURN
N#endif
N
N#include <stdint.h>
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 84 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\RTOS\RTX\INC\cmsis_os.h" 2
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N// ==== Enumeration, structures, defines ====
N
N/// Priority used for thread control.
Ntypedef enum  {
N  osPriorityIdle          = -3,          ///< priority: idle (lowest)
N  osPriorityLow           = -2,          ///< priority: low
N  osPriorityBelowNormal   = -1,          ///< priority: below normal
N  osPriorityNormal        =  0,          ///< priority: normal (default)
N  osPriorityAboveNormal   = +1,          ///< priority: above normal
N  osPriorityHigh          = +2,          ///< priority: high
N  osPriorityRealtime      = +3,          ///< priority: realtime (highest)
N  osPriorityError         =  0x84,       ///< system cannot determine priority or thread has illegal priority
N  os_priority_reserved    =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
N} osPriority;
N
N/// Timeout value.
N#define osWaitForever     0xFFFFFFFFU    ///< wait forever timeout value
N
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum  {
N  osOK                    =     0,       ///< function completed; no error or event occurred.
N  osEventSignal           =  0x08,       ///< function completed; signal event occurred.
N  osEventMessage          =  0x10,       ///< function completed; message event occurred.
N  osEventMail             =  0x20,       ///< function completed; mail event occurred.
N  osEventTimeout          =  0x40,       ///< function completed; timeout occurred.
N  osErrorParameter        =  0x80,       ///< parameter error: a mandatory parameter was missing or specified an incorrect object.
N  osErrorResource         =  0x81,       ///< resource not available: a specified resource was not available.
N  osErrorTimeoutResource  =  0xC1,       ///< resource not available within given time: a specified resource was not available within the timeout period.
N  osErrorISR              =  0x82,       ///< not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osErrorISRRecursive     =  0x83,       ///< function called multiple times from ISR with same object.
N  osErrorPriority         =  0x84,       ///< system cannot determine priority or thread has illegal priority.
N  osErrorNoMemory         =  0x85,       ///< system is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorValue            =  0x86,       ///< value of a parameter is out of range.
N  osErrorOS               =  0xFF,       ///< unspecified RTOS error: run-time error but no other error message fits.
N  os_status_reserved      =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
N} osStatus;
N
N
N/// Timer type value for the timer definition.
Ntypedef enum  {
N  osTimerOnce             =     0,       ///< one-shot timer
N  osTimerPeriodic         =     1        ///< repeating timer
N} os_timer_type;
N
N/// Entry point of a thread.
Ntypedef void (*os_pthread) (void const *argument);
N
N/// Entry point of a timer call back function.
Ntypedef void (*os_ptimer) (void const *argument);
N
N// >>> the following data type definitions may shall adapted towards a specific RTOS
N
N/// Thread ID identifies the thread (pointer to a thread control block).
Ntypedef struct os_thread_cb *osThreadId;
N
N/// Timer ID identifies the timer (pointer to a timer control block).
Ntypedef struct os_timer_cb *osTimerId;
N
N/// Mutex ID identifies the mutex (pointer to a mutex control block).
Ntypedef struct os_mutex_cb *osMutexId;
N
N/// Semaphore ID identifies the semaphore (pointer to a semaphore control block).
Ntypedef struct os_semaphore_cb *osSemaphoreId;
N
N/// Pool ID identifies the memory pool (pointer to a memory pool control block).
Ntypedef struct os_pool_cb *osPoolId;
N
N/// Message ID identifies the message queue (pointer to a message queue control block).
Ntypedef struct os_messageQ_cb *osMessageQId;
N
N/// Mail ID identifies the mail queue (pointer to a mail queue control block).
Ntypedef struct os_mailQ_cb *osMailQId;
N
N
N/// Thread Definition structure contains startup information of a thread.
Ntypedef struct os_thread_def  {
N  os_pthread               pthread;    ///< start address of thread function
N  osPriority             tpriority;    ///< initial thread priority
N  uint32_t               instances;    ///< maximum number of instances of that thread function
N  uint32_t               stacksize;    ///< stack size requirements in bytes; 0 is default stack size
N} osThreadDef_t;
N
N/// Timer Definition structure contains timer parameters.
Ntypedef struct os_timer_def  {
N  os_ptimer                 ptimer;    ///< start address of a timer function
N  void                      *timer;    ///< pointer to internal data
N} osTimerDef_t;
N
N/// Mutex Definition structure contains setup information for a mutex.
Ntypedef struct os_mutex_def  {
N  void                      *mutex;    ///< pointer to internal data
N} osMutexDef_t;
N
N/// Semaphore Definition structure contains setup information for a semaphore.
Ntypedef struct os_semaphore_def  {
N  void                  *semaphore;    ///< pointer to internal data
N} osSemaphoreDef_t;
N
N/// Definition structure for memory block allocation.
Ntypedef struct os_pool_def  {
N  uint32_t                 pool_sz;    ///< number of items (elements) in the pool
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< pointer to memory for pool
N} osPoolDef_t;
N
N/// Definition structure for message queue.
Ntypedef struct os_messageQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  void                       *pool;    ///< memory array for messages
N} osMessageQDef_t;
N
N/// Definition structure for mail queue.
Ntypedef struct os_mailQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< memory array for mail
N} osMailQDef_t;
N
N/// Event structure contains detailed information about an event.
Ntypedef struct  {
N  osStatus                 status;     ///< status code: event or error information
N  union  {
N    uint32_t                    v;     ///< message as 32-bit value
N    void                       *p;     ///< message or mail as void pointer
N    int32_t               signals;     ///< signal flags
N  } value;                             ///< event value
N  union  {
N    osMailQId             mail_id;     ///< mail id obtained by \ref osMailCreate
N    osMessageQId       message_id;     ///< message id obtained by \ref osMessageCreate
N  } def;                               ///< event definition
N} osEvent;
N
N
N//  ==== Kernel Control Functions ====
N
N/// Initialize the RTOS Kernel for creating objects.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelInitialize (void);
N
N/// Start the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelStart (void);
N
N/// Check if the RTOS kernel is already started.
N/// \return 0 RTOS is not started, 1 RTOS is started.
Nint32_t osKernelRunning(void);
N
N#if (defined (osFeature_SysTick)  &&  (osFeature_SysTick != 0))     // System Timer available
X#if (1L  &&  (1 != 0))     
N
N/// \cond INTERNAL_VARIABLES
Nextern uint32_t const os_tickfreq;
Nextern uint16_t const os_tickus_i;
Nextern uint16_t const os_tickus_f;
N/// \endcond
N
N/// Get the RTOS kernel system timer counter.
N/// \return RTOS kernel system timer as 32-bit value 
Nuint32_t osKernelSysTick (void);
N
N/// The RTOS kernel system timer frequency in Hz.
N/// \note Reflects the system timer setting and is typically defined in a configuration file.
N#define osKernelSysTickFrequency os_tickfreq
N
N/// Convert a microseconds value to a RTOS kernel system timer value.
N/// \param         microsec     time value in microseconds.
N/// \return time value normalized to the \ref osKernelSysTickFrequency
N/*
N#define osKernelSysTickMicroSec(microsec) (((uint64_t)microsec * (osKernelSysTickFrequency)) / 1000000)
N*/
N#define osKernelSysTickMicroSec(microsec) ((microsec * os_tickus_i) + ((microsec * os_tickus_f) >> 16))
N
N#endif    // System Timer available
N
N//  ==== Thread Management ====
N
N/// Create a Thread Definition with function, priority, and stack requirements.
N/// \param         name         name of the thread function.
N/// \param         priority     initial priority of the thread function.
N/// \param         instances    number of possible thread instances.
N/// \param         stacksz      stack size (in bytes) requirements for the thread function.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osThreadDef(name, priority, instances, stacksz)  \
Sextern const osThreadDef_t os_thread_def_##name
X#define osThreadDef(name, priority, instances, stacksz)  extern const osThreadDef_t os_thread_def_##name
N#else                            // define the object
N#define osThreadDef(name, priority, instances, stacksz)  \
Nconst osThreadDef_t os_thread_def_##name = \
N{ (name), (priority), (instances), (stacksz)  }
X#define osThreadDef(name, priority, instances, stacksz)  const osThreadDef_t os_thread_def_##name = { (name), (priority), (instances), (stacksz)  }
N#endif
N
N/// Access a Thread definition.
N/// \param         name          name of the thread definition object.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#define osThread(name)  \
N&os_thread_def_##name
X#define osThread(name)  &os_thread_def_##name
N
N/// Create a thread and add it to Active Threads and set it to state READY.
N/// \param[in]     thread_def    thread definition referenced with \ref osThread.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument);
N
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadGetId (void);
N
N/// Terminate execution of a thread and remove it from Active Threads.
N/// \param[in]     thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadTerminate (osThreadId thread_id);
N
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadYield (void);
N
N/// Change priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadSetPriority (osThreadId thread_id, osPriority priority);
N
N/// Get current priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return current priority value of the thread function.
NosPriority osThreadGetPriority (osThreadId thread_id);
N
N
N//  ==== Generic Wait Functions ====
N
N/// Wait for Timeout (Time Delay).
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue "Time delay" value
N/// \return status code that indicates the execution status of the function.
NosStatus osDelay (uint32_t millisec);
N
N#if (defined (osFeature_Wait)  &&  (osFeature_Wait != 0))     // Generic Wait available
X#if (1L  &&  (0 != 0))     
S
S/// Wait for Signal, Message, Mail, or Timeout.
S/// \param[in] millisec          \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
S/// \return event that contains signal, message, or mail information or error code.
Sos_InRegs osEvent osWait (uint32_t millisec);
S
N#endif  // Generic Wait available
N
N
N//  ==== Timer Management Functions ====
N/// Define a Timer object.
N/// \param         name          name of the timer object.
N/// \param         function      name of the timer call back function.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osTimerDef(name, function)  \
Sextern const osTimerDef_t os_timer_def_##name
X#define osTimerDef(name, function)  extern const osTimerDef_t os_timer_def_##name
N#else                            // define the object
N#define osTimerDef(name, function)  \
Nuint32_t os_timer_cb_##name[6]; \
Nconst osTimerDef_t os_timer_def_##name = \
N{ (function), (os_timer_cb_##name) }
X#define osTimerDef(name, function)  uint32_t os_timer_cb_##name[6]; const osTimerDef_t os_timer_def_##name = { (function), (os_timer_cb_##name) }
N#endif
N
N/// Access a Timer definition.
N/// \param         name          name of the timer object.
N#define osTimer(name) \
N&os_timer_def_##name
X#define osTimer(name) &os_timer_def_##name
N
N/// Create a timer.
N/// \param[in]     timer_def     timer object referenced with \ref osTimer.
N/// \param[in]     type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer call back function.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument);
N
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue "Time delay" value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStart (osTimerId timer_id, uint32_t millisec);
N
N/// Stop the timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStop (osTimerId timer_id);
N
N/// Delete a timer that was created by \ref osTimerCreate.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerDelete (osTimerId timer_id);
N
N
N//  ==== Signal Management ====
N
N/// Set the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that should be set.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
Nint32_t osSignalSet (osThreadId thread_id, int32_t signals);
N
N/// Clear the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that shall be cleared.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters or call from ISR.
Nint32_t osSignalClear (osThreadId thread_id, int32_t signals);
N
N/// Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread.
N/// \param[in]     signals       wait until all specified signal flags set or 0 for any single signal flag.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event flag information or error code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060422 >= 6010050)
S#define   osSignalWait __osSignalWait
SosEvent __osSignalWait (int32_t signals, uint32_t millisec);
N#else
Nos_InRegs osEvent osSignalWait (int32_t signals, uint32_t millisec);
X__value_in_regs osEvent osSignalWait (int32_t signals, uint32_t millisec);
N#endif
N
N
N//  ==== Mutex Management ====
N
N/// Define a Mutex.
N/// \param         name          name of the mutex object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMutexDef(name)  \
Sextern const osMutexDef_t os_mutex_def_##name
X#define osMutexDef(name)  extern const osMutexDef_t os_mutex_def_##name
N#else                            // define the object
N#define osMutexDef(name)  \
Nuint32_t os_mutex_cb_##name[4] = { 0 }; \
Nconst osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
X#define osMutexDef(name)  uint32_t os_mutex_cb_##name[4] = { 0 }; const osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
N#endif
N
N/// Access a Mutex definition.
N/// \param         name          name of the mutex object.
N#define osMutex(name)  \
N&os_mutex_def_##name
X#define osMutex(name)  &os_mutex_def_##name
N
N/// Create and Initialize a Mutex object.
N/// \param[in]     mutex_def     mutex definition referenced with \ref osMutex.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId osMutexCreate (const osMutexDef_t *mutex_def);
N
N/// Wait until a Mutex becomes available.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexWait (osMutexId mutex_id, uint32_t millisec);
N
N/// Release a Mutex that was obtained by \ref osMutexWait.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexRelease (osMutexId mutex_id);
N
N/// Delete a Mutex that was created by \ref osMutexCreate.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexDelete (osMutexId mutex_id);
N
N
N//  ==== Semaphore Management Functions ====
N
N#if (defined (osFeature_Semaphore)  &&  (osFeature_Semaphore != 0))     // Semaphore available
X#if (1L  &&  (65535 != 0))     
N
N/// Define a Semaphore object.
N/// \param         name          name of the semaphore object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osSemaphoreDef(name)  \
Sextern const osSemaphoreDef_t os_semaphore_def_##name
X#define osSemaphoreDef(name)  extern const osSemaphoreDef_t os_semaphore_def_##name
N#else                            // define the object
N#define osSemaphoreDef(name)  \
Nuint32_t os_semaphore_cb_##name[2] = { 0 }; \
Nconst osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
X#define osSemaphoreDef(name)  uint32_t os_semaphore_cb_##name[2] = { 0 }; const osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
N#endif
N
N/// Access a Semaphore definition.
N/// \param         name          name of the semaphore object.
N#define osSemaphore(name)  \
N&os_semaphore_def_##name
X#define osSemaphore(name)  &os_semaphore_def_##name
N
N/// Create and Initialize a Semaphore object used for managing resources.
N/// \param[in]     semaphore_def semaphore definition referenced with \ref osSemaphore.
N/// \param[in]     count         number of available resources.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count);
N
N/// Wait until a Semaphore token becomes available.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return number of available tokens, or -1 in case of incorrect parameters.
Nint32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec);
N
N/// Release a Semaphore token.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreRelease (osSemaphoreId semaphore_id);
N
N/// Delete a Semaphore that was created by \ref osSemaphoreCreate.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreDelete (osSemaphoreId semaphore_id);
N
N#endif     // Semaphore available
N
N
N//  ==== Memory Pool Management Functions ====
N
N#if (defined (osFeature_Pool)  &&  (osFeature_Pool != 0))  // Memory Pool Management available
X#if (1L  &&  (1 != 0))  
N
N/// \brief Define a Memory Pool.
N/// \param         name          name of the memory pool.
N/// \param         no            maximum number of blocks (objects) in the memory pool.
N/// \param         type          data type of a single block (object).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osPoolDef(name, no, type)   \
Sextern const osPoolDef_t os_pool_def_##name
X#define osPoolDef(name, no, type)   extern const osPoolDef_t os_pool_def_##name
N#else                            // define the object
N#define osPoolDef(name, no, type)   \
Nuint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; \
Nconst osPoolDef_t os_pool_def_##name = \
N{ (no), sizeof(type), (os_pool_m_##name) }
X#define osPoolDef(name, no, type)   uint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; const osPoolDef_t os_pool_def_##name = { (no), sizeof(type), (os_pool_m_##name) }
N#endif
N
N/// \brief Access a Memory Pool definition.
N/// \param         name          name of the memory pool
N#define osPool(name) \
N&os_pool_def_##name
X#define osPool(name) &os_pool_def_##name
N
N/// Create and Initialize a memory pool.
N/// \param[in]     pool_def      memory pool definition referenced with \ref osPool.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosPoolId osPoolCreate (const osPoolDef_t *pool_def);
N
N/// Allocate a memory block from a memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolAlloc (osPoolId pool_id);
N
N/// Allocate a memory block from a memory pool and set memory block to zero.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolCAlloc (osPoolId pool_id);
N
N/// Return an allocated memory block back to a specific memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \param[in]     block         address of the allocated memory block that is returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus osPoolFree (osPoolId pool_id, void *block);
N
N#endif   // Memory Pool Management available
N
N
N//  ==== Message Queue Management Functions ====
N
N#if (defined (osFeature_MessageQ)  &&  (osFeature_MessageQ != 0))     // Message Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Message Queue Definition.
N/// \param         name          name of the queue.
N/// \param         queue_sz      maximum number of messages in the queue.
N/// \param         type          data type of a single message element (for debugger).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMessageQDef(name, queue_sz, type)   \
Sextern const osMessageQDef_t os_messageQ_def_##name
X#define osMessageQDef(name, queue_sz, type)   extern const osMessageQDef_t os_messageQ_def_##name
N#else                            // define the object
N#define osMessageQDef(name, queue_sz, type)   \
Nuint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; \
Nconst osMessageQDef_t os_messageQ_def_##name = \
N{ (queue_sz), (os_messageQ_q_##name) }
X#define osMessageQDef(name, queue_sz, type)   uint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; const osMessageQDef_t os_messageQ_def_##name = { (queue_sz), (os_messageQ_q_##name) }
N#endif
N
N/// \brief Access a Message Queue Definition.
N/// \param         name          name of the queue
N#define osMessageQ(name) \
N&os_messageQ_def_##name
X#define osMessageQ(name) &os_messageQ_def_##name
N
N/// Create and Initialize a Message Queue.
N/// \param[in]     queue_def     queue definition referenced with \ref osMessageQ.
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id);
N
N/// Put a Message to a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     info          message information.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec);
N
N/// Get a Message or Wait for a Message from a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event information that includes status code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060422 >= 6010050)
S#define   osMessageGet __osMessageGet
SosEvent __osMessageGet (osMessageQId queue_id, uint32_t millisec);
N#else
Nos_InRegs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
N#endif
N
N#endif     // Message Queues available
N
N
N//  ==== Mail Queue Management Functions ====
N
N#if (defined (osFeature_MailQ)  &&  (osFeature_MailQ != 0))     // Mail Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Mail Queue Definition.
N/// \param         name          name of the queue
N/// \param         queue_sz      maximum number of messages in queue
N/// \param         type          data type of a single message element
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMailQDef(name, queue_sz, type) \
Sextern const osMailQDef_t os_mailQ_def_##name
X#define osMailQDef(name, queue_sz, type) extern const osMailQDef_t os_mailQ_def_##name
N#else                            // define the object
N#define osMailQDef(name, queue_sz, type) \
Nuint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; \
Nuint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; \
Nvoid *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; \
Nconst osMailQDef_t os_mailQ_def_##name =  \
N{ (queue_sz), sizeof(type), (os_mailQ_p_##name) }
X#define osMailQDef(name, queue_sz, type) uint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; uint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; void *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; const osMailQDef_t os_mailQ_def_##name =  { (queue_sz), sizeof(type), (os_mailQ_p_##name) }
N#endif
N
N/// \brief Access a Mail Queue Definition.
N/// \param         name          name of the queue
N#define osMailQ(name)  \
N&os_mailQ_def_##name
X#define osMailQ(name)  &os_mailQ_def_##name
N
N/// Create and Initialize mail queue.
N/// \param[in]     queue_def     reference to the mail queue definition obtain with \ref osMailQ
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return mail queue ID for reference by other functions or NULL in case of error.
NosMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id);
N
N/// Allocate a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Allocate a memory block from a mail and set memory block to zero.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailCAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Put a mail to a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailPut (osMailQId queue_id, void *mail);
N
N/// Get a mail from a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return event that contains mail information or error code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060422 >= 6010050)
S#define   osMailGet __osMailGet
SosEvent __osMailGet (osMailQId queue_id, uint32_t millisec);
N#else
Nos_InRegs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
N#endif
N
N/// Free a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          pointer to the memory block that was obtained with \ref osMailGet.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailFree (osMailQId queue_id, void *mail);
N
N#endif  // Mail Queues available
N
N
N//  ==== RTX Extensions ====
N
N/// Suspend the RTX task scheduler.
N/// \return number of ticks, for how long the system can sleep or power-down.
Nuint32_t os_suspend (void);
N
N/// Resume the RTX task scheduler.
N/// \param[in]     sleep_time    specifies how long the system was in sleep or power-down mode.
Nvoid os_resume (uint32_t sleep_time);
N
N/// OS idle demon (running when no other thread is ready to run).
N__NO_RETURN void os_idle_demon (void);
X__declspec(noreturn) void os_idle_demon (void);
N
N/// OS error callback (called when a runtime error is detected).
N/// \param[in]     error_code    actual error code that has been detected.
N__NO_RETURN void os_error (uint32_t error_code);
X__declspec(noreturn) void os_error (uint32_t error_code);
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif  // _CMSIS_OS_H
L 25 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_os.h" 2
N  #define  USB_CMSIS_RTOS          (1U)
N#endif
N
N#endif // __USB_OS_H__
L 21 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 2
N#include "usb_compiler.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_compiler.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB:Device
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    usb_compiler.h
N * Purpose: USB Library Compiler specific definitions
N *----------------------------------------------------------------------------*/
N
N#ifndef __USB_COMPILER_H__
N#define __USB_COMPILER_H__
N
N#include "cmsis_compiler.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.1.0
N * @date     08. May 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (0L && (__TARGET_ARCH_6S_M  == 1))   )
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (1L && (1  == 1))
N  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE                 
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif           
N#ifndef   __NO_RETURN
S  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute((used, section("RESET")))
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1U);
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (0L && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (0L && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value != 0U; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return result;
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
S{
S  if ((sat >= 1U) && (sat <= 32U))
S  {
S    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
S    const int32_t min = -1 - max ;
S    if (val > max)
S    {
S      return max;
S    }
S    else if (val < min)
S    {
S      return min;
S    }
S  }
S  return val;
S}
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
S{
S  if (sat <= 31U)
S  {
S    const uint32_t max = ((1U << sat) - 1U);
S    if (val > (int32_t)max)
S    {
S      return max;
S    }
S    else if (val < 0)
S    {
S      return 0U;
S    }
S  }
S  return (uint32_t)val;
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 13 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_compiler.h" 2
N
N// Supported compilers are ARM Compiler 4,5 and 6, and GNU Compiler
N#if (defined ( __CC_ARM ) || defined ( __ARMCC_VERSION ) || defined ( __GNUC__ ))
X#if (1L || 1L || 0L)
N
N  // Generic macros same for all supported compilers
N  #if   defined ( __CC_ARM )                                              /* ARM Compiler 4/5 */
X  #if   1L                                               
N  #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )     /* ARM Compiler 6 */
S    #pragma clang diagnostic push
S    #pragma clang diagnostic ignored "-Wpacked"
S  #elif defined ( __GNUC__ )                                              /* GNU Compiler */
S    #pragma GCC diagnostic push
S    #pragma GCC diagnostic ignored "-Wpacked"
S    #pragma GCC diagnostic ignored "-Wattributes"
N  #endif
N  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)  (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
N  #endif
N  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ  { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)        (((const struct T_UINT16_READ  *)(const void*)(addr))->v)
N  #endif
N  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)  (void)((((struct T_UINT32_WRITE *)(void*)(addr))->v) = (val))
N  #endif
N  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ  { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)        (((const struct T_UINT32_READ  *)(const void*)(addr))->v)
N  #endif
N  #if   defined ( __CC_ARM )                                              /* ARM Compiler 4/5 */
X  #if   1L                                               
N  #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )     /* ARM Compiler 6 */
S    #pragma clang diagnostic pop
S  #elif defined ( __GNUC__ )                                              /* GNU Compiler */
S    #pragma GCC diagnostic pop
N  #endif
N
N  #ifndef   __SECTION
N    #define __SECTION__(x)              __attribute__((section(#x)))
N    #define __SECTION(x)                __SECTION__(x)
N  #endif
N
N  // Compiler specific macros
N  #if   defined ( __CC_ARM )                                              /* ARM Compiler 4/5 */
X  #if   1L                                               
N    #ifndef   __AT_ADDR
N      #define __AT_ADDR(x)                __attribute__((at(x)))
N    #endif
N  #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )     /* ARM Compiler 6 */
S    #ifndef   __AT_ADDR
S      #define __AT_ADDR__(x)              __attribute__((section(".ARM.__AT_"#x)))
S      #define __AT_ADDR(x)                __AT_ADDR__(x)
S    #endif
S  #elif defined ( __GNUC__ )                                              /* GNU Compiler */
S    #warning Position memory containing __AT_ADDR macro at absolute address!
S    #ifndef   __AT_ADDR
S      #define __AT_ADDR(x)
S    #endif
N  #endif
N
N#else
S  #error Unsupported compiler!
N#endif
N
N#endif  // __USB_COMPILER_H__
L 22 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 2
N#include "usb_def.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_def.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    usb_def.h
N * Purpose: USB Definitions
N *----------------------------------------------------------------------------*/
N
N#ifndef __USB_DEF_H
N#define __USB_DEF_H
N
N#include <stdint.h>
N
N#include "usb_compiler.h"
N
N
N// USB Speed
N#define USB_SPEED_LOW                    0U
N#define USB_SPEED_FULL                   1U
N#define USB_SPEED_HIGH                   2U
N
N// USB PID Types
N#define USB_PID_RESERVED                 0U
N#define USB_PID_OUT                      1U
N#define USB_PID_ACK                      2U
N#define USB_PID_DATA0                    3U
N#define USB_PID_PING                     4U
N#define USB_PID_SOF                      5U
N#define USB_PID_DATA2                    7U
N#define USB_PID_NYET                     6U
N#define USB_PID_SPLIT                    8U
N#define USB_PID_IN                       9U
N#define USB_PID_NAK                     10U
N#define USB_PID_DATA1                   11U
N#define USB_PID_PRE                     12U
N#define USB_PID_ERR                     12U
N#define USB_PID_SETUP                   13U
N#define USB_PID_STALL                   14U
N#define USB_PID_MDATA                   15U
N
N// bmRequestType.Dir
N#define USB_REQUEST_HOST_TO_DEVICE      0U
N#define USB_REQUEST_DEVICE_TO_HOST      1U
N
N// bmRequestType.Type
N#define USB_REQUEST_STANDARD            0U
N#define USB_REQUEST_CLASS               1U
N#define USB_REQUEST_VENDOR              2U
N#define USB_REQUEST_RESERVED            3U
N
N// bmRequestType.Recipient
N#define USB_REQUEST_TO_DEVICE           0U
N#define USB_REQUEST_TO_INTERFACE        1U
N#define USB_REQUEST_TO_ENDPOINT         2U
N#define USB_REQUEST_TO_OTHER            3U
N
N/// bmRequestType Definition
Ntypedef struct {
N  uint8_t Recipient : 5;                ///< D4..0: Recipient
N  uint8_t Type      : 2;                ///< D6..5: Type
N  uint8_t Dir       : 1;                ///< D7:    Data Transfer Direction
N} USB_REQUEST_TYPE;
N
N// USB Standard Request Codes
N#define USB_REQUEST_GET_STATUS           0U
N#define USB_REQUEST_CLEAR_FEATURE        1U
N#define USB_REQUEST_SET_FEATURE          3U
N#define USB_REQUEST_SET_ADDRESS          5U
N#define USB_REQUEST_GET_DESCRIPTOR       6U
N#define USB_REQUEST_SET_DESCRIPTOR       7U
N#define USB_REQUEST_GET_CONFIGURATION    8U
N#define USB_REQUEST_SET_CONFIGURATION    9U
N#define USB_REQUEST_GET_INTERFACE       10U
N#define USB_REQUEST_SET_INTERFACE       11U
N#define USB_REQUEST_SYNC_FRAME          12U
N
N// USB GET_STATUS Bit Values
N#define USB_GETSTATUS_SELF_POWERED      0x01U
N#define USB_GETSTATUS_REMOTE_WAKEUP     0x02U
N#define USB_GETSTATUS_ENDPOINT_STALL    0x01U
N
N// USB Standard Feature selectors
N#define USB_FEATURE_ENDPOINT_STALL      0U
N#define USB_FEATURE_REMOTE_WAKEUP       1U
N
N/// USB Default Control Pipe Setup Packet
Ntypedef struct {
N  USB_REQUEST_TYPE bmRequestType;       ///< Characteristics of request
N  uint8_t          bRequest;            ///< Specific request
N  uint16_t         wValue;              ///< Value according to request
N  uint16_t         wIndex;              ///< Index or Offset according to request
N  uint16_t         wLength;             ///< Number of bytes to transfer if there is a Data stage
N} USB_SETUP_PACKET;
N
N
N// USB Descriptor Types
N#define USB_DEVICE_DESCRIPTOR_TYPE                 1U
N#define USB_CONFIGURATION_DESCRIPTOR_TYPE          2U
N#define USB_STRING_DESCRIPTOR_TYPE                 3U
N#define USB_INTERFACE_DESCRIPTOR_TYPE              4U
N#define USB_ENDPOINT_DESCRIPTOR_TYPE               5U
N#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE       6U
N#define USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE     7U
N#define USB_INTERFACE_POWER_DESCRIPTOR_TYPE        8U
N#define USB_OTG_DESCRIPTOR_TYPE                    9U
N#define USB_DEBUG_DESCRIPTOR_TYPE                 10U
N#define USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE 11U
N
N// USB Device Classes
N#define USB_DEVICE_CLASS_RESERVED                 0x00U
N#define USB_DEVICE_CLASS_AUDIO                    0x01U
N#define USB_DEVICE_CLASS_COMMUNICATIONS           0x02U
N#define USB_DEVICE_CLASS_HUMAN_INTERFACE          0x03U
N#define USB_DEVICE_CLASS_MONITOR                  0x04U
N#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE       0x05U
N#define USB_DEVICE_CLASS_POWER                    0x06U
N#define USB_DEVICE_CLASS_PRINTER                  0x07U
N#define USB_DEVICE_CLASS_STORAGE                  0x08U
N#define USB_DEVICE_CLASS_HUB                      0x09U
N#define USB_DEVICE_CLASS_MISCELLANEOUS            0xEFU
N#define USB_DEVICE_CLASS_VENDOR_SPECIFIC          0xFFU
N
N// bmAttributes in Configuration Descriptor
N#define USB_CONFIG_POWERED_MASK                   0x40U
N#define USB_CONFIG_BUS_POWERED                    0x80U
N#define USB_CONFIG_SELF_POWERED                   0xC0U
N#define USB_CONFIG_REMOTE_WAKEUP                  0x20U
N
N// bMaxPower in Configuration Descriptor
N#define USB_CONFIG_POWER_MA(mA)                   ((mA)/2)
N
N// bEndpointAddress in Endpoint Descriptor
N#define USB_ENDPOINT_DIRECTION_MASK               0x80U
N#define USB_ENDPOINT_OUT(addr)                    ( addr         )
N#define USB_ENDPOINT_IN(addr)                     ((addr) | 0x80U)
N
N// bmAttributes in Endpoint Descriptor
N#define USB_ENDPOINT_TYPE_MASK                    0x03U
N#define USB_ENDPOINT_TYPE_CONTROL                 0x00U
N#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01U
N#define USB_ENDPOINT_TYPE_BULK                    0x02U
N#define USB_ENDPOINT_TYPE_INTERRUPT               0x03U
N#define USB_ENDPOINT_SYNC_MASK                    0x0CU
N#define USB_ENDPOINT_SYNC_NO_SYNCHRONIZATION      0x00U
N#define USB_ENDPOINT_SYNC_ASYNCHRONOUS            0x04U
N#define USB_ENDPOINT_SYNC_ADAPTIVE                0x08U
N#define USB_ENDPOINT_SYNC_SYNCHRONOUS             0x0CU
N#define USB_ENDPOINT_USAGE_MASK                   0x30U
N#define USB_ENDPOINT_USAGE_DATA                   0x00U
N#define USB_ENDPOINT_USAGE_FEEDBACK               0x10U
N#define USB_ENDPOINT_USAGE_IMPLICIT_FEEDBACK      0x20U
N#define USB_ENDPOINT_USAGE_RESERVED               0x30U
N
N/// USB Standard Device Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t bcdUSB;
N  uint8_t  bDeviceClass;
N  uint8_t  bDeviceSubClass;
N  uint8_t  bDeviceProtocol;
N  uint8_t  bMaxPacketSize0;
N  uint16_t idVendor;
N  uint16_t idProduct;
N  uint16_t bcdDevice;
N  uint8_t  iManufacturer;
N  uint8_t  iProduct;
N  uint8_t  iSerialNumber;
N  uint8_t  bNumConfigurations;
N} USB_DEVICE_DESCRIPTOR;
N
N/// USB 2.0 Device Qualifier Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t bcdUSB;
N  uint8_t  bDeviceClass;
N  uint8_t  bDeviceSubClass;
N  uint8_t  bDeviceProtocol;
N  uint8_t  bMaxPacketSize0;
N  uint8_t  bNumConfigurations;
N  uint8_t  bReserved;
N} USB_DEVICE_QUALIFIER_DESCRIPTOR;
N
N/// USB Standard Configuration Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t wTotalLength;
N  uint8_t  bNumInterfaces;
N  uint8_t  bConfigurationValue;
N  uint8_t  iConfiguration;
N  uint8_t  bmAttributes;
N  uint8_t  bMaxPower;
N} USB_CONFIGURATION_DESCRIPTOR;
N
N/// USB Standard Interface Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint8_t  bInterfaceNumber;
N  uint8_t  bAlternateSetting;
N  uint8_t  bNumEndpoints;
N  uint8_t  bInterfaceClass;
N  uint8_t  bInterfaceSubClass;
N  uint8_t  bInterfaceProtocol;
N  uint8_t  iInterface;
N} USB_INTERFACE_DESCRIPTOR;
N
N/// USB Standard Endpoint Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint8_t  bEndpointAddress;
N  uint8_t  bmAttributes;
N  uint16_t wMaxPacketSize;
N  uint8_t  bInterval;
N} USB_ENDPOINT_DESCRIPTOR;
N
N/// USB String Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t bString;
N} USB_STRING_DESCRIPTOR;
N
N/// USB Common Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N} USB_COMMON_DESCRIPTOR;
N
N/// USB Interface Association Descriptor
Ntypedef struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint8_t  bFirstInterface;
N  uint8_t  bInterfaceCount;
N  uint8_t  bFunctionClass;
N  uint8_t  bFunctionSubclass;
N  uint8_t  bFunctionProtocol;
N  uint8_t  iFunction;
N} USB_INTERFACE_ASSOCIATION_DESCRIPTOR;
N
N#endif  // __USB_DEF_H
L 23 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 2
N#include "usb_cdc.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_cdc.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    usb_cdc.h
N * Purpose: USB Communication Device Class Definitions
N *----------------------------------------------------------------------------*/
N
N#ifndef __USB_CDC_H
N#define __USB_CDC_H
N
N#include <stdint.h>
N
N#include "usb_compiler.h"
N#include "usb_def.h"
N
N
N/*------------------------------------------------------------------------------
N *      Definitions  based on: - usbcdc11.pdf  (www.usb.org)
N *                             - usbecm120.pdf (www.usb.org)
N *                             - usbncm10.pdf  (www.usb.org)
N *----------------------------------------------------------------------------*/
N// Communication device class specification version 1.1
N#define CDC_V1_1_0                              0x0110U
N
N// Communication device class specification version 1.2
N#define CDC_V1_2_0                              0x0120U
N
N// Communication interface class code
N// (usbcdc11.pdf, 4.2, Table 15)
N#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02U
N
N// Communication interface class subclass codes
N// (usbcdc11.pdf, 4.3, Table 16)
N#define CDC_DIRECT_LINE_CONTROL_MODEL           0x01U
N#define CDC_ABSTRACT_CONTROL_MODEL              0x02U
N#define CDC_TELEPHONE_CONTROL_MODEL             0x03U
N#define CDC_MULTI_CHANNEL_CONTROL_MODEL         0x04U
N#define CDC_CAPI_CONTROL_MODEL                  0x05U
N#define CDC_ETHERNET_NETWORKING_CONTROL_MODEL   0x06U
N#define CDC_ATM_NETWORKING_CONTROL_MODEL        0x07U
N#define CDC_WIRELESS_HANDSET_CONTROL_MODEL      0x08U
N#define CDC_DEVICE_MANAGEMENT                   0x09U
N#define CDC_MOBILE_DIRECT_LINE_MODEL            0x0AU
N#define CDC_OBEX                                0x0BU
N#define CDC_ETHERNET_EMULATION_MODEL            0x0CU
N#define CDC_NETWORK_CONTROL_MODEL               0x0DU
N
N// Communication interface class control protocol codes
N// (usbcdc11.pdf, 4.4, Table 17)
N#define CDC_PROTOCOL_COMMON_AT_COMMANDS         0x01U
N
N// NCM Communication Interface Protocol Codes
N// (usbncm10.pdf, 4.2, Table 4-2)
N#define CDC_NCM_PROTOCOL_NONE                   0x00U
N#define CDC_NCM_PROTOCOL_OEM                    0xFEU
N
N// Data interface class code
N// (usbcdc11.pdf, 4.5, Table 18)
N#define CDC_DATA_INTERFACE_CLASS                0x0AU
N
N// NCM Data Class Interface Protocol Codes
N// (usbncm10.pdf, 4.3, Table 4-3)
N#define CDC_NCM_DATA_NETWORK_TRANSFER_BLOCK     0x01U
N
N// NCM Functional Descriptor Code
N// (usbncm10.pdf, 4.4, Table 4-4)
N#define CDC_NCM_FUNC_DESC_CODE                  0x1AU
N
N// Data interface class protocol codes
N// (usbcdc11.pdf, 4.7, Table 19)
N#define CDC_PROTOCOL_ISDN_BRI                   0x30U
N#define CDC_PROTOCOL_HDLC                       0x31U
N#define CDC_PROTOCOL_TRANSPARENT                0x32U
N#define CDC_PROTOCOL_Q921_MANAGEMENT            0x50U
N#define CDC_PROTOCOL_Q921_DATA_LINK             0x51U
N#define CDC_PROTOCOL_Q921_MULTIPLEXOR           0x52U
N#define CDC_PROTOCOL_V42                        0x90U
N#define CDC_PROTOCOL_EURO_ISDN                  0x91U
N#define CDC_PROTOCOL_V24_RATE_ADAPTATION        0x92U
N#define CDC_PROTOCOL_CAPI                       0x93U
N#define CDC_PROTOCOL_HOST_BASED_DRIVER          0xFDU
N#define CDC_PROTOCOL_DESCRIBED_IN_PUFD          0xFEU
N
N// Type values for bDescriptorType field of functional descriptors
N// (usbcdc11.pdf, 5.2.3, Table 24)
N#define CDC_CS_INTERFACE                        0x24U
N#define CDC_CS_ENDPOINT                         0x25U
N
N// Type values for bDescriptorSubtype field of functional descriptors
N// (usbcdc11.pdf, 5.2.3, Table 25)
N#define CDC_HEADER                              0x00U
N#define CDC_CALL_MANAGEMENT                     0x01U
N#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02U
N#define CDC_DIRECT_LINE_MANAGEMENT              0x03U
N#define CDC_TELEPHONE_RINGER                    0x04U
N#define CDC_REPORTING_CAPABILITIES              0x05U
N#define CDC_UNION                               0x06U
N#define CDC_COUNTRY_SELECTION                   0x07U
N#define CDC_TELEPHONE_OPERATIONAL_MODES         0x08U
N#define CDC_USB_TERMINAL                        0x09U
N#define CDC_NETWORK_CHANNEL                     0x0AU
N#define CDC_PROTOCOL_UNIT                       0x0BU
N#define CDC_EXTENSION_UNIT                      0x0CU
N#define CDC_MULTI_CHANNEL_MANAGEMENT            0x0DU
N#define CDC_CAPI_CONTROL_MANAGEMENT             0x0EU
N#define CDC_ETHERNET_NETWORKING                 0x0FU
N#define CDC_ATM_NETWORKING                      0x10U
N
N// CDC class-specific request codes
N// (usbcdc11.pdf, 6.2, Table 46)
N// see Table 45 for info about the specific requests.
N#define CDC_SEND_ENCAPSULATED_COMMAND           0x00U
N#define CDC_GET_ENCAPSULATED_RESPONSE           0x01U
N#define CDC_SET_COMM_FEATURE                    0x02U
N#define CDC_GET_COMM_FEATURE                    0x03U
N#define CDC_CLEAR_COMM_FEATURE                  0x04U
N#define CDC_SET_AUX_LINE_STATE                  0x10U
N#define CDC_SET_HOOK_STATE                      0x11U
N#define CDC_PULSE_SETUP                         0x12U
N#define CDC_SEND_PULSE                          0x13U
N#define CDC_SET_PULSE_TIME                      0x14U
N#define CDC_RING_AUX_JACK                       0x15U
N#define CDC_SET_LINE_CODING                     0x20U
N#define CDC_GET_LINE_CODING                     0x21U
N#define CDC_SET_CONTROL_LINE_STATE              0x22U
N#define CDC_SEND_BREAK                          0x23U
N#define CDC_SET_RINGER_PARMS                    0x30U
N#define CDC_GET_RINGER_PARMS                    0x31U
N#define CDC_SET_OPERATION_PARMS                 0x32U
N#define CDC_GET_OPERATION_PARMS                 0x33U
N#define CDC_SET_LINE_PARMS                      0x34U
N#define CDC_GET_LINE_PARMS                      0x35U
N#define CDC_DIAL_DIGITS                         0x36U
N#define CDC_SET_UNIT_PARAMETER                  0x37U
N#define CDC_GET_UNIT_PARAMETER                  0x38U
N#define CDC_CLEAR_UNIT_PARAMETER                0x39U
N#define CDC_GET_PROFILE                         0x3AU
N#define CDC_SET_ETHERNET_MULTICAST_FILTERS      0x40U
N#define CDC_SET_ETHERNET_PMP_FILTER             0x41U
N#define CDC_GET_ETHERNET_PMP_FILTER             0x42U
N#define CDC_SET_ETHERNET_PACKET_FILTER          0x43U
N#define CDC_GET_ETHERNET_STATISTIC              0x44U
N#define CDC_SET_ATM_DATA_FORMAT                 0x50U
N#define CDC_GET_ATM_DEVICE_STATISTICS           0x51U
N#define CDC_SET_ATM_DEFAULT_VC                  0x52U
N#define CDC_GET_ATM_VC_STATISTICS               0x53U
N#define CDC_GET_NTB_PARAMETERS                  0x80U
N#define CDC_GET_NET_ADDRESS                     0x81U
N#define CDC_SET_NET_ADDRESS                     0x82U
N#define CDC_GET_NTB_FORMAT                      0x83U
N#define CDC_SET_NTB_FORMAT                      0x84U
N#define CDC_GET_NTB_INPUT_SIZE                  0x85U
N#define CDC_SET_NTB_INPUT_SIZE                  0x86U
N#define CDC_GET_MAX_DATAGRAM_SIZE               0x87U
N#define CDC_SET_MAX_DATAGRAM_SIZE               0x88U
N#define CDC_GET_CRC_MODE                        0x89U
N#define CDC_SET_CRC_MODE                        0x8AU
N
N// Communication feature selector codes
N// (usbcdc11.pdf, 6.2.2..6.2.4, Table 47)
N#define CDC_ABSTRACT_STATE                      0x01U
N#define CDC_COUNTRY_SETTING                     0x02U
N
N// Feature Status returned for ABSTRACT_STATE Selector
N// (usbcdc11.pdf, 6.2.3, Table 48)
N#define CDC_IDLE_SETTING                        (1U)
N#define CDC_DATA_MULTPLEXED_STATE               (1U << 1)
N
N
N// Control signal bitmap values for the SetControlLineState request
N// (usbcdc11.pdf, 6.2.14, Table 51)
N#define CDC_DTE_PRESENT                         (1U)
N#define CDC_ACTIVATE_CARRIER                    (1U << 1)
N
N// CDC class-specific notification codes
N// (usbcdc11.pdf, 6.3, Table 68)
N// see Table 67 for Info about class-specific notifications
N#define CDC_NOTIFICATION_NETWORK_CONNECTION     0x00U
N#define CDC_RESPONSE_AVAILABLE                  0x01U
N#define CDC_AUX_JACK_HOOK_STATE                 0x08U
N#define CDC_RING_DETECT                         0x09U
N#define CDC_NOTIFICATION_SERIAL_STATE           0x20U
N#define CDC_CALL_STATE_CHANGE                   0x28U
N#define CDC_LINE_STATE_CHANGE                   0x29U
N#define CDC_CONNECTION_SPEED_CHANGE             0x2AU
N
N// UART state bitmap values (Serial state notification).
N// (usbcdc11.pdf, 6.3.5, Table 69)
N#define CDC_SERIAL_STATE_OVERRUN                (1U << 6)  // receive data overrun error has occurred
N#define CDC_SERIAL_STATE_OVERRUN_Pos            (      6)
N#define CDC_SERIAL_STATE_OVERRUN_Msk            (1U << CDC_SERIAL_STATE_OVERRUN_Pos)
N#define CDC_SERIAL_STATE_PARITY                 (1U << 5)  // parity error has occurred
N#define CDC_SERIAL_STATE_PARITY_Pos             (      5)
N#define CDC_SERIAL_STATE_PARITY_Msk             (1U << CDC_SERIAL_STATE_PARITY_Pos)
N#define CDC_SERIAL_STATE_FRAMING                (1U << 4)  // framing error has occurred
N#define CDC_SERIAL_STATE_FRAMING_Pos            (      4)
N#define CDC_SERIAL_STATE_FRAMING_Msk            (1U << CDC_SERIAL_STATE_FRAMING_Pos)
N#define CDC_SERIAL_STATE_RING                   (1U << 3)  // state of ring signal detection
N#define CDC_SERIAL_STATE_RING_Pos               (      3)
N#define CDC_SERIAL_STATE_RING_Msk               (1U << CDC_SERIAL_STATE_RING_Pos)
N#define CDC_SERIAL_STATE_BREAK                  (1U << 2)  // state of break detection
N#define CDC_SERIAL_STATE_BREAK_Pos              (      2)
N#define CDC_SERIAL_STATE_BREAK_Msk              (1U << CDC_SERIAL_STATE_BREAK_Pos)
N#define CDC_SERIAL_STATE_TX_CARRIER             (1U << 1)  // state of transmission carrier
N#define CDC_SERIAL_STATE_TX_CARRIER_Pos         (      1)
N#define CDC_SERIAL_STATE_TX_CARRIER_Msk         (1U << CDC_SERIAL_STATE_TX_CARRIER_Pos)
N#define CDC_SERIAL_STATE_RX_CARRIER             (1U     )  // state of receiver carrier
N#define CDC_SERIAL_STATE_RX_CARRIER_Pos         (      0)
N#define CDC_SERIAL_STATE_RX_CARRIER_Msk         (1U << CDC_SERIAL_STATE_RX_CARRIER_Pos)
N
N
N/*------------------------------------------------------------------------------
N *      Structures based on: - usbcdc11.pdf  (www.usb.org)
N *                           - usbecm120.pdf (www.usb.org)
N *                           - usbncm10.pdf  (www.usb.org)
N *----------------------------------------------------------------------------*/
N
N/// Header functional descriptor
N/// (usbcdc11.pdf, 5.2.3.1)
N/// This header must precede any list of class-specific descriptors.
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bFunctionLength;             ///< size of this descriptor in bytes
N  uint8_t  bDescriptorType;             ///< CS_INTERFACE descriptor type
N  uint8_t  bDescriptorSubtype;          ///< Header functional descriptor subtype
N  uint16_t bcdCDC;                      ///< USB CDC specification release version
N} CDC_HEADER_DESCRIPTOR;
N
N/// Call management functional descriptor
N/// (usbcdc11.pdf, 5.2.3.2)
N/// Describes the processing of calls for the communication class interface.
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bFunctionLength;             ///< size of this descriptor in bytes
N  uint8_t  bDescriptorType;             ///< CS_INTERFACE descriptor type
N  uint8_t  bDescriptorSubtype;          ///< call management functional descriptor subtype
N  uint8_t  bmCapabilities;              ///< capabilities that this configuration supports
N  uint8_t  bDataInterface;              ///< interface number of the data class interface used for call management (optional)
N} CDC_CALL_MANAGEMENT_DESCRIPTOR;
N
N/// Abstract control management functional descriptor
N/// (usbcdc11.pdf, 5.2.3.3)
N/// Describes the command supported by the communication interface class with the Abstract Control Model subclass code.
Ntypedef struct {
N  uint8_t  bFunctionLength;             ///< size of this descriptor in bytes
N  uint8_t  bDescriptorType;             ///< CS_INTERFACE descriptor type
N  uint8_t  bDescriptorSubtype;          ///< abstract control management functional descriptor subtype
N  uint8_t  bmCapabilities;              ///< capabilities supported by this configuration
N} CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR;
N
N/// Union functional descriptors
N/// (usbcdc11.pdf, 5.2.3.8)
N/// Describes the relationship between a group of interfaces that can be considered to form a functional unit.
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bFunctionLength;             ///< size of this descriptor in bytes
N  uint8_t  bDescriptorType;             ///< CS_INTERFACE descriptor type
N  uint8_t  bDescriptorSubtype;          ///< union functional descriptor subtype
N  uint8_t  bMasterInterface;            ///< interface number designated as master
N} CDC_UNION_DESCRIPTOR;
N
N/// Union functional descriptors with one slave interface
N/// (usbcdc11.pdf, 5.2.3.8)
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  CDC_UNION_DESCRIPTOR sUnion;          ///< Union functional descriptor
N  uint8_t  bSlaveInterfaces[1];         ///< Slave interface 0
N} CDC_UNION_1SLAVE_DESCRIPTOR;
N
N/// Line coding structure
N/// Format of the data returned when a GetLineCoding request is received
N/// (usbcdc11.pdf, 6.2.13)
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t dwDTERate;                   ///< Data terminal rate in bits per second
N  uint8_t  bCharFormat;                 ///< Number of stop bits
N  uint8_t  bParityType;                 ///< Parity bit type
N  uint8_t  bDataBits;                   ///< Number of data bits
N} CDC_LINE_CODING;
N
N/// Notification header
N/// Data sent on the notification endpoint must follow this header.
N/// see  USB_SETUP_PACKET in file usb.h
Ntypedef USB_SETUP_PACKET CDC_NOTIFICATION_HEADER;
N
N/// NTB Parameters Structure
N/// (usbncm10.pdf, 6.2.1)
Ntypedef struct {
N  uint16_t wLength;
N  uint16_t bmNtbFormatsSupported;
N  uint32_t dwNtbInMaxSize;
N  uint16_t wNdpInDivisor;
N  uint16_t wNdpInPayloadRemainder;
N  uint16_t wNdpInAlignment;
N  uint16_t Reserved0;
N  uint32_t dwNtbOutMaxSize;
N  uint16_t wNdpOutDivisor;
N  uint16_t wNdpOutPayloadRemainder;
N  uint16_t wNdpOutAlignment;
N  uint16_t Reserved1;
N} CDC_NCM_NTB_PARAM;
N
N/// 16-bit NCM Transfer Header (NTH16) Structure
N/// (usbncm10.pdf, 3.2.1)
Ntypedef struct {
N  uint32_t dwSignature;
N  uint16_t wHeaderLength;
N  uint16_t wSequence;
N  uint16_t wBlockLength;
N  uint16_t wNdpIndex;
N} CDC_NCM_NTB_NTH16;
N
N/// 32-bit NCM Transfer Header (NTH32) Structure
N/// (usbncm10.pdf, 3.2.2)
Ntypedef struct {
N  uint32_t dwSignature;
N  uint16_t wHeaderLength;
N  uint16_t wSequence;
N  uint32_t dwBlockLength;
N  uint32_t dwNdpIndex;
N} CDC_NCM_NTB_NTH32;
N
N/// 16-bit Datagram Pointer Entry Structure
N/// (usbncm10.pdf, 3.3.1)
Ntypedef struct {
N  uint16_t wDatagramIndex;
N  uint16_t wDatagramLength;
N} CDC_NCM_NTB_DATAGRAM16;
N
N/// // 32-bit Datagram Pointer Entry Structure
N/// (usbncm10.pdf, 3.3.2)
Ntypedef struct {
N  uint32_t dwDatagramIndex;
N  uint32_t dwDatagramLength;
N} CDC_NCM_NTB_DATAGRAM32;
N
N/// 16-bit NCM Datagram Pointer Table (NDP16)
N/// (usbncm10.pdf, 3.3.1)
Ntypedef struct {
N  uint32_t dwSignature;
N  uint16_t wLength;
N  uint16_t wNextNdpIndex;
N  CDC_NCM_NTB_DATAGRAM16 datagram[1];
N} CDC_NCM_NTB_NDP16;
N
N/// 32-bit NCM Datagram Pointer Table (NDP32)
N/// (usbncm10.pdf, 3.3.2)
Ntypedef struct {
N  uint32_t dwSignature;
N  uint16_t wLength;
N  uint16_t wReserved6;
N  uint32_t dwNextNdpIndex;
N  uint32_t dwReserved12;
N  CDC_NCM_NTB_DATAGRAM32 datagram[1];
N} CDC_NCM_NTB_NDP32;
N
N#endif
L 24 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 2
N#include "usb_cdc_acm_rndis.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_cdc_acm_rndis.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    usb_cdc_acm_rndis.h
N * Purpose: USB Device Communication Device Class (CDC)
N *          Abstract Control Model (ACM)
N *          Remote Network Driver Interface Specification (RNDIS) Definitions
N *----------------------------------------------------------------------------*/
N
N#ifndef __USB_CDC_ACM_RNDIS_H
N#define __USB_CDC_ACM_RNDIS_H
N
N#include <stdint.h>
N
N#include "usb_compiler.h"
N#include "usb_def.h"
N
N
N/*------------------------------------------------------------------------------
N *  Definitions based on:
N *  [MS-RNDIS].pdf (https://msdn.microsoft.com/en-us/library/ee524902.aspx)
N *----------------------------------------------------------------------------*/
N
N// RNDIS Major version
N#define RNDIS_MAJOR_VERSION                     0x00000001U
N
N// RNDIS Minor version
N#define RNDIS_MINOR_VERSION                     0x00000000U
N
N// RNDIS message types
N#define REMOTE_NDIS_PACKET_MSG                  0x00000001U
N#define REMOTE_NDIS_INITIALIZE_MSG              0x00000002U
N#define REMOTE_NDIS_INITIALIZE_CMPLT            0x80000002U
N#define REMOTE_NDIS_HALT_MSG                    0x00000003U
N#define REMOTE_NDIS_QUERY_MSG                   0x00000004U
N#define REMOTE_NDIS_QUERY_CMPLT                 0x80000004U
N#define REMOTE_NDIS_SET_MSG                     0x00000005U
N#define REMOTE_NDIS_SET_CMPLT                   0x80000005U
N#define REMOTE_NDIS_RESET_MSG                   0x00000006U
N#define REMOTE_NDIS_RESET_CMPLT                 0x80000006U
N#define REMOTE_NDIS_INDICATE_STATUS_MSG         0x00000007U
N#define REMOTE_NDIS_KEEPALIVE_MSG               0x00000008U
N#define REMOTE_NDIS_KEEPALIVE_CMPLT             0x80000008U
N
N// RNDIS messages status values
N#define RNDIS_STATUS_SUCCESS                    0x00000000U     // Success
N#define RNDIS_STATUS_FAILURE                    0xC0000001U     // Unspecified error
N#define RNDIS_STATUS_INVALID_DATA               0xC0010015U     // Invalid data error
N#define RNDIS_STATUS_NOT_SUPPORTED              0xC00000BBU     // Unsupported request error
N#define RNDIS_STATUS_MEDIA_CONNECT              0x4001000BU     // Device is connected to a network medium
N#define RNDIS_STATUS_MEDIA_DISCONNECT           0x4001000CU     // Device is disconnected from the medium
N
N// RNDIS states
N#define RNDIS_UNINITIALIZED                     0x00000000U
N#define RNDIS_BUS_INITIALIZED                   0x00000001U
N#define RNDIS_INITIALIZED                       0x00000002U
N#define RNDIS_DATA_INITIALIZED                  0x00000003U
N
N// RNDIS connection types
N#define RNDIS_DF_CONNECTIONLESS                 0x00000001UL
N#define RNDIS_DF_CONNECTION_ORIENTED            0x00000002UL
N
N
N/*------------------------------------------------------------------------------
N *  Definitions based on:
N *  https://docs.microsoft.com/en-us/windows-hardware/drivers/network/remote-ndis-oids
N *----------------------------------------------------------------------------*/
N
N// General OIDs - required
N#define OID_GEN_SUPPORTED_LIST                  0x00010101
N#define OID_GEN_HARDWARE_STATUS                 0x00010102
N#define OID_GEN_MEDIA_SUPPORTED                 0x00010103
N#define OID_GEN_MEDIA_IN_USE                    0x00010104
N#define OID_GEN_MAXIMUM_FRAME_SIZE              0x00010106
N#define OID_GEN_LINK_SPEED                      0x00010107
N#define OID_GEN_TRANSMIT_BLOCK_SIZE             0x0001010A
N#define OID_GEN_RECEIVE_BLOCK_SIZE              0x0001010B
N#define OID_GEN_VENDOR_ID                       0x0001010C
N#define OID_GEN_VENDOR_DESCRIPTION              0x0001010D
N#define OID_GEN_CURRENT_PACKET_FILTER           0x0001010E
N#define OID_GEN_MAXIMUM_TOTAL_SIZE              0x00010111
N#define OID_GEN_MEDIA_CONNECT_STATUS            0x00010114
N
N// General OIDs - optional
N#define OID_GEN_MAC_OPTIONS                     0x00010113
N#define OID_GEN_VENDOR_DRIVER_VERSION           0x00010116
N#define OID_GEN_NETWORK_LAYER_ADDRESSES         0x00010118  // Set only
N#define OID_GEN_TRANSPORT_HEADER_OFFSET         0x00010119  // Set only
N#define OID_GEN_RNDIS_CONFIG_PARAMETER          0x0001021B  // Set only
N#define OID_GEN_MEDIA_CAPABILITIES              0x00010201
N#define OID_GEN_PHYSICAL_MEDIUM                 0x00010202
N
N// General Statistic OIDs - required
N#define OID_GEN_XMIT_OK                         0x00020101
N#define OID_GEN_RCV_OK                          0x00020102
N#define OID_GEN_XMIT_ERROR                      0x00020103
N#define OID_GEN_RCV_ERROR                       0x00020104
N#define OID_GEN_RCV_NO_BUFFER                   0x00020105
N
N// General Statistic OIDs - optional
N#define OID_GEN_DIRECTED_BYTES_XMIT             0x00020201
N#define OID_GEN_DIRECTED_FRAMES_XMIT            0x00020202
N#define OID_GEN_MULTICAST_BYTES_XMIT            0x00020203
N#define OID_GEN_MULTICAST_FRAMES_XMIT           0x00020204
N#define OID_GEN_BROADCAST_BYTES_XMIT            0x00020205
N#define OID_GEN_BROADCAST_FRAMES_XMIT           0x00020206
N#define OID_GEN_DIRECTED_BYTES_RCV              0x00020207
N#define OID_GEN_DIRECTED_FRAMES_RCV             0x00020208
N#define OID_GEN_MULTICAST_BYTES_RCV             0x00020209
N#define OID_GEN_MULTICAST_FRAMES_RCV            0x0002020A
N#define OID_GEN_BROADCAST_BYTES_RCV             0x0002020B
N#define OID_GEN_BROADCAST_FRAMES_RCV            0x0002020C
N#define OID_GEN_RCV_CRC_ERROR                   0x0002020D
N#define OID_GEN_TRANSMIT_QUEUE_LENGTH           0x0002020E
N
N// 802.3 OIDs - required
N#define OID_802_3_PERMANENT_ADDRESS             0x01010101
N#define OID_802_3_CURRENT_ADDRESS               0x01010102
N#define OID_802_3_MULTICAST_LIST                0x01010103
N#define OID_802_3_MAXIMUM_LIST_SIZE             0x01010104
N
N#define OID_802_3_RCV_ERROR_ALIGNMENT           0x01020101
N#define OID_802_3_XMIT_ONE_COLLISION            0x01020102
N#define OID_802_3_XMIT_MORE_COLLISIONS          0x01020103
N
N// 802.3 OIDs - optional
N#define OID_802_3_MAC_OPTIONS                   0x01010105  // deprecated
N
N// 802.3 Statistic OIDs - optional
N#define OID_802_3_XMIT_DEFERRED                 0x01020201
N#define OID_802_3_XMIT_MAX_COLLISIONS           0x01020202
N#define OID_802_3_RCV_OVERRUN                   0x01020203
N#define OID_802_3_XMIT_UNDERRUN                 0x01020204
N#define OID_802_3_XMIT_HEARTBEAT_FAILURE        0x01020205
N#define OID_802_3_XMIT_TIMES_CRS_LOST           0x01020206
N#define OID_802_3_XMIT_LATE_COLLISIONS          0x01020207
N
N// Power Management OIDs - optional
N#define OID_PNP_CAPABILITIES                    0xFD010100
N#define OID_PNP_SET_POWER                       0xFD010101
N#define OID_PNP_QUERY_POWER                     0xFD010102
N
N// Network Wake Up OIDs - optional
N#define OID_PNP_ADD_WAKE_UP_PATTERN             0xFD010103
N#define OID_PNP_REMOVE_WAKE_UP_PATTERN          0xFD010104
N#define OID_PNP_ENABLE_WAKE_UP                  0xFD010106
N
N// Hardware status codes (OID_GEN_HARDWARE_STATUS)
Ntypedef enum {
N  NdisHardwareStatusReady,
N  NdisHardwareStatusInitializing,
N  NdisHardwareStatusReset,
N  NdisHardwareStatusClosing,
N  NdisHardwareStatusNotReady
N} NDIS_HARDWARE_STATUS_t;
N
N//
N// Medium the Ndis Driver is running on (OID_GEN_MEDIA_SUPPORTED/ OID_GEN_MEDIA_IN_USE).
N//
Ntypedef enum _NDIS_MEDIUM
N{
N  NdisMedium802_3,
N  NdisMedium802_5,
N  NdisMediumFddi,
N  NdisMediumWan,
N  NdisMediumLocalTalk,
N  NdisMediumDix,                // defined for convenience, not a real medium
N  NdisMediumArcnetRaw,
N  NdisMediumArcnet878_2,
N  NdisMediumAtm,
N  NdisMediumWirelessWan,
N  NdisMediumIrda,
N  NdisMediumBpc,
N  NdisMediumCoWan,
N  NdisMedium1394,
N  NdisMediumInfiniBand,
N  NdisMediumTunnel,
N  NdisMediumNative802_11,
N  NdisMediumLoopback,
N  NdisMediumWiMAX,
N  NdisMediumIP,
N  NdisMediumMax                 // Not a real medium, defined as an upper-bound
N} NDIS_MEDIUM_t;
N
N// Physical Medium Type definitions. Used with OID_GEN_PHYSICAL_MEDIUM.
Ntypedef enum {
N  NdisPhysicalMediumUnspecified,
N  NdisPhysicalMediumWirelessLan,
N  NdisPhysicalMediumCableModem,
N  NdisPhysicalMediumPhoneLine,
N  NdisPhysicalMediumPowerLine,
N  NdisPhysicalMediumDSL,        // includes ADSL and UADSL (G.Lite)
N  NdisPhysicalMediumFibreChannel,
N  NdisPhysicalMedium1394,
N  NdisPhysicalMediumWirelessWan,
N  NdisPhysicalMediumNative802_11,
N  NdisPhysicalMediumBluetooth,
N  NdisPhysicalMediumInfiniband,
N  NdisPhysicalMediumWiMax,
N  NdisPhysicalMediumUWB,
N  NdisPhysicalMedium802_3,
N  NdisPhysicalMedium802_5,
N  NdisPhysicalMediumIrda,
N  NdisPhysicalMediumWiredWAN,
N  NdisPhysicalMediumWiredCoWan,
N  NdisPhysicalMediumOther,
N  NdisPhysicalMediumMax         // Not a real physical type, defined as an upper-bound
N} NDIS_PHYSICAL_MEDIUM_t;
N
N// Ethernet sizes
N#define ETH_MAX_SIZE                   (1522U)  // MAC header (14) + Data (1500) + CRC (4) + VLAN id (4)
N#define ETH_MIN_SIZE                   (14U)    // Only MAC header
N#define ETH_MTU_SIZE                   (1500U)  // Ethernet Maximum Transfer Unit
N
N// Defines the state of the LAN media
Ntypedef enum {
N  NdisMediaStateConnected,
N  NdisMediaStateDisconnected
N} NDIS_MEDIA_STATE_t;
N
N// Packet Filter Bits (OID_GEN_CURRENT_PACKET_FILTER)
N#define RNDIS_FILTER_DIRECTED          (1U     )
N#define RNDIS_FILTER_MULTICAST         (1U << 1)
N#define RNDIS_FILTER_ALL_MULTICAST     (1U << 2)
N#define RNDIS_FILTER_BROADCAST         (1U << 3)
N#define RNDIS_FILTER_PROMISCUOUS       (1U << 5)
N
N// MAC ADDRESS type definition
Ntypedef uint8_t MAC_ADDRESS_t[6];
N
N
N/*------------------------------------------------------------------------------
N *  Structures based on:
N *  [MS-RNDIS].pdf (https://msdn.microsoft.com/en-us/library/ee524902.aspx)
N *----------------------------------------------------------------------------*/
N
N// REMOTE_NDIS_INITIALIZE_MSG structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N  uint32_t MajorVersion;
N  uint32_t MinorVersion;
N  uint32_t MaxTransferSize;
N} REMOTE_NDIS_INITIALIZE_MSG_t;
N
N// REMOTE_NDIS_INITIALIZE_CMPLT structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N  uint32_t Status;
N  uint32_t MajorVersion;
N  uint32_t MinorVersion;
N  uint32_t DeviceFlags;
N  uint32_t Medium;
N  uint32_t MaxPacketsPerTransfer;
N  uint32_t MaxTransferSize;
N  uint32_t PacketAlignmentFactor;
N  uint32_t Reserved[2];
N} REMOTE_NDIS_INITIALIZE_CMPLT_t;
N
N// REMOTE_NDIS_HALT_MSG structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N} REMOTE_NDIS_HALT_MSG_t;
N
N// REMOTE_NDIS_QUERY_MSG structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N  uint32_t Oid;
N  uint32_t InformationBufferLength;
N  uint32_t InformationBufferOffset;
N  uint32_t Reserved;
N  uint32_t OIDInputBuffer[1];
N} REMOTE_NDIS_QUERY_MSG_t;
N
N// REMOTE_NDIS_QUERY_CMPLT structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N  uint32_t Status;
N  uint32_t InformationBufferLength;
N  uint32_t InformationBufferOffset;
N  uint32_t OIDInputBuffer[1];
N} REMOTE_NDIS_QUERY_CMPLT_t;
N
N// REMOTE_NDIS_SET_MSG structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N  uint32_t Oid;
N  uint32_t InformationBufferLength;
N  uint32_t InformationBufferOffset;
N  uint32_t Reserved;
N  uint32_t OIDInputBuffer[1];
N} REMOTE_NDIS_SET_MSG_t;
N
N// REMOTE_NDIS_SET_CMPLT structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N  uint32_t Status;
N} REMOTE_NDIS_SET_CMPLT_t;
N
N// REMOTE_NDIS_RESET_MSG structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t Reserved;
N} REMOTE_NDIS_RESET_MSG_t;
N
N// REMOTE_NDIS_RESET_CMPLT structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t Status;
N  uint32_t AddressingReset;
N} REMOTE_NDIS_RESET_CMPLT_t;
N
N// REMOTE_NDIS_INDICATE_STATUS_MSG structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t Status;
N  uint32_t StatusBufferLength;
N  uint32_t StatusBufferOffset;
N  uint32_t DiagnosticInfoBuffer[2];
N  uint32_t StatusBuffer[1];
N} REMOTE_NDIS_INDICATE_STATUS_MSG_t;
N
N// REMOTE_NDIS_KEEPALIVE_MSG structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N} REMOTE_NDIS_KEEPALIVE_MSG_t;
N
N// REMOTE_NDIS_KEEPALIVE_CMPLT structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t RequestID;
N  uint32_t Status;
N} REMOTE_NDIS_KEEPALIVE_CMPLT_t;
N
N// REMOTE_NDIS_PACKET_MSG structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t MessageType;
N  uint32_t MessageLength;
N  uint32_t DataOffset;
N  uint32_t DataLength;
N  uint32_t OutOfBandDataOffset;
N  uint32_t OutOfBandDataLength;
N  uint32_t NumOutOfBandDataElements;
N  uint32_t PerPacketInfoOffset;
N  uint32_t PerPacketInfoLength;
N  uint32_t Reserved[2];
N  uint32_t PayLoad[1];
N} REMOTE_NDIS_PACKET_MSG_t;
N
N// REMOTE_NDIS_OUT_OF_BAND_DATA structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t Size;
N  uint32_t Type;
N  uint32_t ClassInformationOffset;
N  uint32_t OutOfBandData[1];
N} REMOTE_NDIS_OUT_OF_BAND_DATA_t;
N
N// REMOTE_NDIS_PER_PACKET_INFO_DATA structure
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t Size;
N  uint32_t Type;
N  uint32_t PerPacketInformationOffset;
N  uint32_t PerPacketData[1];
N} REMOTE_NDIS_PER_PACKET_INFO_DATA_t;
N
N#endif
L 25 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 2
N#include "usb_hid.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_hid.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    usb_hid.h
N * Purpose: USB Human Interface Device Class Definitions
N *----------------------------------------------------------------------------*/
N
N#ifndef __USB_HID_H__
N#define __USB_HID_H__
N
N#include <stdint.h>
N
N#include "usb_compiler.h"
N
N
N// Human Interface Device Class (HID)
N// HID Subclass Codes
N#define HID_SUBCLASS_NONE                       0x00U
N#define HID_SUBCLASS_BOOT                       0x01U
N
N// HID Protocol Codes
N#define HID_PROTOCOL_NONE                       0x00U
N#define HID_PROTOCOL_BOOT                       0x00U
N#define HID_PROTOCOL_KEYBOARD                   0x01U
N#define HID_PROTOCOL_REPORT                     0x01U
N#define HID_PROTOCOL_MOUSE                      0x02U
N
N
N// HID Descriptor Types
N#define HID_HID_DESCRIPTOR_TYPE                 0x21U
N#define HID_REPORT_DESCRIPTOR_TYPE              0x22U
N#define HID_PHYSICAL_DESCRIPTOR_TYPE            0x23U
N
N// HID Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t bcdHID;
N  uint8_t  bCountryCode;
N  uint8_t  bNumDescriptors;
N  // Array of one or more descriptors
N  __PACKED_STRUCT _HID_DESCRIPTOR_LIST {
X  __packed struct _HID_DESCRIPTOR_LIST {
N    uint8_t  bDescriptorType;
N    uint16_t wDescriptorLength;
N  } DescriptorList[1];
N} HID_DESCRIPTOR;
N
N// HID Request Codes
N#define HID_REQUEST_GET_REPORT                  0x01U
N#define HID_REQUEST_GET_IDLE                    0x02U
N#define HID_REQUEST_GET_PROTOCOL                0x03U
N#define HID_REQUEST_SET_REPORT                  0x09U
N#define HID_REQUEST_SET_IDLE                    0x0AU
N#define HID_REQUEST_SET_PROTOCOL                0x0BU
N
N// HID Report Types
N#define HID_REPORT_INPUT                        0x01U
N#define HID_REPORT_OUTPUT                       0x02U
N#define HID_REPORT_FEATURE                      0x03U
N
N
N// Usage Pages
N#define HID_USAGE_PAGE_UNDEFINED                0x00U
N#define HID_USAGE_PAGE_GENERIC                  0x01U
N#define HID_USAGE_PAGE_SIMULATION               0x02U
N#define HID_USAGE_PAGE_VR                       0x03U
N#define HID_USAGE_PAGE_SPORT                    0x04U
N#define HID_USAGE_PAGE_GAME                     0x05U
N#define HID_USAGE_PAGE_DEV_CONTROLS             0x06U
N#define HID_USAGE_PAGE_KEYBOARD                 0x07U
N#define HID_USAGE_PAGE_LED                      0x08U
N#define HID_USAGE_PAGE_BUTTON                   0x09U
N#define HID_USAGE_PAGE_ORDINAL                  0x0AU
N#define HID_USAGE_PAGE_TELEPHONY                0x0BU
N#define HID_USAGE_PAGE_CONSUMER                 0x0CU
N#define HID_USAGE_PAGE_DIGITIZER                0x0DU
N#define HID_USAGE_PAGE_UNICODE                  0x10U
N#define HID_USAGE_PAGE_ALPHANUMERIC             0x14U
N// ...
N
N
N// Generic Desktop Page (0x01)
N#define HID_USAGE_GENERIC_POINTER               0x01U
N#define HID_USAGE_GENERIC_MOUSE                 0x02U
N#define HID_USAGE_GENERIC_JOYSTICK              0x04U
N#define HID_USAGE_GENERIC_GAMEPAD               0x05U
N#define HID_USAGE_GENERIC_KEYBOARD              0x06U
N#define HID_USAGE_GENERIC_KEYPAD                0x07U
N#define HID_USAGE_GENERIC_X                     0x30U
N#define HID_USAGE_GENERIC_Y                     0x31U
N#define HID_USAGE_GENERIC_Z                     0x32U
N#define HID_USAGE_GENERIC_RX                    0x33U
N#define HID_USAGE_GENERIC_RY                    0x34U
N#define HID_USAGE_GENERIC_RZ                    0x35U
N#define HID_USAGE_GENERIC_SLIDER                0x36U
N#define HID_USAGE_GENERIC_DIAL                  0x37U
N#define HID_USAGE_GENERIC_WHEEL                 0x38U
N#define HID_USAGE_GENERIC_HATSWITCH             0x39U
N#define HID_USAGE_GENERIC_COUNTED_BUFFER        0x3AU
N#define HID_USAGE_GENERIC_BYTE_COUNT            0x3BU
N#define HID_USAGE_GENERIC_MOTION_WAKEUP         0x3CU
N#define HID_USAGE_GENERIC_VX                    0x40U
N#define HID_USAGE_GENERIC_VY                    0x41U
N#define HID_USAGE_GENERIC_VZ                    0x42U
N#define HID_USAGE_GENERIC_VBRX                  0x43U
N#define HID_USAGE_GENERIC_VBRY                  0x44U
N#define HID_USAGE_GENERIC_VBRZ                  0x45U
N#define HID_USAGE_GENERIC_VNO                   0x46U
N#define HID_USAGE_GENERIC_SYSTEM_CTL            0x80U
N#define HID_USAGE_GENERIC_SYSCTL_POWER          0x81U
N#define HID_USAGE_GENERIC_SYSCTL_SLEEP          0x82U
N#define HID_USAGE_GENERIC_SYSCTL_WAKE           0x83U
N#define HID_USAGE_GENERIC_SYSCTL_CONTEXT_MENU   0x84U
N#define HID_USAGE_GENERIC_SYSCTL_MAIN_MENU      0x85U
N#define HID_USAGE_GENERIC_SYSCTL_APP_MENU       0x86U
N#define HID_USAGE_GENERIC_SYSCTL_HELP_MENU      0x87U
N#define HID_USAGE_GENERIC_SYSCTL_MENU_EXIT      0x88U
N#define HID_USAGE_GENERIC_SYSCTL_MENU_SELECT    0x89U
N#define HID_USAGE_GENERIC_SYSCTL_MENU_RIGHT     0x8AU
N#define HID_USAGE_GENERIC_SYSCTL_MENU_LEFT      0x8BU
N#define HID_USAGE_GENERIC_SYSCTL_MENU_UP        0x8CU
N#define HID_USAGE_GENERIC_SYSCTL_MENU_DOWN      0x8DU
N// ...
N
N// Simulation Controls Page (0x02)
N// ...
N#define HID_USAGE_SIMULATION_RUDDER             0xBAU
N#define HID_USAGE_SIMULATION_THROTTLE           0xBBU
N// ...
N
N// Virtual Reality Controls Page (0x03)
N// ...
N
N// Sport Controls Page (0x04)
N// ...
N
N// Game Controls Page (0x05)
N// ...
N
N// Generic Device Controls Page (0x06)
N// ...
N
N// Keyboard/Keypad Page (0x07)
N
N// Keyboard Usage Keys
Nextern const unsigned char HID_KEYBOARD_ID_TO_ASCII[];
N
N// Error "Keys"
N#define HID_USAGE_KEYBOARD_NOEVENT              0x00U
N#define HID_USAGE_KEYBOARD_ROLLOVER             0x01U
N#define HID_USAGE_KEYBOARD_POSTFAIL             0x02U
N#define HID_USAGE_KEYBOARD_UNDEFINED            0x03U
N
N// Letters
N#define HID_USAGE_KEYBOARD_aA                   0x04U
N#define HID_USAGE_KEYBOARD_zZ                   0x1DU
N
N// Numbers
N#define HID_USAGE_KEYBOARD_ONE                  0x1EU
N#define HID_USAGE_KEYBOARD_ZERO                 0x27U
N
N#define HID_USAGE_KEYBOARD_RETURN               0x28U
N#define HID_USAGE_KEYBOARD_ESCAPE               0x29U
N#define HID_USAGE_KEYBOARD_DELETE               0x2AU
N
N// Funtion Keys
N#define HID_USAGE_KEYBOARD_F1                   0x3AU
N#define HID_USAGE_KEYBOARD_F12                  0x45U
N
N#define HID_USAGE_KEYBOARD_PRINT_SCREEN         0x46U
N
N// Modifier Keys
N#define HID_USAGE_KEYBOARD_LCTRL                0xE0U
N#define HID_USAGE_KEYBOARD_LSHFT                0xE1U
N#define HID_USAGE_KEYBOARD_LALT                 0xE2U
N#define HID_USAGE_KEYBOARD_LGUI                 0xE3U
N#define HID_USAGE_KEYBOARD_RCTRL                0xE4U
N#define HID_USAGE_KEYBOARD_RSHFT                0xE5U
N#define HID_USAGE_KEYBOARD_RALT                 0xE6U
N#define HID_USAGE_KEYBOARD_RGUI                 0xE7U
N#define HID_USAGE_KEYBOARD_SCROLL_LOCK          0x47U
N#define HID_USAGE_KEYBOARD_NUM_LOCK             0x53U
N#define HID_USAGE_KEYBOARD_CAPS_LOCK            0x39U
N
N// Modifier Keys (values)
N#define HID_USAGE_KEYBOARD_MOD_LCTRL            0x01U
N#define HID_USAGE_KEYBOARD_MOD_LSHIFT           0x02U
N#define HID_USAGE_KEYBOARD_MOD_LALTL            0x04U
N#define HID_USAGE_KEYBOARD_MOD_LGUI             0x08U
N#define HID_USAGE_KEYBOARD_MOD_RCTRL            0x10U
N#define HID_USAGE_KEYBOARD_MOD_RSHIFT           0x20U
N#define HID_USAGE_KEYBOARD_MOD_RALTL            0x40U
N#define HID_USAGE_KEYBOARD_MOD_RGUI             0x80U
N
N// ...
N
N// LED Page (0x08)
N#define HID_USAGE_LED_NUM_LOCK                  0x01U
N#define HID_USAGE_LED_CAPS_LOCK                 0x02U
N#define HID_USAGE_LED_SCROLL_LOCK               0x03U
N#define HID_USAGE_LED_COMPOSE                   0x04U
N#define HID_USAGE_LED_KANA                      0x05U
N#define HID_USAGE_LED_POWER                     0x06U
N#define HID_USAGE_LED_SHIFT                     0x07U
N#define HID_USAGE_LED_DO_NOT_DISTURB            0x08U
N#define HID_USAGE_LED_MUTE                      0x09U
N#define HID_USAGE_LED_TONE_ENABLE               0x0AU
N#define HID_USAGE_LED_HIGH_CUT_FILTER           0x0BU
N#define HID_USAGE_LED_LOW_CUT_FILTER            0x0CU
N#define HID_USAGE_LED_EQUALIZER_ENABLE          0x0DU
N#define HID_USAGE_LED_SOUND_FIELD_ON            0x0EU
N#define HID_USAGE_LED_SURROUND_FIELD_ON         0x0FU
N#define HID_USAGE_LED_REPEAT                    0x10U
N#define HID_USAGE_LED_STEREO                    0x11U
N#define HID_USAGE_LED_SAMPLING_RATE_DETECT      0x12U
N#define HID_USAGE_LED_SPINNING                  0x13U
N#define HID_USAGE_LED_CAV                       0x14U
N#define HID_USAGE_LED_CLV                       0x15U
N#define HID_USAGE_LED_RECORDING_FORMAT_DET      0x16U
N#define HID_USAGE_LED_OFF_HOOK                  0x17U
N#define HID_USAGE_LED_RING                      0x18U
N#define HID_USAGE_LED_MESSAGE_WAITING           0x19U
N#define HID_USAGE_LED_DATA_MODE                 0x1AU
N#define HID_USAGE_LED_BATTERY_OPERATION         0x1BU
N#define HID_USAGE_LED_BATTERY_OK                0x1CU
N#define HID_USAGE_LED_BATTERY_LOW               0x1DU
N#define HID_USAGE_LED_SPEAKER                   0x1EU
N#define HID_USAGE_LED_HEAD_SET                  0x1FU
N#define HID_USAGE_LED_HOLD                      0x20U
N#define HID_USAGE_LED_MICROPHONE                0x21U
N#define HID_USAGE_LED_COVERAGE                  0x22U
N#define HID_USAGE_LED_NIGHT_MODE                0x23U
N#define HID_USAGE_LED_SEND_CALLS                0x24U
N#define HID_USAGE_LED_CALL_PICKUP               0x25U
N#define HID_USAGE_LED_CONFERENCE                0x26U
N#define HID_USAGE_LED_STAND_BY                  0x27U
N#define HID_USAGE_LED_CAMERA_ON                 0x28U
N#define HID_USAGE_LED_CAMERA_OFF                0x29U
N#define HID_USAGE_LED_ON_LINE                   0x2AU
N#define HID_USAGE_LED_OFF_LINE                  0x2BU
N#define HID_USAGE_LED_BUSY                      0x2CU
N#define HID_USAGE_LED_READY                     0x2DU
N#define HID_USAGE_LED_PAPER_OUT                 0x2EU
N#define HID_USAGE_LED_PAPER_JAM                 0x2FU
N#define HID_USAGE_LED_REMOTE                    0x30U
N#define HID_USAGE_LED_FORWARD                   0x31U
N#define HID_USAGE_LED_REVERSE                   0x32U
N#define HID_USAGE_LED_STOP                      0x33U
N#define HID_USAGE_LED_REWIND                    0x34U
N#define HID_USAGE_LED_FAST_FORWARD              0x35U
N#define HID_USAGE_LED_PLAY                      0x36U
N#define HID_USAGE_LED_PAUSE                     0x37U
N#define HID_USAGE_LED_RECORD                    0x38U
N#define HID_USAGE_LED_ERROR                     0x39U
N#define HID_USAGE_LED_SELECTED_INDICATOR        0x3AU
N#define HID_USAGE_LED_IN_USE_INDICATOR          0x3BU
N#define HID_USAGE_LED_MULTI_MODE_INDICATOR      0x3CU
N#define HID_USAGE_LED_INDICATOR_ON              0x3DU
N#define HID_USAGE_LED_INDICATOR_FLASH           0x3EU
N#define HID_USAGE_LED_INDICATOR_SLOW_BLINK      0x3FU
N#define HID_USAGE_LED_INDICATOR_FAST_BLINK      0x40U
N#define HID_USAGE_LED_INDICATOR_OFF             0x41U
N#define HID_USAGE_LED_FLASH_ON_TIME             0x42U
N#define HID_USAGE_LED_SLOW_BLINK_ON_TIME        0x43U
N#define HID_USAGE_LED_SLOW_BLINK_OFF_TIME       0x44U
N#define HID_USAGE_LED_FAST_BLINK_ON_TIME        0x45U
N#define HID_USAGE_LED_FAST_BLINK_OFF_TIME       0x46U
N#define HID_USAGE_LED_INDICATOR_COLOR           0x47U
N#define HID_USAGE_LED_RED                       0x48U
N#define HID_USAGE_LED_GREEN                     0x49U
N#define HID_USAGE_LED_AMBER                     0x4AU
N#define HID_USAGE_LED_GENERIC_INDICATOR         0x4BU
N
N// Button Page (0x09)
N//   There is no need to label these usages.
N
N// Ordinal Page (0x0A)
N//   There is no need to label these usages.
N
N// Telephony Device Page (0x0B)
N#define HID_USAGE_TELEPHONY_PHONE               0x01U
N#define HID_USAGE_TELEPHONY_ANSWERING_MACHINE   0x02U
N#define HID_USAGE_TELEPHONY_MESSAGE_CONTROLS    0x03U
N#define HID_USAGE_TELEPHONY_HANDSET             0x04U
N#define HID_USAGE_TELEPHONY_HEADSET             0x05U
N#define HID_USAGE_TELEPHONY_KEYPAD              0x06U
N#define HID_USAGE_TELEPHONY_PROGRAMMABLE_BUTTON 0x07U
N// ...
N
N// Consumer Page (0x0C)
N#define HID_USAGE_CONSUMER_CONTROL              0x01U
N// ...
N
N// and others ...
N
N
N// HID Report Item Macros
N
N// Main Items
N#define HID_Input(x)                            0x81U,x
N#define HID_Output(x)                           0x91U,x
N#define HID_Feature(x)                          0xB1U,x
N#define HID_Collection(x)                       0xA1U,x
N#define HID_EndCollection                       0xC0U
N
N// Data (Input, Output, Feature)
N#define HID_Data                                0U
N#define HID_Constant                            1U << 0
N#define HID_Array                               0U
N#define HID_Variable                            1U << 1
N#define HID_Absolute                            0U
N#define HID_Relative                            1U << 2
N#define HID_NoWrap                              0U
N#define HID_Wrap                                1U << 3
N#define HID_Linear                              0U
N#define HID_NonLinear                           1U << 4
N#define HID_PreferredState                      0U
N#define HID_NoPreferred                         1U << 5
N#define HID_NoNullPosition                      0U
N#define HID_NullState                           1U << 6
N#define HID_NonVolatile                         0U
N#define HID_Volatile                            1U << 7
N
N// Collection Data
N#define HID_Physical                            0x00U
N#define HID_Application                         0x01U
N#define HID_Logical                             0x02U
N#define HID_Report                              0x03U
N#define HID_NamedArray                          0x04U
N#define HID_UsageSwitch                         0x05U
N#define HID_UsageModifier                       0x06U
N
N// Global Items
N#define HID_UsagePage(x)                        0x05U,x
N#define HID_UsagePageVendor(x)                  0x06U,x,0xFFU
N#define HID_LogicalMin(x)                       0x15U,x
N#define HID_LogicalMinS(x)                      0x16U,(x&0xFFU),((x>>8)&0xFFU)
N#define HID_LogicalMinL(x)                      0x17U,(x&0xFFU),((x>>8)&0xFFU),((x>>16)&0xFFU),((x>>24)&0xFFU)
N#define HID_LogicalMax(x)                       0x25U,x
N#define HID_LogicalMaxS(x)                      0x26U,(x&0xFFU),((x>>8)&0xFFU)
N#define HID_LogicalMaxL(x)                      0x27U,(x&0xFFU),((x>>8)&0xFFU),((x>>16)&0xFFU),((x>>24)&0xFFU)
N#define HID_PhysicalMin(x)                      0x35U,x
N#define HID_PhysicalMinS(x)                     0x36U,(x&0xFFU),((x>>8)&0xFFU)
N#define HID_PhysicalMinL(x)                     0x37U,(x&0xFFU),((x>>8)&0xFFU),((x>>16)&0xFFU),((x>>24)&0xFFU)
N#define HID_PhysicalMax(x)                      0x45U,x
N#define HID_PhysicalMaxS(x)                     0x46U,(x&0xFFU),((x>>8)&0xFFU)
N#define HID_PhysicalMaxL(x)                     0x47U,(x&0xFFU),((x>>8)&0xFFU),((x>>16)&0xFFU),((x>>24)&0xFFU)
N#define HID_UnitExponent(x)                     0x55U,x
N#define HID_Unit(x)                             0x65U,x
N#define HID_UnitS(x)                            0x66U,(x&0xFFU),((x>>8)&0xFFU)
N#define HID_UnitL(x)                            0x67U,(x&0xFFU),((x>>8)&0xFFU),((x>>16)&0xFFU),((x>>24)&0xFFU)
N#define HID_ReportSize(x)                       0x75U,x
N#define HID_ReportSizeS(x)                      0x76U,(x&0xFFU),((x>>8)&0xFFU)
N#define HID_ReportSizeL(x)                      0x77U,(x&0xFFU),((x>>8)&0xFFU),((x>>16)&0xFFU),((x>>24)&0xFFU)
N#define HID_ReportID(x)                         0x85U,x
N#define HID_ReportCount(x)                      0x95U,x
N#define HID_ReportCountS(x)                     0x96U,(x&0xFFU),((x>>8)&0xFFU)
N#define HID_ReportCountL(x)                     0x97U,(x&0xFFU),((x>>8)&0xFFU),((x>>16)&0xFFU),((x>>24)&0xFFU)
N#define HID_Push                                0xA4U
N#define HID_Pop                                 0xB4U
N
N// Local Items
N#define HID_Usage(x)                            0x09U,x
N#define HID_UsageMin(x)                         0x19U,x
N#define HID_UsageMax(x)                         0x29U,x
N
N#endif
L 26 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 2
N#include "usb_msc.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_msc.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    usb_msc.h
N * Purpose: USB Mass Storage Device Class Definitions
N *----------------------------------------------------------------------------*/
N
N#ifndef __USB_MSC_H__
N#define __USB_MSC_H__
N
N#include <stdint.h>
N
N#include "usb_compiler.h"
N
N
N// MSC Subclass Codes
N#define MSC_SUBCLASS_RBC                0x01U
N#define MSC_SUBCLASS_SFF8020I_MMC2      0x02U
N#define MSC_SUBCLASS_QIC157             0x03U
N#define MSC_SUBCLASS_UFI                0x04U
N#define MSC_SUBCLASS_SFF8070I           0x05U
N#define MSC_SUBCLASS_SCSI               0x06U
N
N// MSC Protocol Codes
N#define MSC_PROTOCOL_CBI_INT            0x00U
N#define MSC_PROTOCOL_CBI_NOINT          0x01U
N#define MSC_PROTOCOL_BULK_ONLY          0x50U
N
N// MSC Request Codes
N#define MSC_REQUEST_RESET               0xFFU
N#define MSC_REQUEST_GET_MAX_LUN         0xFEU
N
N// MSC Bulk-only Stage
N#define MSC_BS_CBW                      0U      // Command Block Wrapper
N#define MSC_BS_DATA_OUT                 1U      // Data Out Phase
N#define MSC_BS_DATA_IN                  2U      // Data In Phase
N#define MSC_BS_DATA_IN_LAST             3U      // Data In Last Phase
N#define MSC_BS_DATA_IN_LAST_STALL       4U      // Data In Last Phase with Stall
N#define MSC_BS_CSW                      5U      // Command Status Wrapper
N#define MSC_BS_ERROR                    6U      // Error
N#define MSC_BS_RESET                    7U      // Bulk-Only Mass Storage Reset
N
N// Bulk-only Command Block Wrapper
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t dSignature;
N  uint32_t dTag;
N  uint32_t dDataLength;
N  uint8_t  bmFlags;
N  uint8_t  bLUN;
N  uint8_t  bCBLength;
N  uint8_t  CB[16];
N} MSC_CBW;
N
N// Bulk-only Command Status Wrapper
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t dSignature;
N  uint32_t dTag;
N  uint32_t dDataResidue;
N  uint8_t  bStatus;
N} MSC_CSW;
N
N#define MSC_CBW_Signature               0x43425355U
N#define MSC_CSW_Signature               0x53425355U
N
N// CSW Status Definitions
N#define CSW_CMD_PASSED                  0x00U
N#define CSW_CMD_FAILED                  0x01U
N#define CSW_PHASE_ERROR                 0x02U
N
N// SCSI Commands
N#define SCSI_TEST_UNIT_READY            0x00U
N#define SCSI_REQUEST_SENSE              0x03U
N#define SCSI_FORMAT_UNIT                0x04U
N#define SCSI_INQUIRY                    0x12U
N#define SCSI_MODE_SELECT6               0x15U
N#define SCSI_MODE_SENSE6                0x1AU
N#define SCSI_START_STOP_UNIT            0x1BU
N#define SCSI_MEDIA_REMOVAL              0x1EU
N#define SCSI_READ_FORMAT_CAPACITIES     0x23U
N#define SCSI_READ_CAPACITY              0x25U
N#define SCSI_READ10                     0x28U
N#define SCSI_WRITE10                    0x2AU
N#define SCSI_VERIFY10                   0x2FU
N#define SCSI_SYNC_CACHE10               0x35U
N#define SCSI_READ12                     0xA8U
N#define SCSI_WRITE12                    0xAAU
N#define SCSI_MODE_SELECT10              0x55U
N#define SCSI_MODE_SENSE10               0x5AU
N#define SCSI_SYNC_CACHE16               0x91U
N#define SCSI_ATA_COMMAND_PASS_THROUGH12 0xA1U
N#define SCSI_ATA_COMMAND_PASS_THROUGH16 0x85U
N#define SCSI_SERVICE_ACTION_IN12        0xABU
N#define SCSI_SERVICE_ACTION_IN16        0x9EU
N#define SCSI_SERVICE_ACTION_OUT12       0xA9U
N#define SCSI_SERVICE_ACTION_OUT16       0x9FU
N#define SCSI_REPORT_ID_INFO             0xA3U
N
N#endif
L 27 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 2
N#include "usb_ms.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\usb_ms.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::USB
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    usb_ms.h
N * Purpose: USB Microsoft Descriptors Specific Definitions
N *----------------------------------------------------------------------------*/
N
N#ifndef __USB_MS_H
N#define __USB_MS_H
N
N#include <stdint.h>
N
N#include "usb_compiler.h"
N
N
N// USB Microsoft String Descriptor Index
N#define USB_MS_OS_STRING_DESCRIPTOR_IDX                 0xEEU
N
N// USB Microsoft OS Feature Descriptor Index
N#define USB_MS_OS_FEAT_EXT_COMPAT_ID_DESCRIPTOR_IDX     4U      // Extended Compat ID Descriptor Index
N#define USB_MS_OS_FEAT_EXT_PROP_DESCRIPTOR_IDX          5U      // Extended Properties Descriptor Index
N
N
N/// Microsoft OS String Descriptor
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint8_t  qwSignature[14];
N  uint8_t  bMS_VendorCode;
N  uint8_t  bPad;
N} USB_MS_OS_STRING_DESCRIPTOR;
N
N/// Microsoft OS Feature Descriptor: Extended Compat ID Header
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t dwLength;
N  uint16_t bcdVersion;
N  uint16_t wIndex;
N  uint8_t  bCount;
N  uint8_t  reserved[7];
N} USB_MS_OS_FEAT_EXT_COMPAT_ID_HEADER;
N
N/// Microsoft OS Feature Descriptor: Extended Compat ID Function
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint8_t  bFirstInterfaceNum;
N  uint8_t  reserved1;
N  uint8_t  compatibleID[8];
N  uint8_t  subCompatibleID[8];
N  uint8_t  reserved2[6];
N} USB_MS_OS_FEAT_EXT_COMPAT_ID_FUNCTION;
N
N/// Microsoft OS Feature Descriptor: Extended Properties Header
Ntypedef __PACKED_STRUCT {
Xtypedef __packed struct {
N  uint32_t dwLength;
N  uint16_t bcdVersion;
N  uint16_t wIndex;
N  uint16_t wCount;
N} USB_MS_OS_FEAT_EXT_PROP_HEADER;
N
N#endif  // __USB_MS_H
L 28 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include\rl_usb.h" 2
N
N
N///  ==== USB Constants and Defines ====
N
N/// Status code values returned by USB library functions.
Ntypedef enum {
N  usbOK                       =    0U,  ///< Function completed with no error
N
N  usbTimeout,                           ///< Function completed; time-out occurred
N  usbInvalidParameter,                  ///< Invalid Parameter error: a mandatory parameter was missing or specified an incorrect object
N
N  usbThreadError              = 0x10U,  ///< CMSIS-RTOS Thread creation/termination failed
N  usbTimerError,                        ///< CMSIS-RTOS Timer creation/deletion failed
N  usbSemaphoreError,                    ///< CMSIS-RTOS Semaphore creation failed
N  usbMutexError,                        ///< CMSIS-RTOS Mutex creation failed
N
N  usbControllerError          = 0x20U,  ///< Controller does not exist
N  usbDeviceError,                       ///< Device does not exist
N  usbDriverError,                       ///< Driver function produced error
N  usbDriverBusy,                        ///< Driver function is busy
N  usbMemoryError,                       ///< Memory management function produced error
N  usbNotConfigured,                     ///< Device is not configured (is connected)
N  usbClassErrorADC,                     ///< Audio Device Class (ADC) error (no device or device produced error)
N  usbClassErrorCDC,                     ///< Communication Device Class (CDC) error (no device or device produced error)
N  usbClassErrorHID,                     ///< Human Interface Device (HID) error (no device or device produced error)
N  usbClassErrorMSC,                     ///< Mass Storage Device (MSC) error (no device or device produced error)
N  usbClassErrorCustom,                  ///< Custom device Class (Class) error (no device or device produced error)
N  usbUnsupportedClass,                  ///< Unsupported Class
N
N  usbTransferStall            = 0x40U,  ///< Transfer handshake was stall
N  usbTransferError,                     ///< Transfer error
N
N  usbUnknownError             = 0xFFU   ///< Unspecified USB error
N} usbStatus;
N
N/// Endianess handling macros
N#ifdef __BIG_ENDIAN
S #define U32_LE(v)  (uint32_t)(__REV(v))
S #define U16_LE(v)  (uint16_t)(__REV(v) >> 16)
S #define U32_BE(v)  (uint32_t)(v)
S #define U16_BE(v)  (uint16_t)(v)
N#else
N #define U32_BE(v)  (uint32_t)(__REV(v))
N #define U16_BE(v)  (uint16_t)(__REV(v) >> 16)
N #define U32_LE(v)  (uint32_t)(v)
N #define U16_LE(v)  (uint16_t)(v)
N#endif
N
N//  ==== USB Device Constants and Defines ====
N
N/// USB Device Custom Class API enumerated constants
Ntypedef enum {
N  usbdRequestNotProcessed = 0U,         ///< Request not processed
N  usbdRequestOK,                        ///< Request processed and OK
N  usbdRequestStall,                     ///< Request processed but unsupported
N  usbdRequestNAK                        ///< Request processed but busy
N} usbdRequestStatus;
N
N/// USB Device MSC Check Media bit masks
N#define USBD_MSC_MEDIA_READY     (1UL)          ///< Media Ready
N#define USBD_MSC_MEDIA_PROTECTED (1UL<<1)       ///< Media Write Protected
N
N/// USB Device HID Class API enumerated constants
Ntypedef enum {
N  USBD_HID_REQ_EP_CTRL = 0U,            ///< Request from control endpoint
N  USBD_HID_REQ_EP_INT,                  ///< Request from interrupt endpoint
N  USBD_HID_REQ_PERIOD_UPDATE            ///< Request from periodic update
N} USBD_HID_REQ_t;
N
N/// USB Device thread enumerator
Ntypedef enum {
N  usbdThreadCore  =  0U,
N  usbdThreadCC,
N  usbdThreadADC,
N  usbdThreadCDC_Int,
N  usbdThreadCDC_Bulk,
N  usbdThreadHID,
N  usbdThreadMSC
N} usbdThread_t;
N
N/// USB Device semaphore enumerator
Ntypedef enum {
N  usbdSemaphoreCore  =  0U,
N  usbdSemaphoreEndpoint,
N  usbdSemaphoreHID
N} usbdSemaphore_t;
N
N/* USB Device State structure */
N/// @cond USBD_STATE_cond
Ntypedef struct {
N  uint32_t vbus     :  1;               ///< USB Device VBUS state
N  uint32_t speed    :  2;               ///< USB Device enumerated speed (USB_SPEED_LOW, USB_SPEED_FULL or USB_SPEED_HIGH)
N  uint32_t active   :  1;               ///< USB Device bus activity
N  uint32_t reserved : 28;               ///< reserved
N} USBD_STATE;
N/// @endcond
N
N/* USB Host Constants and Defines */
N
N/// USB Host Notification enumerated constants
Ntypedef enum {
N  USBH_NOTIFY_CONNECT = 0U,             ///< Port connection happened
N  USBH_NOTIFY_DISCONNECT,               ///< Port disconnection happened
N  USBH_NOTIFY_OVERCURRENT,              ///< Port overcurrent happened
N  USBH_NOTIFY_REMOTE_WAKEUP,            ///< Port remote wakeup signaling happened
N  USBH_NOTIFY_READY,                    ///< Device was successfully enumerated, initialized and is ready for communication
N  USBH_NOTIFY_UNKNOWN_DEVICE,           ///< Device was successfully enumerated but there is no driver for it
N  USBH_NOTIFY_INSUFFICIENT_POWER,       ///< Device requires more power consumption than available
N  USBH_NOTIFY_CONFIGURATION_FAILED,     ///< Device was not successfully configured (not enough resources)
N  USBH_NOTIFY_INITIALIZATION_FAILED     ///< Device was not successfully initialized
N} USBH_NOTIFY;
N
N/* USB Host Pipe handle type */
Ntypedef uint32_t USBH_PIPE_HANDLE;
N
N/// USB Host thread enumerator
Ntypedef enum {
N  usbhThreadCore         =  0U,
N  usbhThreadCDC,
N  usbhThreadHID
N} usbhThread_t;
N
N/// USB Host mutex enumerator
Ntypedef enum {
N  usbhMutexCore          =  0U
N} usbhMutex_t;
N
N/// USB Host semaphore enumerator
Ntypedef enum {
N  usbhSemaphoreCore      =  0U
N} usbhSemaphore_t;
N
N/// Mouse state information.
Ntypedef struct {
N  uint8_t reserved;                     ///< Reserved byte (for alignment)
N  uint8_t button;                       ///< Current button states
N  int16_t x;                            ///< Absolute X position change
N  int16_t y;                            ///< Absolute Y position change
N} usbHID_MouseState;
N
N
N//  ==== USB Device Functions ====
N
N/// \brief Get version of USB Device stack
N/// \return                             version (major.minor.revision : mmnnnrrrr decimal)
Nextern uint32_t USBD_GetVersion (void);
N
N/// \brief Initialize USB Device stack and controller
N/// \param[in]     device               index of USB Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_Initialize (uint8_t device);
N
N/// \brief De-initialize USB Device stack and controller
N/// \param[in]     device               index of USB Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_Uninitialize (uint8_t device);
N
N/// \brief Activate pull-up on D+ or D- line to signal USB Device connection on USB Bus
N/// \param[in]     device               index of USB Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_Connect (uint8_t device);
N
N/// \brief Disconnect USB Device from USB Bus
N/// \param[in]     device               index of USB Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_Disconnect (uint8_t device);
N
N/// \brief Retrieve USB Device configuration status
N/// \param[in]     device               index of USB Device.
N/// \return                             device is in configured state and ready to communicate or is not configured and not ready to communicate :
N///                                       - value true :  device is in configured state and ready to communicate
N///                                       - value false : device is not configured and not ready to communicate
Nextern bool USBD_Configured (uint8_t device);
Xextern _Bool USBD_Configured (uint8_t device);
N
N/// \brief Retrieve USB Device state
N/// \param[in]     device               index of USB Device.
N/// \return                             structure containing device state information.
Nextern USBD_STATE USBD_GetState (uint8_t device);
N
N/// \brief Set USB Device serial number string
N/// \param[in]     device               index of USB Device.
N/// \param[in]     string               serial number string.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_SetSerialNumber (uint8_t device, const char *string);
N
N#ifdef __DOXYGEN__
S
S// following functions are available for each instance of a Device.
S// generic prefix USBD_Devicen is USBD_Device0 for Device instance 0.
S
S/// \brief Callback function called during \ref USBD_Initialize to initialize the USB Device
S/// \return                             none.
Svoid USBD_Devicen_Initialize (void);
S 
S/// \brief Callback function called during \ref USBD_Uninitialize to de-initialize the USB Device
S/// \return                             none.
Svoid USBD_Devicen_Uninitialize (void);
S 
S/// \brief Callback function called when VBUS level changes
S/// \param[in]     level                current VBUS level :
S///                                       - value true :  VBUS level is high
S///                                       - value false : VBUS level is low
S/// \return                             none.
Svoid USBD_Devicen_VbusChanged (bool level);
S 
S/// \brief Callback function called upon USB Bus Reset signaling
S/// \return                             none.
Svoid USBD_Devicen_Reset (void);
S 
S/// \brief Callback function called when USB Bus speed has changed to high-speed
S/// \return                             none.
Svoid USBD_Devicen_HighSpeedActivated (void);
S
S/// \brief Callback function called when USB Bus goes into suspend mode (no bus activity for 3 ms)
S/// \return                             none.
Svoid USBD_Devicen_Suspended (void);
S
S/// \brief Callback function called when USB Bus activity has resumed
S/// \return                             none.
Svoid USBD_Devicen_Resumed (void);
S
S/// \brief Callback function called when Device configuration has changed
S/// \param[in]     val                  current configuration value :
S///                                       - value 0 :   not configured
S///                                       - value > 0 : active configuration
S/// \return                             none.
Svoid USBD_Devicen_ConfigurationChanged (uint8_t val);
S
S/// \brief Callback function called when Set Feature for Remote Wakeup was requested over Control Endpoint 0
S/// \return                             none.
Svoid USBD_Devicen_EnableRemoteWakeup (void);
S
S/// \brief Callback function called when Clear Feature for Remote Wakeup was requested over Control Endpoint 0
S/// \return                             none.
Svoid USBD_Devicen_DisableRemoteWakeup (void);
S 
S/// \brief Callback function called when Device received SETUP PACKET on Control Endpoint 0
S/// \param[in]     setup_packet         pointer to received setup packet.
S/// \param[in,out] buf                  pointer to data buffer used for data stage requested by setup packet.
S/// \param[in,out] len                  pointer to number of data bytes in data stage requested by setup packet.
S/// \return        usbdRequestStatus    enumerator value indicating the function execution status :
S///                                       - value usbdRequestNotProcessed : request was not processed; processing will be done by USB library
S///                                       - value usbdRequestOK :           request was processed successfully (send Zero-Length Packet if no data stage)
S///                                       - value usbdRequestStall :        request was processed but is not supported (stall Endpoint 0)
SusbdRequestStatus USBD_Devicen_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
S
S/// \brief Callback function called when SETUP PACKET was processed by USB library
S/// \param[in]     setup_packet         pointer to processed setup packet.
S/// \return                             none.
Svoid USBD_Devicen_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
S
S/// \brief Callback function called when Device received OUT DATA on Control Endpoint 0
S/// \param[in]     len                  number of received data bytes.
S/// \return        usbdRequestStatus    enumerator value indicating the function execution status :
S///                                       - value usbdRequestNotProcessed : request was not processed; processing will be done by USB library
S///                                       - value usbdRequestOK :           request was processed successfully (send Zero-Length Packet)
S///                                       - value usbdRequestStall :        request was processed but is not supported (stall Endpoint 0)
S///                                       - value usbdRequestNAK :          request was processed but the device is busy (return NAK)
SusbdRequestStatus USBD_Devicen_Endpoint0_OutDataReceived (uint32_t len);
S
S/// \brief Callback function called when Device sent IN DATA on Control Endpoint 0
S/// \param[in]     len                  number of sent data bytes.
S/// \return        usbdRequestStatus    enumerator value indicating the function execution status :
S///                                       - value usbdRequestNotProcessed : request was not processed; processing will be done by USB library
S///                                       - value usbdRequestOK :           request was processed successfully (return ACK)
S///                                       - value usbdRequestStall :        request was processed but is not supported (stall Endpoint 0)
S///                                       - value usbdRequestNAK :          request was processed but the device is busy (return NAK)
SusbdRequestStatus USBD_Devicen_Endpoint0_InDataSent (uint32_t len);
S
N#endif // __DOXYGEN
N
N//  ==== USB Device Audio Device Functions ====
N
N#ifdef __DOXYGEN__
S
S// following functions are available for each instance of a ADC class.
S// generic prefix USBD_ADCn is USBD_ADC0 for ADC class instance 0.
S
S/// \brief Callback function called during \ref USBD_Initialize to initialize the USB ADC class instance
S/// \return                             none.
Svoid USBD_ADCn_Initialize (void);
S
S/// \brief Callback function called during \ref USBD_Uninitialize to de-initialize the USB ADC class instance
S/// \return                             none.
Svoid USBD_ADCn_Uninitialize (void);
S
S/// \brief Callback function called when play started
S/// \return                             none.
Svoid USBD_ADCn_PlayStart (void);
S
S/// \brief Callback function called when play stopped
S/// \return                             none.
Svoid USBD_ADCn_PlayStop (void);
S
S/// \brief Callback function called when speaker mute setting changed
S/// \param[in]     ch                   channel index :
S///                                       - value 0 : master channel
S///                                       - value 1 : left speaker (in stereo mode)
S///                                       - value 2 : right speaker (in stereo mode)
S/// \param[in]     on                   current mute setting :
S///                                       - value false : mute off
S///                                       - value true :  mute on
S/// \return                             none.
Svoid USBD_ADCn_SetSpeakerMute (uint8_t ch, bool on);
S
S/// \brief Callback function called when speaker volume setting changed
S/// \param[in]     ch                   channel index :
S///                                       - value 0 : master channel
S///                                       - value 1 : left speaker (in stereo mode)
S///                                       - value 2 : right speaker (in stereo mode)
S/// \param[in]     vol                  current volume setting.
S/// \return                             none.
Svoid USBD_ADCn_SetSpeakerVolume (uint8_t ch, uint16_t vol);
S
S/// \brief Callback function called when recording started
S/// \return                             none.
Svoid USBD_ADCn_RecordStart (void);
S
S/// \brief Callback function called when recording stopped
S/// \return                             none.
Svoid USBD_ADCn_RecordStop (void);
S
S/// \brief Callback function called when microphone mute setting changed
S/// \param[in]     ch                   channel index :
S///                                       - value 0 : master channel
S///                                       - value 1 : left microphone (in stereo mode)
S///                                       - value 2 : right microphone (in stereo mode)
S/// \param[in]     on                   current mute setting
S///                                       - value false : mute off
S///                                       - value true :  mute on
S/// \return                             none.
Svoid USBD_ADCn_SetMicrophoneMute (uint8_t ch, bool on);
S
S/// \brief Callback function called when microphone volume setting changed
S/// \param[in]     ch                   channel index :
S///                                       - value 0 : master channel
S///                                       - value 1 : left microphone (in stereo mode)
S///                                       - value 2 : right microphone (in stereo mode)
S/// \param[in]     vol                  current volume setting.
S/// \return                             none.
Svoid USBD_ADCn_SetMicrophoneVolume (uint8_t ch, uint16_t vol);
S
S/// \brief Callback function called when data in USB buffer for speaker samples reaches half-full from empty
S/// \return                             none.
Svoid USBD_ADCn_ReceivedSamples (void);
S
N#endif // __DOXYGEN
N
N// Rename deprecated functions
N#define USBD_ADC_SpeakerSetVolumeRange      USBD_ADC_SetSpeakerVolumeRange
N#define USBD_ADC_MicrophoneSetVolumeRange   USBD_ADC_SetMicrophoneVolumeRange
N
N/// \brief Set range for speaker volume control
N/// \param[in]     instance             instance of ADC class.
N/// \param[in]     ch                   channel index :
N///                                       - value 0 : master channel
N///                                       - value 1 : left speaker (in stereo mode)
N///                                       - value 2 : right speaker (in stereo mode)
N/// \param[in]     min                  minimum volume value.
N/// \param[in]     max                  maximum volume value.
N/// \param[in]     res                  volume resolution.
N/// \param[in]     cur                  current volume value.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_ADC_SetSpeakerVolumeRange (uint8_t instance, uint8_t ch, uint16_t min, uint16_t max, uint16_t res, uint16_t cur);
N
N/// \brief Set range for microphone volume (level) control
N/// \param[in]     instance             instance of ADC class.
N/// \param[in]     ch                   channel index :
N///                                       - value 0 : master channel
N///                                       - value 1 : left microphone (in stereo mode)
N///                                       - value 2 : right microphone (in stereo mode)
N/// \param[in]     min                  minimum volume value.
N/// \param[in]     max                  maximum volume value.
N/// \param[in]     res                  volume resolution.
N/// \param[in]     cur                  current volume value.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_ADC_SetMicrophoneVolumeRange (uint8_t instance, uint8_t ch, uint16_t min, uint16_t max, uint16_t res, uint16_t cur);
N
N/// \brief Number of audio samples received from USB Host and available to be read
N/// \param[in]     instance             instance of ADC class.
N/// \return                             number of samples available to be read.
Nextern uint32_t USBD_ADC_ReceivedSamplesAvailable (uint8_t instance);
N
N/// \brief Number of audio samples written and pending to be sent to USB Host
N/// \param[in]     instance             instance of ADC class.
N/// \return                             number of samples ready to be sent.
Nextern uint32_t USBD_ADC_WrittenSamplesPending (uint8_t instance);
N
N/// \brief Read audio samples received from USB Host
N/// \param[in]     instance             instance of ADC class.
N/// \param[out]    buf                  buffer that receives samples.
N/// \param[in]     num                  maximum number of samples to read.
N/// \return                             number of samples read or execution status :
N///                                       - value >= 0 : number of samples read
N///                                       - value < 0 :  error occurred, -value is execution status as defined with \ref usbStatus
Nextern int32_t USBD_ADC_ReadSamples (uint8_t instance, void *buf, int32_t num);
N
N/// \brief Write audio samples to be transferred to USB Host
N/// \param[in]     instance             instance of ADC class.
N/// \param[in]     buf                  buffer containing samples to write.
N/// \param[in]     num                  number of samples to write.
N/// \return                             number of samples written or execution status :
N///                                       - value >= 0 : number of samples written for sending
N///                                       - value < 0 :  error occurred, -value is execution status as defined with \ref usbStatus
Nextern int32_t USBD_ADC_WriteSamples (uint8_t instance, const void *buf, int32_t num);
N
N
N//  ==== USB Device Communication Device (Abstract Control Model) Functions ====
N
N#ifdef __DOXYGEN__
S
S// following functions are available for each instance of a CDC class.
S// generic prefix USBD_CDCn is USBD_CDC0 for CDC class instance 0.
S
S/// \brief Callback function called during \ref USBD_Initialize to initialize the USB CDC class instance (ACM)
S/// \return                             none.
Svoid USBD_CDCn_ACM_Initialize (void);
S
S/// \brief Callback function called during \ref USBD_Uninitialize to de-initialize the USB CDC class instance (ACM)
S/// \return                             none.
Svoid USBD_CDCn_ACM_Uninitialize (void);
S
S/// \brief Callback function called upon USB Bus Reset signaling
S/// \return                             none.
Svoid USBD_CDCn_ACM_Reset (void);
S
S/// \brief Callback function called upon reception of request send encapsulated command sent by the USB Host.
S/// \param[in]     buf                  buffer that contains send encapsulated command request.
S/// \param[in]     len                  length of send encapsulated command request.
S/// \return                             received send encapsulated command processed status :
S///                                       - value true :  processed
S///                                       - value false : not processed
Sbool USBD_CDCn_ACM_SendEncapsulatedCommand (const uint8_t *buf, uint16_t len);
S
S/// \brief Callback function called upon reception of request to get encapsulated response sent by the USB Host
S/// \param[in]     max_len              maximum number of data bytes that USB Host expects to receive.
S/// \param[out]    buf                  pointer to buffer containing get encapsulated response to be returned to USB Host.
S/// \param[out]    len                  pointer to number of data bytes to be returned to USB Host.
S/// \return                             received get encapsulated response processed status :
S///                                       - value true :  processed and response prepared
S///                                       - value false : not processed
Sbool USBD_CDCn_ACM_GetEncapsulatedResponse (uint16_t max_len, uint8_t **buf, uint16_t *len);
S
S/// \brief Callback function called upon USB Host request to change communication settings
S/// \param[in]     line_coding          pointer to CDC_LINE_CODING structure.
S/// \return                             set line coding request processed status :
S///                                       - value true :  processed
S///                                       - value false : not processed
Sbool USBD_CDCn_ACM_SetLineCoding (const CDC_LINE_CODING *line_coding);
S
S/// \brief Callback function called upon USB Host request to retrieve communication settings
S/// \param[out]    line_coding          pointer to CDC_LINE_CODING structure.
S/// \return                             get line coding request processed status :
S///                                       - value true :  processed
S///                                       - value false : not processed
Sbool USBD_CDCn_ACM_GetLineCoding (CDC_LINE_CODING *line_coding);
S
S/// \brief Callback function called upon USB Host request to set control line states
S/// \param[in]     state                control line settings bitmap :
S///                                       - bit 0 : DTR state
S///                                       - bit 1 : RTS state
S/// \return                             set control line state request processed status :
S///                                       - value true :  processed
S///                                       - value false : not processed
Sbool USBD_CDCn_ACM_SetControlLineState (uint16_t state);
S
S/// \brief Callback function called when new data was received
S/// \param[in]     len                  number of bytes available to read.
S/// \return                             none.
Svoid USBD_CDCn_ACM_DataReceived (uint32_t len);
S
S/// \brief Callback function called when all data was sent
S/// \return                             none.
Svoid USBD_CDCn_ACM_DataSent (void);
S
S/// \brief Callback function called during USBD_Initialize to initialize the USB CDC class instance (NCM)
S/// \return                             none.
Svoid USBD_CDCn_NCM_Initialize (void);
S
S/// \brief Callback function called during USBD_Uninitialize to de-initialize the USB CDC class instance (NCM)
S/// \return                             none.
Svoid USBD_CDCn_NCM_Uninitialize (void);
S
S/// \brief Callback function called upon USB Bus Reset signaling
S/// \return                             none.
Svoid USBD_CDCn_NCM_Reset (void);
S
S/// \brief Callback function called when USB Host changes data interface from alternate 0 to alternate 1 (activates data interface)
S/// \return                             none.
Svoid USBD_CDCn_NCM_Start (void);
S
S/// \brief Callback function called when USB Host changes data interface from alternate 1 to alternate 0 (de-activates data interface)
S/// \return                             none.
Svoid USBD_CDCn_NCM_Stop (void);
S
S/// \brief Callback function called upon USB Host request to set the Ethernet device multicast filters
S/// \param[in]     addr_list            Pointer to list of 48-bit Multicast addresses.
S/// \param[in]     num_of_filters       Number of filters.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_SetEthernetMulticastFilters (const uint8_t *addr_list, uint16_t num_of_filters);
S
S/// \brief Callback function called upon USB Host request to set up the specified Ethernet power management pattern filter
S/// \param[in]     filter_number        Filter number.
S/// \param[in]     pattern_filter       Power management pattern filter structure.
S/// \param[in]     pattern_filter_size  Size of pattern filter structure.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
S
S/// \brief Callback function called upon USB Host request to retrieve the status of the specified Ethernet power management pattern filter
S/// \param[in]     filter_number        Filter number.
S/// \param[out]    pattern_active       Pointer to pattern active boolean.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
S
S/// \brief Callback function called upon USB Host request to configure device Ethernet packet filter settings
S/// \param[in]     packet_filter_bitmap Packet Filter Bitmap.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_SetEthernetPacketFilter (uint16_t packet_filter_bitmap);
S
S/// \brief Callback function called upon USB Host request to retrieve a statistic based on the feature selector
S/// \param[in]     feature_selector     Feature Selector.
S/// \param[out]    data                 Pointer to Statistics Value.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_GetEthernetStatistic (uint16_t feature_selector, uint32_t *data);
S
S/// \brief Callback function called upon USB Host request to retrieve the parameters that describe NTBs for each direction
S/// \param[out]    ntb_params           Pointer to NTB Parameter Structure.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_GetNtbParameters (CDC_NCM_NTB_PARAM *ntb_params);
S
S/// \brief Callback function called upon USB Host request to return the USB Device's current EUI-48 station address
S/// \param[out]    net_addr             Pointer to EUI-48 current address, in network byte order.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_GetNetAddress (uint8_t *net_addr);
S
S/// \brief Callback function called upon USB Host request to set the USB Device's current EUI-48 station address
S/// \param[in]     net_addr             Pointer to EUI-48 address, in network byte order.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_SetNetAddress (const uint8_t *net_addr);
S
S/// \brief Callback function called upon USB Host request to return the NTB data format currently being used
S/// \param[out]    ntb_format           Pointer to NTB format code.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_GetNtbFormat (uint16_t *ntb_format);
S
S/// \brief Callback function called upon USB Host request to select the format of NTB to be used for NTBs transmitted to the USB Host
S/// \param[in]     ntb_format           NTB format selection :
S///                                       - value 0 : NTB-16
S///                                       - value 1 : NTB-32
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_SetNtbFormat (uint16_t ntb_format);
S
S/// \brief Callback function called upon USB Host request to return NTB input size currently being used
S/// \param[out]    ntb_input_size       Pointer to NTB input size.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_GetNtbInputSize (uint32_t *ntb_input_size);
S
S/// \brief Callback function called upon USB Host request to select the maximum size of NTB that is permitted to be sent to the USB Host
S/// \param[in]     ntb_input_size       Maximum NTB size.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_SetNtbInputSize (uint32_t ntb_input_size);
S
S/// \brief Callback function called upon USB Host request to return the currently effective maximum datagram size
S/// \param[out]    max_datagram_size    Pointer to current maximum datagram size.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_GetMaxDatagramSize (uint16_t *max_datagram_size);
S
S/// \brief Callback function called upon USB Host request to select the maximum datagram size that can be sent in an NTB
S/// \param[in]     max_datagram_size    Maximum datagram size.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_SetMaxDatagramSize (uint16_t max_datagram_size);
S
S/// \brief Callback function called upon USB Host request to return the currently selected CRC mode
S/// \param[out]    crc_mode             Pointer to current CRC mode.
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_GetCrcMode (uint16_t *crc_mode);
S
S/// \brief Callback function called upon USB Host request to control CRC mode
S/// \param[in]     crc_mode             CRC mode :
S///                                       - value 0 : CRCs shall not be appended
S///                                       - value 1 : CRCs shall be appended
S/// \return                             request handled status :
S///                                       - value true :  request was handled
S///                                       - value false : request was not handled
Sbool USBD_CDCn_NCM_SetCrcMode (uint16_t crc_mode);
S
S/// \brief Callback function called when NTB was successfully sent
S/// \return                             none.
Svoid USBD_CDCn_NCM_NTB_IN_Sent (void);
S
S/// \brief Callback function called when NTB was successfully received
S/// \return                             none.
Svoid USBD_CDCn_NCM_NTB_OUT_Received (void);
S
N#endif // __DOXYGEN
N
N// Rename deprecated functions
N#define USBD_CDC_ACM_Notify             USBD_CDC_ACM_Notify_SerialState
N
N/// \brief Read one character received by Communication Device from USB Host
N/// \param[in]     instance             instance of CDC class.
N/// \return                             value of read character or no character received :
N///                                       - value >= 0 : value of first received unread character
N///                                       - value -1 :   indicates no character was received
Nextern int USBD_CDC_ACM_GetChar (uint8_t instance);
N
N/// \brief Write a single character from Communication Device to USB Host
N/// \param[in]     instance             instance of CDC class.
N/// \param[in]     ch                   character to write.
N/// \return                             value of accepted character or no character accepted :
N///                                       - value ch : if character accepted for writing
N///                                       - value -1 : indicates character not accepted
Nextern int USBD_CDC_ACM_PutChar (uint8_t instance, int ch);
N
N/// \brief Read multiple data bytes received by Communication Device from USB Host
N/// \param[in]     instance             instance of CDC class.
N/// \param[out]    buf                  buffer that receives data.
N/// \param[in]     len                  maximum number of bytes to read.
N/// \return                             number of bytes read or execution status :
N///                                       - value >= 0 : number of bytes read
N///                                       - value < 0 :  error occurred, -value is execution status as defined with \ref usbStatus
Nextern int32_t USBD_CDC_ACM_ReadData (uint8_t instance, uint8_t *buf, int32_t len);
N
N/// \brief Write data from Communication Device to USB Host
N/// \param[in]     instance             instance of CDC class.
N/// \param[in]     buf                  buffer containing data bytes to write.
N/// \param[in]     len                  number of bytes to write.
N/// \return                             number of bytes accepted for writing or execution status :
N///                                       - value >= 0 : number of bytes accepted for writing
N///                                       - value < 0 :  error occurred, -value is execution status as defined with \ref usbStatus
Nextern int32_t USBD_CDC_ACM_WriteData (uint8_t instance, const uint8_t *buf, int32_t len);
N
N/// \brief Retrieve number of data bytes received by Communication Device from
N///        USB Host that are available to read
N/// \param[in]     instance             instance of CDC class.
N/// \return                             number of bytes available to read.
Nextern int32_t USBD_CDC_ACM_DataAvailable (uint8_t instance);
N
N/// \brief Send notification of Communication Device status and line states to USB Host
N/// \param[in]     instance             instance of CDC class.
N/// \param[in]     state                error status and line states :
N///                                       - bit 6 : bOverRun
N///                                       - bit 5 : bParity
N///                                       - bit 4 : bFraming
N///                                       - bit 3 : bRingSignal
N///                                       - bit 2 : bBreak
N///                                       - bit 1 : bTxCarrier (DSR line state)
N///                                       - bit 0 : bRxCarrier (DCD line state)
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_CDC_ACM_Notify_SerialState (uint8_t instance, uint16_t state);
N
N/// \brief Send notification to USB Host signaling that response is available
N/// \param[in]     instance             instance of CDC class.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_CDC_ACM_Notify_ResponseAvailable (uint8_t instance);
N
N/// \brief Clear the active NTB (prepared for sending)
N/// \param[in]     instance             Instance of CDC class.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_IN_Initialize (uint8_t instance);
N
N/// \brief Create a new NDP in the NTB (datagrams can be added to it)
N/// \param[in]     instance             Instance of CDC class.
N/// \param[in]     num_datagrams        Maximum number of datagrams that NDP will contain.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_IN_CreateNDP (uint8_t instance, uint8_t num_datagrams);
N
N/// \brief Add a datagram into the active NDP of the NTB to be sent
N/// \param[in]     instance             Instance of CDC class.
N/// \param[in]     buf                  Buffer containing data bytes to write.
N/// \param[in]     len                  Number of bytes to write.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_IN_WriteDatagram (uint8_t instance, const uint8_t *buf, uint32_t len);
N
N/// \brief Send the active NTB
N/// \param[in]     instance             Instance of CDC class.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_IN_Send (uint8_t instance);
N
N/// \brief Check if NTB was sent and new NTB can be prepared
N/// \param[in]     instance             Instance of CDC class.
N/// \return                             NTB sent status or error code :
N///                                       - value 1 :   NTB was sent
N///                                       - value 0 :   NTB sending is in progress
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_IN_IsSent (uint8_t instance);
N
N/// \brief Check if NTB was received and is available for processing
N/// \param[in]     instance             Instance of CDC class.
N/// \return                             NTB available or error code :
N///                                       - value 1 :   received NTB is available
N///                                       - value 0 :   no received NTB is available
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_OUT_IsReceived (uint8_t instance);
N
N/// \brief Flush the received NTB and release memory for reception of a new NTB
N/// \param[in]     instance             Instance of CDC class.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_OUT_Release (uint8_t instance);
N
N/// \brief Process the next NDP in the received NTB
N/// \param[in]     instance             Instance of CDC class.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_OUT_ProcessNDP (uint8_t instance);
N
N/// \brief Get size of a datagram from the active NDP of the received NTB
N/// \param[in]     instance             Instance of CDC class.
N/// \return                             Number of bytes available in the datagram.
Nextern uint32_t USBD_CDC_NCM_NTB_OUT_GetDatagramSize (uint8_t instance);
N
N/// \brief Read a datagram from the active NDP of the received NTB
N/// \param[in]     instance             Instance of CDC class.
N/// \param[out]    buf                  Buffer that receives read data.
N/// \param[in]     max_len              Maximum number of bytes to read.
N/// \return                             number of bytes read from the datagram or error code :
N///                                       - value >= 0 : number of bytes read from the datagram
N///                                       - value <  0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_OUT_ReadDatagram (uint8_t instance, uint8_t *buf, uint32_t max_len);
N
N/// \brief Send already prepared NTB (for this option value of define in configuration USBD_CDCn_NCM_RAW_ENABLE has to be 1)
N/// \param[in]     instance             Instance of CDC class.
N/// \param[in]     buf                  Buffer containing NTB.
N/// \param[in]     len                  Size of NTB.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_IN_RawSend (uint8_t instance, const uint8_t *buf, uint32_t len);
N
N/// \brief Get size of the received NTB
N/// \param[in]     instance             Instance of CDC class.
N/// \return                             Number of bytes available in the NTB.
Nextern uint32_t USBD_CDC_NCM_NTB_OUT_RawGetSize (uint8_t instance);
N
N/// \brief Receive an NDP (for this option value of define in configuration USBD_CDCn_NCM_RAW_ENABLE has to be 1)
N/// \param[in]     instance             Instance of CDC class.
N/// \param[out]    buf                  Buffer that receives NTB.
N/// \param[in]     max_len              Maximum number of bytes that buffer can accept.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_NTB_OUT_RawReceive (uint8_t instance, uint8_t *buf, uint32_t max_len);
N
N/// \brief Report whether or not the physical layer (modem, Ethernet PHY, etc.) link is up to the USB Host
N/// \param[in]     instance             Instance of CDC class.
N/// \param[in]     status               Connection status :
N///                                       - value 0 : Disconnected
N///                                       - value 1 : Connected
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_Notify_NetworkConnection (uint8_t instance, uint16_t status);
N
N/// \brief Report a change in upstream or downstream speed of the networking connection to the USB Host
N/// \param[in]     instance             Instance of CDC class.
N/// \param[in]     us_bitrate           Upstream bitrate.
N/// \param[in]     ds_bitrate           Downstream bitrate.
N/// \return                             function execution status :
N///                                       - value 0 :   success
N///                                       - value < 0 : error code
Nextern int32_t USBD_CDC_NCM_Notify_ConnectionSpeedChange (uint8_t instance, uint32_t us_bitrate, uint32_t ds_bitrate);
N
N//  ==== USB Device Human Interface Device Functions ====
N
N#ifdef __DOXYGEN__
S
S// following functions are available for each instance of a HID class.
S// generic prefix USBD_HIDn is USBD_HID0 for HID class instance 0.
S
S/// \brief Callback function called during \ref USBD_Initialize to initialize the USB HID class instance
S/// \return                             none.
Svoid USBD_HIDn_Initialize (void);
S
S/// \brief Callback function called during \ref USBD_Uninitialize to de-initialize the USB HID class instance
S/// \return                             none.
Svoid USBD_HIDn_Uninitialize (void);
S
S/// \brief Callback function called to prepare HID Report data to send
S/// \param[in]     rtype                report type :
S///                                       - HID_REPORT_INPUT   = input report requested
S///                                       - HID_REPORT_FEATURE = feature report requested
S/// \param[in]     req                  request type :
S///                                       - USBD_HID_REQ_EP_CTRL       = control endpoint request
S///                                       - USBD_HID_REQ_PERIOD_UPDATE = idle period expiration request
S///                                       - USBD_HID_REQ_EP_INT        = previously sent report on interrupt endpoint request
S/// \param[in]     rid                  report ID (0 if only one report exists).
S/// \param[out]    buf                  buffer containing report data to send.
S/// \return                             number of report data bytes prepared to send or invalid report requested :
S///                                       - value >= 0 : number of report data bytes prepared to send
S///                                       - value -1 :   invalid report requested
Sint32_t USBD_HIDn_GetReport (uint8_t rtype, uint8_t req, uint8_t rid, uint8_t *buf);
S
S/// \brief Callback function called to process received HID Report data
S/// \param[in]     rtype                report type :
S///                                       - HID_REPORT_OUTPUT    = output report received
S///                                       - HID_REPORT_FEATURE   = feature report received
S/// \param[in]     req                  request type :
S///                                       - USBD_HID_REQ_EP_CTRL = report received on control endpoint
S///                                       - USBD_HID_REQ_EP_INT  = report received on interrupt endpoint
S/// \param[in]     rid                  report ID (0 if only one report exists).
S/// \param[in]     buf                  buffer that receives report data.
S/// \param[in]     len                  length of received report data.
S/// \return                             received report data processed status :
S///                                       - value true :  processed
S///                                       - value false : not processed
Sbool USBD_HIDn_SetReport (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
S
N#endif // __DOXYGEN
N
N/// \brief Asynchronously prepare HID Report data to send
N/// \param[in]     instance             instance of HID class.
N/// \param[in]     rid                  report ID.
N/// \param[in]     buf                  buffer containing report data to send.
N/// \param[in]     len                  number of report data bytes to send.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_HID_GetReportTrigger (uint8_t instance, uint8_t rid, const uint8_t *buf, uint32_t len);
N
N
N#ifdef __DOXYGEN__
S
S//  ==== USB Device Mass Storage Device Functions ====
S
S// following functions are available for each instance of a MSC class.
S// generic prefix USBD_MSCn is USBD_MSC0 for MSC class instance 0.
S
S/// \brief Callback function called during \ref USBD_Initialize to initialize all Logical Units of the USB MSC class instance
S/// \return                             none.
Svoid USBD_MSCn_Initialize (void);
S
S/// \brief Callback function called during \ref USBD_Uninitialize to de-initialize all Logical Units of the USB MSC class instance
S/// \return                             none.
Svoid USBD_MSCn_Uninitialize (void);
S
S/// \brief Callback function called to get cache information
S/// \param[out]    buffer               cache buffer address.
S/// \param[out]    size                 cache buffer size.
S///                                     operation execution status :
S///                                       - value true :  operation succeeded
S///                                       - value false : operation failed
Sbool USBD_MSCn_GetCacheInfo (uint32_t *buffer, uint32_t *size);
S
S/// \brief Callback function called to get media capacity
S/// \param[out]    block_count          total number of blocks on media.
S/// \param[out]    block_size           media block size.
S///                                     operation execution status :
S///                                       - value true :  operation succeeded
S///                                       - value false : operation failed
Sbool USBD_MSCn_GetMediaCapacity (uint32_t *block_count, uint32_t *block_size);
S
S/// \brief Callback function called to read data from media
S/// \param[in]     lba                  logical address of first block to read.
S/// \param[in]     cnt                  number of contiguous blocks to read from media.
S/// \param[out]    buf                  data buffer for data read from media.
S///                                     operation execution status :
S///                                       - value true :  operation succeeded
S///                                       - value false : operation failed
Sbool USBD_MSCn_Read (uint32_t lba, uint32_t cnt, uint8_t *buf);
S
S/// \brief Callback function called to write data to media
S/// \param[in]     lba                  logical address of first block to write.
S/// \param[in]     cnt                  number of contiguous blocks to write to media.
S/// \param[in]     buf                  data buffer containing data to write to media.
S///                                     operation execution status :
S///                                       - value true :  operation succeeded
S///                                       - value false : operation failed
Sbool USBD_MSCn_Write (uint32_t lba, uint32_t cnt, const uint8_t *buf);
S
S/// \brief Callback function called to check media presence and write protect status
S/// \return                             media presence and write protected status :
S///                                     - bit 1:      write protect bit
S///                                       - value 1 :   media is write protected
S///                                       - value 0 :   media is not write protected
S///                                     - bit 0:      media presence bit
S///                                       - value 1 :   media is present
S///                                       - value 0 :   media is not present
Suint32_t USBD_MSCn_CheckMedia (void);
S
S/// \brief Callback function called to get maximum number of logical units
S/// \return                             number of logical units that device contains
S///                                       - value > 0 and <= 4 : maximum number of logical units
S///                                       - value 0 :            use setting from configuration file
Suint8_t USBD_MSCn_GetMaxLUN (void);
S
S/// \brief Callback function called to get media capacity  of a logical unit
S/// \param[in]     lun                  logical unit number.
S/// \param[out]    block_count          total number of blocks on media.
S/// \param[out]    block_size           media block size.
S///                                     operation execution status :
S///                                       - value true :  operation succeeded
S///                                       - value false : operation failed
Sbool USBD_MSCn_LUN_GetMediaCapacity (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
S
S/// \brief Callback function called to read data from media of a logical unit
S/// \param[in]     lun                  logical unit number.
S/// \param[in]     lba                  logical address of first block to read.
S/// \param[in]     cnt                  number of contiguous blocks to read from media.
S/// \param[out]    buf                  data buffer for data read from media.
S///                                     operation execution status :
S///                                       - value true :  operation succeeded
S///                                       - value false : operation failed
Sbool USBD_MSCn_LUN_Read (uint8_t lun, uint32_t lba, uint32_t cnt, uint8_t *buf);
S
S/// \brief Callback function called to write data to media of a logical unit
S/// \param[in]     lun                  logical unit number.
S/// \param[in]     lba                  logical address of first block to write.
S/// \param[in]     cnt                  number of contiguous blocks to write to media.
S/// \param[in]     buf                  data buffer containing data to write to media.
S///                                     operation execution status :
S///                                       - value true :  operation succeeded
S///                                       - value false : operation failed
Sbool USBD_MSCn_LUN_Write (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
S
S/// \brief Callback function called to check media presence and write protect status of a logical unit
S/// \param[in]     lun                  logical unit number.
S/// \return                             media presence and write protected status :
S///                                     - bit 1:      write protect bit
S///                                       - value 1 :   media is write protected
S///                                       - value 0 :   media is not write protected
S///                                     - bit 0:      media presence bit
S///                                       - value 1 :   media is present
S///                                       - value 0 :   media is not present
Suint32_t USBD_MSCn_LUN_CheckMedia (uint8_t lun);
S
N#endif // __DOXYGEN
N
N
N//  ==== USB Device Custom Class Functions ====
N
N#ifdef __DOXYGEN__
S
S// following functions are available for each instance of a Custom class.
S// generic prefix USBD_CustomClassn is USBD_CustomClass0 for Custom class instance 0.
S
S/// \brief Callback function called during \ref USBD_Initialize to initialize the USB Custom class instance
S/// \return                             none.
Svoid USBD_CustomClassn_Initialize (void);
S
S/// \brief Callback function called during \ref USBD_Uninitialize to de-initialize the USB Custom class instance
S/// \return                             none.
Svoid USBD_CustomClassn_Uninitialize (void);
S
S/// \brief Callback function called upon USB Bus Reset signaling
S/// \return                             none.
Svoid USBD_CustomClassn_Reset (void);
S
S/// \brief Callback function called when Endpoint Start was requested (by activating interface or configuration)
S/// \param[in]     ep_addr              endpoint address :
S///                                       - ep_addr.0..3 : address
S///                                       - ep_addr.7 :    direction
S/// \return                             none.
Svoid USBD_CustomClassn_EndpointStart (uint8_t ep_addr);
S
S/// \brief Callback function called when Endpoint Stop was requested (by de-activating interface or activating configuration 0)
S/// \param[in]     ep_addr              endpoint address :
S///                                       - ep_addr.0..3 : address
S///                                       - ep_addr.7 :    direction
S/// \return                             none.
Svoid USBD_CustomClassn_EndpointStop (uint8_t ep_addr);
S
S/// \brief Callback function called when a SETUP PACKET was received on Control Endpoint 0
S/// \param[in]     setup_packet         pointer to received setup packet.
S/// \param[in,out] buf                  pointer to data buffer used for data stage requested by setup packet.
S/// \param[in,out] len                  pointer to number of data bytes in data stage requested by setup packet.
S/// \return        usbdRequestStatus    enumerator value indicating the function execution status :
S///                                       - value usbdRequestNotProcessed : request was not processed; processing will be done by USB library
S///                                       - value usbdRequestOK :           request was processed successfully (send Zero-Length Packet if no data stage)
S///                                       - value usbdRequestStall :        request was processed but is not supported (STALL EP)
SusbdRequestStatus USBD_CustomClassn_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
S
S/// \brief Callback function called when a SETUP PACKET was processed by USB library
S/// \param[in]     setup_packet         pointer to processed setup packet.
S/// \return                             none.
Svoid USBD_CustomClassn_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
S
S/// \brief Callback function called when OUT DATA was received on Control Endpoint 0
S/// \param[in]     len                  number of received data bytes.
S/// \return        usbdRequestStatus    enumerator value indicating the function execution status :
S///                                       - value usbdRequestNotProcessed : request was not processed; processing will be done by USB library
S///                                       - value usbdRequestOK :           request was processed successfully (send Zero-Length Packet)
S///                                       - value usbdRequestStall :        request was processed but is not supported (stall endpoint 0)
S///                                       - value usbdRequestNAK :          request was processed but the device is busy (return NAK)
SusbdRequestStatus USBD_CustomClassn_Endpoint0_OutDataReceived (uint32_t len);
S
S/// \brief Callback function called when IN DATA was sent on Control Endpoint 0
S/// \param[in]     len                  number of sent data bytes.
S/// \return        usbdRequestStatus    enumerator value indicating the function execution status :
S///                                       - value usbdRequestNotProcessed : request was not processed; processing will be done by USB library
S///                                       - value usbdRequestOK :           request was processed successfully (return ACK)
S///                                       - value usbdRequestStall :        request was processed but is not supported (stall endpoint 0)
S///                                       - value usbdRequestNAK :          request was processed but the device is busy (return NAK)
SusbdRequestStatus USBD_CustomClassn_Endpoint0_InDataSent (uint32_t len);
S
S/// \brief Callback function called when DATA was sent or received on Endpoint n
S/// \param[in]     event                event on Endpoint :
S///                                       - ARM_USBD_EVENT_OUT = data OUT received
S///                                       - ARM_USBD_EVENT_IN  = data IN  sent
S/// \return                             none.
Svoid USBD_CustomClassn_Endpoint1_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint2_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint3_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint4_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint5_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint6_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint7_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint8_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint9_Event  (uint32_t event);
Svoid USBD_CustomClassn_Endpoint10_Event (uint32_t event);
Svoid USBD_CustomClassn_Endpoint11_Event (uint32_t event);
Svoid USBD_CustomClassn_Endpoint12_Event (uint32_t event);
Svoid USBD_CustomClassn_Endpoint13_Event (uint32_t event);
Svoid USBD_CustomClassn_Endpoint14_Event (uint32_t event);
Svoid USBD_CustomClassn_Endpoint15_Event (uint32_t event);
S
N#endif // __DOXYGEN
N
N/// \brief Start reception on Endpoint
N/// \param[in]     device               index of USB Device.
N/// \param[in]     ep_addr              endpoint address :
N///                                       - ep_addr.0..3 : address
N///                                       - ep_addr.7 :    direction
N/// \param[out]    buf                  buffer that receives data.
N/// \param[in]     len                  maximum number of bytes to receive.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_EndpointRead (uint8_t device, uint8_t ep_addr, uint8_t *buf, uint32_t len);
N
N/// \brief Get result of read operation on Endpoint
N/// \param[in]     device               index of USB Device.
N/// \param[in]     ep_addr              endpoint address :
N///                                       - ep_addr.0..3 : address
N///                                       - ep_addr.7 :    direction
N/// \return                             number of bytes received.
Nextern uint32_t USBD_EndpointReadGetResult (uint8_t device, uint8_t ep_addr);
N
N/// \brief Start write on Endpoint
N/// \param[in]     device               index of USB Device.
N/// \param[in]     ep_addr              endpoint address :
N///                                       - ep_addr.0..3 : address
N///                                       - ep_addr.7 :    direction
N/// \param[in]     buf                  buffer containing data bytes to write.
N/// \param[in]     len                  number of bytes to write.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_EndpointWrite (uint8_t device, uint8_t ep_addr, const uint8_t *buf, uint32_t len);
N
N/// \brief Get result of write operation on Endpoint
N/// \param[in]     device               index of USB Device.
N/// \param[in]     ep_addr              endpoint address :
N///                                       - ep_addr.0..3 : address
N///                                       - ep_addr.7 :    direction
N/// \return                             number of bytes written.
Nextern uint32_t USBD_EndpointWriteGetResult (uint8_t device, uint8_t ep_addr);
N
N/// \brief Set/Clear stall on Endpoint
N/// \param[in]     device               index of USB Device.
N/// \param[in]     ep_addr              endpoint address :
N///                                       - ep_addr.0..3 : address
N///                                       - ep_addr.7 :    direction
N/// \param[in]     stall                operation :
N///                                       - value false : clear stall
N///                                       - value true :  set stall
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_EndpointStall (uint8_t device, uint8_t ep_addr, bool stall);
Xextern usbStatus USBD_EndpointStall (uint8_t device, uint8_t ep_addr, _Bool stall);
N
N/// \brief Abort read/write operation on Endpoint
N/// \param[in]     device               index of USB Device.
N/// \param[in]     ep_addr              endpoint address :
N///                                       - ep_addr.0..3 : address
N///                                       - ep_addr.7 :    direction
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBD_EndpointAbort (uint8_t device, uint8_t ep_addr);
N
N
N//  ==== USB Host Functions ====
N
N// Rename deprecated functions
N#define USBH_GetDeviceStatus            USBH_Device_GetStatus
N
N/// \brief Get version of USB Host stack
N/// \return                             version (major.minor.revision : mmnnnrrrr decimal)
Nextern uint32_t USBH_GetVersion (void);
N
N/// \brief Initialize USB Host stack and controller
N/// \param[in]     ctrl                 index of USB Host controller.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_Initialize (uint8_t ctrl);
N
N/// \brief De-initialize USB Host stack and controller
N/// \param[in]     ctrl                 index of USB Host controller.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_Uninitialize (uint8_t ctrl);
N
N/// \brief Suspend a root HUB port on specified controller
N/// \param[in]     ctrl                 index of USB Host controller.
N/// \param[in]     port                 root HUB port.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_Port_Suspend (uint8_t ctrl, uint8_t port);
N
N/// \brief Resume a root HUB port on specified controller
N/// \param[in]     ctrl                 index of USB Host controller.
N/// \param[in]     port                 root HUB port.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_Port_Resume (uint8_t ctrl, uint8_t port);
N
N/// \brief Get index of USB Host controller to which USB Device is connected
N/// \param[in]     device               index of USB Device.
N/// \return                             index of USB Host controller or non-existing USB Host controller :
N///                                       - value != 255 : index of USB Host controller
N///                                       - value 255 :    non-existing USB Host controller
Nextern uint8_t USBH_Device_GetController (uint8_t device);
N
N/// \brief Get index of USB Host Root HUB port to which USB Device is connected
N/// \param[in]     device               index of USB Device.
N/// \return                             index of USB Host Root HUB port or non-existing USB Host Root HUB port :
N///                                       - value <= 15 : index of USB Host Root HUB port
N///                                       - value 255 :   non-existing USB Host Root HUB port
Nextern uint8_t USBH_Device_GetPort (uint8_t device);
N
N/// \brief Get status of USB Device
N/// \param[in]     device               index of USB Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_Device_GetStatus (uint8_t device);
N
N/// \brief Get communication speed of USB Device
N/// \param[in]     device               index of USB Device.
N/// \return                             communication speed :
N///                                       - USB_SPEED_LOW  = low speed
N///                                       - USB_SPEED_FULL = full speed
N///                                       - USB_SPEED_HIGH = high speed
Nextern int32_t USBH_Device_GetSpeed (uint8_t device);
N
N/// \brief Get communication address of USB Device
N/// \param[in]     device               index of USB Device.
N/// \return                             enumerated address or invalid address :
N///                                       - value <= 127 : enumerated address
N///                                       - value 255 :    invalid address
Nextern uint8_t USBH_Device_GetAddress (uint8_t device);
N
N/// \brief Get Vendor ID (VID) of USB Device
N/// \param[in]     device               index of USB Device.
N/// \return                             Vendor ID.
Nextern uint16_t USBH_Device_GetVID (uint8_t device);
N
N/// \brief Get Product ID (PID) of USB Device
N/// \param[in]     device               index of USB Device.
N/// \return                             Product ID.
Nextern uint16_t USBH_Device_GetPID (uint8_t device);
N
N/// \brief Get String Descriptor of USB Device
N/// \param[in]     device               index of USB Device.
N/// \param[in]     index                index of string descriptor.
N/// \param[in]     language_id          language ID.
N/// \param[out]    descriptor_data      pointer to where descriptor data will be read.
N/// \param[in]     descriptor_length    maximum descriptor length.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_Device_GetStringDescriptor (uint8_t device, uint8_t index, uint16_t language_id, uint8_t *descriptor_data, uint16_t descriptor_length);
N
N/// \brief Callback function called when some event has happened on corresponding controller and port
N/// \param[in]     ctrl                 index of USB Host controller.
N/// \param[in]     port                 index of Root HUB port.
N/// \param[in]     device               index of USB Device :
N///                                       - value <= 127: index of of USB Device for device notifications
N///                                       - value 255: no device information for port notifications
N/// \param[in]     notify               notification :
N///                                       - USBH_NOTIFY_CONNECT               = Port connection happened
N///                                       - USBH_NOTIFY_DISCONNECT            = Port disconnection happened
N///                                       - USBH_NOTIFY_OVERCURRENT           = Port overcurrent happened
N///                                       - USBH_NOTIFY_REMOTE_WAKEUP         = Port remote wakeup signaling happened
N///                                       - USBH_NOTIFY_READY                 = Device was successfully enumerated, initialized and is ready for communication
N///                                       - USBH_NOTIFY_UNKNOWN_DEVICE        = Device was successfully enumerated but there is no driver for it
N///                                       - USBH_NOTIFY_INSUFFICIENT_POWER    = Device requires more power consumption than available
N///                                       - USBH_NOTIFY_CONFIGURATION_FAILED  = Device was not successfully configured (not enough resources)
N///                                       - USBH_NOTIFY_INITIALIZATION_FAILED = Device was not successfully initialized
Nextern void USBH_Notify (uint8_t ctrl, uint8_t port, uint8_t device, USBH_NOTIFY notify);
N
N
N//  ==== USB Host Mass Storage Functions ====
N
N// Rename deprecated functions
N#define USBH_MSC_GetDeviceStatus        USBH_MSC_GetStatus
N
N/// \brief Callback function called when Mass Storage Device was enumerated and is ready
N/// \param[in]     instance             instance of MSC Device.
N/// \return                             none.
Nextern void USBH_MSC_Initialize (uint8_t instance);
N
N/// \brief Callback function called when Mass Storage Device was disconnected
N/// \param[in]     instance             instance of MSC Device.
N/// \return                             none.
Nextern void USBH_MSC_Uninitialize (uint8_t instance);
N
N/// \brief Get Device instance of Mass Storage Device
N/// \param[in]     instance             instance of MSC Device.
N/// \return                             instance of Device or non-existing Device instance :
N///                                       - value <= 127 : instance of Device
N///                                       - value 255 :    non-existing Device instance
Nextern uint8_t USBH_MSC_GetDevice (uint8_t instance);
N
N/// \brief Get status of Mass Storage Device
N/// \param[in]     instance             instance of MSC Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_MSC_GetStatus (uint8_t instance);
N
N/// \brief Read requested number of blocks from Mass Storage Device
N/// \param[in]     instance             instance of MSC Device.
N/// \param[in]     lba                  logical block address of first block to read.
N/// \param[in]     cnt                  number of contiguous blocks to read.
N/// \param[out]    buf                  data buffer in which to read data.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_MSC_Read (uint8_t instance, uint32_t lba, uint32_t cnt, uint8_t *buf);
N
N/// \brief Write requested number of blocks to Mass Storage Device
N/// \param[in]     instance             instance of MSC Device.
N/// \param[in]     lba                  logical address of first block to write.
N/// \param[in]     cnt                  number of contiguous blocks to write.
N/// \param[in]     buf                  data buffer containing data to write.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_MSC_Write (uint8_t instance, uint32_t lba, uint32_t cnt, const uint8_t *buf);
N
N/// \brief Read capacity of Mass Storage Device
N/// \param[in]     instance             instance of MSC Device.
N/// \param[out]    block_count          pointer to where total number of blocks available will be read.
N/// \param[out]    block_size           pointer to where block size will be read.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_MSC_ReadCapacity (uint8_t instance, uint32_t *block_count, uint32_t *block_size);
N
N
N//  ==== USB Host Human Interface Device Functions ====
N
N// Rename deprecated functions
N#define USBH_HID_GetDeviceStatus        USBH_HID_GetStatus
N
N/// \brief Callback function called when Human Interface Device was enumerated and is ready
N/// \param[in]     instance             instance of HID Device.
N/// \return                             none.
Nextern void USBH_HID_Initialize (uint8_t instance);
N
N/// \brief Callback function called when Human Interface Device was disconnected
N/// \param[in]     instance             instance of HID Device.
N/// \return                             none.
Nextern void USBH_HID_Uninitialize (uint8_t instance);
N
N/// \brief Get Device instance of Human Interface Device
N/// \param[in]     instance             instance of HID Device.
N/// \return                             instance of Device or non-existing Device instance :
N///                                       - value <= 127 : instance of Device
N///                                       - value 255 :    non-existing Device instance
Nextern uint8_t USBH_HID_GetDevice (uint8_t instance);
N
N/// \brief Get status of Human Interface Device
N/// \param[in]     instance             instance of HID Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_HID_GetStatus (uint8_t instance);
N
N/// \brief Read data received from Human Interface Device
N/// \param[in]     instance             instance of HID Device.
N/// \param[out]    buf                  buffer that receives data.
N/// \param[in]     len                  maximum number of bytes to read.
N/// \return                             number of bytes read or execution status :
N///                                       - value >= 0 : number of bytes read
N///                                       - value < 0 :  error occurred, -value is execution status as defined with \ref usbStatus
Nextern int32_t USBH_HID_Read (uint8_t instance, uint8_t *buf, int32_t len);
N
N/// \brief Write data to Human Interface Device
N/// \param[in]     instance             instance of HID Device.
N/// \param[in]     buf                  data buffer containing data to write.
N/// \param[in]     len                  number of data bytes to write.
N/// \return                             number of bytes accepted for writing or execution status :
N///                                       - value >= 0 : number of bytes accepted for writing
N///                                       - value < 0 :  error occurred, -value is execution status as defined with \ref usbStatus
Nextern int32_t USBH_HID_Write (uint8_t instance, const uint8_t *buf, int32_t len);
N
N/// \brief Retrieve first pending pressed keyboard key on HID Keyboard
N/// \param[in]     instance             instance of HID Device.
N/// \return                             code of first pressed unread key or no key was pressed :
N///                                       - value >= 0 : code of first pressed unread key
N///                                       - value -1 :   indicates no key was pressed since last time this function was called
Nextern int USBH_HID_GetKeyboardKey (uint8_t instance);
N
N/// \brief Retrieve state change since last call of this function
N/// \param[in]     instance             instance of HID Device.
N/// \param[out]    state                pointer to mouse state \ref usbHID_MouseState structure.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_HID_GetMouseState (uint8_t instance, usbHID_MouseState *state);
N
N/// \brief Callback function called for parsing of the Human Interface Device report descriptor
N/// \param[in]     instance             instance index.
N/// \param[in]     ptr_hid_report_desc  pointer to HID report descriptor.
N/// \param[in]     len                  length of HID report descriptor.
N/// \return                             none.
Nextern void USBH_HID_ParseReportDescriptor (uint8_t instance, const uint8_t *ptr_hid_report_desc, uint32_t len);
N
N/// \brief Callback function called when data is received from the Human Interface Device
N/// \param[in]     instance             instance index.
N/// \param[in]     len                  length of received data.
N/// \return                             none.
Nextern void USBH_HID_DataReceived (uint8_t instance, uint32_t len);
N
N
N//  ==== USB Host Communication Device Class (Abstract Control Model) Functions ====
N
N// Rename deprecated functions
N#define USBH_CDC_ACM_GetDeviceStatus    USBH_CDC_ACM_GetStatus
N
N/// \brief Callback function called when Communication Device Class device was enumerated and is ready
N/// \param[in]     instance             instance of CDC Device.
N/// \return                             none.
Nextern void USBH_CDC_ACM_Initialize (uint8_t instance);
N
N/// \brief Callback function called when Communication Device Class device was disconnected
N/// \param[in]     instance             instance of CDC Device.
N/// \return                             none.
Nextern void USBH_CDC_ACM_Uninitialize (uint8_t instance);
N
N/// \brief Get Device instance of Communication Device Class device
N/// \param[in]     instance             instance of CDC Device.
N/// \return                             instance of Device or non-existing Device instance :
N///                                       - value <= 127 : instance of Device
N///                                       - value 255 :    non-existing Device instance
Nextern uint8_t USBH_CDC_ACM_GetDevice (uint8_t instance);
N
N/// \brief Get status of Communication Device Class device
N/// \param[in]     instance             instance of CDC Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_CDC_ACM_GetStatus (uint8_t instance);
N
N/// \brief Send data to Communication Device Class device
N/// \param[in]     instance             index of CDC instance.
N/// \param[in]     data                 buffer containing data bytes to send.
N/// \param[in]     num                  number of bytes to send.
N/// \return                             status code that indicates the execution status of the function as defined with usbStatus.
Nextern usbStatus USBH_CDC_ACM_Send (uint8_t instance, const uint8_t *data, uint32_t num);
N
N/// \brief Get result of send data to Communication Device Class device
N/// \param[in]     instance             index of CDC instance.
N/// \return                             number of successfully sent data bytes.
Nextern uint32_t USBH_CDC_ACM_GetTxCount (uint8_t instance);
N
N/// \brief Receive data from Communication Device Class device
N/// \param[in]     instance             index of CDC instance
N/// \param[out]    data                 buffer that receives data.
N/// \param[in]     num                  maximum number of bytes to receive.
N/// \return                             status code that indicates the execution status of the function as defined with usbStatus.
Nextern usbStatus USBH_CDC_ACM_Receive (uint8_t instance, uint8_t *data, uint32_t num);
N
N/// \brief Get result of receive data from Communication Device Class device
N/// \param[in]     instance             index of CDC instance.
N/// \return                             number of successfully received data bytes.
Nextern uint32_t USBH_CDC_ACM_GetRxCount (uint8_t instance);
N
N/// \brief Change communication settings of Communication Device Class device
N/// \param[in]     instance             index of CDC instance.
N/// \param[in]     line_coding          pointer to CDC_LINE_CODING structure.
N/// \return                             status code that indicates the execution status of the function as defined with usbStatus.
Nextern usbStatus USBH_CDC_ACM_SetLineCoding (uint8_t instance, const CDC_LINE_CODING *line_coding);
N
N/// \brief Retrieve communication settings of Communication Device Class device
N/// \param[in]     instance             index of CDC instance.
N/// \param[out]    line_coding          pointer to CDC_LINE_CODING structure.
N/// \return                             status code that indicates the execution status of the function as defined with usbStatus.
Nextern usbStatus USBH_CDC_ACM_GetLineCoding (uint8_t instance, CDC_LINE_CODING *line_coding);
N
N/// \brief Set control line states of Communication Device Class device
N/// \param[in]     instance             index of CDC instance.
N/// \param[in]     state                control line settings bitmap :
N///                                       - bit 0 : DTR state
N///                                       - bit 1 : RTS state
N/// \return                             status code that indicates the execution status of the function as defined with usbStatus.
Nextern usbStatus USBH_CDC_ACM_SetControlLineState (uint8_t instance, uint16_t state);
N
N/// \brief Callback function called when Communication Device Class device
N///        modem line or error status changes
N/// \param[in]     instance             index of CDC instance.
N/// \param[in]     status               error status and line states :
N///                                       - bit 6 : bOverRun
N///                                       - bit 5 : bParity
N///                                       - bit 4 : bFraming
N///                                       - bit 3 : bRingSignal
N///                                       - bit 2 : bBreak
N///                                       - bit 1 : bTxCarrier (DSR line state)
N///                                       - bit 0 : bRxCarrier (DCD line state)
N/// \return                             none.
Nextern void USBH_CDC_ACM_Notify (uint8_t instance, uint16_t status);
N
N/// \brief Send break on Communication Device Class device
N/// \param[in]     instance             index of CDC instance.
N/// \param[in]     duration             duration of break (in milliseconds) :
N///                                       - value 65535 : indefinite
N///                                       - value     0 : immediate
N/// \return                             status code that indicates the execution status of the function as defined with usbStatus.
Nextern usbStatus USBH_CDC_ACM_SendBreak (uint8_t instance, uint16_t duration);
N
N
N//  ==== USB Host Custom Class Functions ====
N
N// Rename deprecated functions
N#define USBH_CustomClass_GetDeviceStatus    USBH_CustomClass_GetStatus
N
N/// \brief Get Device instance of Custom Class Device
N/// \param[in]     instance             instance of Custom Class Device.
N/// \return                             instance of Device or non-existing Device instance :
N///                                       - value <= 127 : instance of Device
N///                                       - value 255 :    non-existing Device instance
Nextern uint8_t USBH_CustomClass_GetDevice (uint8_t instance);
N
N/// \brief Get status of Custom Class Device
N/// \param[in]     instance             instance of Custom Class Device.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_CustomClass_GetStatus (uint8_t instance);
N
N/// \brief Callback function called when custom class device is connected and needs
N///        to configure resources used by custom class device instance
N/// \param[in]     device               index of USB Device.
N/// \param[in]     ptr_dev_desc         pointer to device descriptor.
N/// \param[in]     ptr_cfg_desc         pointer to configuration descriptor.
N/// \return                             index of configured custom class device instance or configuration failed :
N///                                       - value <= 127 : index of configured custom class device instance
N///                                       - value 255 :    configuration failed
Nextern uint8_t USBH_CustomClass_Configure (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc);
N
N/// \brief Callback function called when custom class device is disconnected and needs
N///        to de-configure resources used by custom class device instance
N/// \param[in]     instance             index of custom class device instance.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_CustomClass_Unconfigure (uint8_t instance);
N
N/// \brief Callback function called when custom class device is connected and needs
N///        to initialize custom class device instance
N/// \param[in]     instance             index of custom class device instance.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_CustomClass_Initialize (uint8_t instance);
N
N/// \brief Callback function called when custom class device is disconnected and needs
N///        to de-initialize custom class device instance
N/// \param[in]     instance             index of custom class device instance.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_CustomClass_Uninitialize (uint8_t instance);
N
N/// \brief Create Pipe
N/// \param[in]     device               index of USB Device.
N/// \param[in]     ep_addr              endpoint address :
N///                                       - ep_addr.0..3 : address
N///                                       - ep_addr.7 :    direction
N/// \param[in]     ep_type              endpoint type.
N/// \param[in]     ep_max_packet_size   endpoint maximum packet size.
N/// \param[in]     ep_interval          endpoint polling interval.
N/// \return                             pipe handle or pipe creation failed :
N///                                       - value > 0 : pipe handle
N///                                       - value 0 :   pipe creation failed
Nextern USBH_PIPE_HANDLE USBH_PipeCreate (uint8_t device, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_max_packet_size, uint8_t ep_interval);
N
N/// \brief Update Pipe
N/// \param[in]     pipe_hndl            pipe handle.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_PipeUpdate (USBH_PIPE_HANDLE pipe_hndl);
N
N/// \brief Delete Pipe
N/// \param[in]     pipe_hndl            pipe handle.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_PipeDelete (USBH_PIPE_HANDLE pipe_hndl);
N
N/// \brief Reset Pipe (reset data toggle)
N/// \param[in]     pipe_hndl            pipe handle.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_PipeReset (USBH_PIPE_HANDLE pipe_hndl);
N
N/// \brief Receive data on Pipe
N/// \param[in]     pipe_hndl            pipe handle.
N/// \param[out]    buf                  buffer that receives data.
N/// \param[in]     len                  maximum number of bytes to receive.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_PipeReceive (USBH_PIPE_HANDLE pipe_hndl, uint8_t *buf, uint32_t len);
N
N/// \brief Get result of receive data operation on Pipe
N/// \param[in]     pipe_hndl            pipe handle.
N/// \return                             number of successfully received data bytes.
Nextern uint32_t USBH_PipeReceiveGetResult (USBH_PIPE_HANDLE pipe_hndl);
N
N/// \brief Send data on Pipe
N/// \param[in]     pipe_hndl            pipe handle.
N/// \param[in]     buf                  buffer containing data bytes to send.
N/// \param[in]     len                  number of bytes to send.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_PipeSend (USBH_PIPE_HANDLE pipe_hndl, const uint8_t *buf, uint32_t len);
N
N/// \brief Get result of send data operation on Pipe
N/// \param[in]     pipe_hndl            pipe handle.
N/// \return                             number of successfully sent data bytes.
Nextern uint32_t USBH_PipeSendGetResult (USBH_PIPE_HANDLE pipe_hndl);
N
N/// \brief Abort send/receive operation on Pipe
N/// \param[in]     pipe_hndl            pipe handle.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_PipeAbort (USBH_PIPE_HANDLE pipe_hndl);
N
N/// \brief Do a Control Transfer on Default Pipe
N/// \param[in]     device               index of USB Device.
N/// \param[in]     setup_packet         pointer to setup packet.
N/// \param[in,out] data                 buffer containing data bytes to send or where data should be received in data stage of Control Transfer.
N/// \param[in]     len                  number of bytes to send or receive in data stage of Control Transfer.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_ControlTransfer (uint8_t device, const USB_SETUP_PACKET *setup_packet, uint8_t *data, uint32_t len);
N
N/// \brief Standard Device Request on Default Pipe - GET_STATUS
N/// \param[in]     device               index of USB Device.
N/// \param[in]     recipient            recipient.
N/// \param[in]     index                interface or endpoint index.
N/// \param[out]    ptr_stat_dat         pointer to where status data should be received.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_GetStatus (uint8_t device, uint8_t recipient, uint8_t index, uint8_t *ptr_stat_dat);
N
N/// \brief Standard Device Request on Default Pipe - CLEAR_FEATURE
N/// \param[in]     device               index of USB Device.
N/// \param[in]     recipient            recipient.
N/// \param[in]     index                interface or endpoint index.
N/// \param[in]     feature_selector     feature selector.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_ClearFeature (uint8_t device, uint8_t recipient, uint8_t index, uint8_t feature_selector);
N
N/// \brief Standard Device Request on Default Pipe - SET_FEATURE
N/// \param[in]     device               index of USB Device.
N/// \param[in]     recipient            recipient.
N/// \param[in]     index                interface or endpoint index.
N/// \param[in]     feature_selector     feature selector.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_SetFeature (uint8_t device, uint8_t recipient, uint8_t index, uint8_t feature_selector);
N
N/// \brief Standard Device Request on Default Pipe - SET_ADDRESS
N/// \param[in]     device               index of USB Device.
N/// \param[in]     device_address       device address.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_SetAddress (uint8_t device, uint8_t device_address);
N
N/// \brief Standard Device Request on Default Pipe - GET_DESCRIPTOR
N/// \param[in]     device               index of USB Device.
N/// \param[in]     recipient            recipient.
N/// \param[in]     descriptor_type      descriptor type.
N/// \param[in]     descriptor_index     descriptor index.
N/// \param[in]     language_id          language ID.
N/// \param[out]    descriptor_data      pointer to where descriptor data will be read.
N/// \param[in]     descriptor_length    maximum descriptor length.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_GetDescriptor (uint8_t device, uint8_t recipient, uint8_t descriptor_type, uint8_t descriptor_index, uint16_t language_id, uint8_t *descriptor_data, uint16_t descriptor_length);
N
N/// \brief Standard Device Request on Default Pipe - SET_DESCRIPTOR
N/// \param[in]     device               index of USB Device.
N/// \param[in]     recipient            recipient.
N/// \param[in]     descriptor_type      descriptor type.
N/// \param[in]     descriptor_index     descriptor index.
N/// \param[in]     language_id          language ID.
N/// \param[in]     descriptor_data      pointer to descriptor data to be written.
N/// \param[in]     descriptor_length    descriptor length.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_SetDescriptor (uint8_t device, uint8_t recipient, uint8_t descriptor_type, uint8_t descriptor_index, uint16_t language_id, const uint8_t *descriptor_data, uint16_t descriptor_length);
N
N/// \brief Standard Device Request on Default Pipe - GET_CONFIGURATION
N/// \param[in]     device               index of USB Device.
N/// \param[out]    ptr_configuration    pointer to where configuration will be read.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_GetConfiguration (uint8_t device, uint8_t *ptr_configuration);
N
N/// \brief Standard Device Request on Default Pipe - SET_CONFIGURATION
N/// \param[in]     device               index of USB Device.
N/// \param[in]     configuration        configuration.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_SetConfiguration (uint8_t device, uint8_t configuration);
N
N/// \brief Standard Device Request on Default Pipe - GET_INTERFACE
N/// \param[in]     device               index of USB Device.
N/// \param[in]     index                interface index.
N/// \param[out]    ptr_alternate        pointer to where alternate setting data will be read.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_GetInterface (uint8_t device, uint8_t index, uint8_t *ptr_alternate);
N
N/// \brief Standard Device Request on Default Pipe - SET_INTERFACE
N/// \param[in]     device               index of USB Device.
N/// \param[in]     index                interface index.
N/// \param[in]     alternate            alternate setting.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_SetInterface (uint8_t device, uint8_t index, uint8_t alternate);
N
N/// \brief Standard Device Request on Default Pipe - SYNCH_FRAME
N/// \param[in]     device               index of USB Device.
N/// \param[in]     index                interface or endpoint index.
N/// \param[out]    ptr_frame_number     pointer to where frame number data will be read.
N/// \return                             status code that indicates the execution status of the function as defined with \ref usbStatus.
Nextern usbStatus USBH_DeviceRequest_SynchFrame (uint8_t device, uint8_t index, uint8_t *ptr_frame_number);
N
N
N// USB Device OS abstraction functions
Nextern void             *USBD_ThreadCreate                  (usbdThread_t thread, uint8_t index);
Nextern int32_t           USBD_ThreadTerminate               (void *thread_hndl);
N
Nextern int32_t           USBD_Delay                         (uint32_t millisec);
N
Nextern void             *USBD_TimerCreate                   (uint8_t instance);
Nextern int32_t           USBD_TimerStart                    (void *timer_hndl, uint32_t millisec);
Nextern int32_t           USBD_TimerStop                     (void *timer_hndl);
Nextern int32_t           USBD_TimerDelete                   (void *timer_hndl);
N
Nextern uint32_t          USBD_ThreadFlagsSet                (void *thread_hndl, uint32_t flags);
Nextern uint32_t          USBD_ThreadFlagsWait               (uint32_t millisec);
N
Nextern void             *USBD_SemaphoreCreate               (usbdSemaphore_t semaphore, uint8_t index1, uint8_t index2);
Nextern int32_t           USBD_SemaphoreAcquire              (void *semaphore_hndl, uint32_t millisec);
Nextern int32_t           USBD_SemaphoreRelease              (void *semaphore_hndl);
Nextern int32_t           USBD_SemaphoreDelete               (void *semaphore_hndl);
N
N
N// USB Device user callback function prototypes
Nextern void              USBD_Device0_Initialize            (void);
Nextern void              USBD_Device0_Uninitialize          (void);
Nextern void              USBD_Device0_VbusChanged           (bool level);
Xextern void              USBD_Device0_VbusChanged           (_Bool level);
Nextern void              USBD_Device0_Reset                 (void);
Nextern void              USBD_Device0_HighSpeedActivated    (void);
Nextern void              USBD_Device0_Suspended             (void);
Nextern void              USBD_Device0_Resumed               (void);
Nextern void              USBD_Device0_ConfigurationChanged  (uint8_t val);
Nextern void              USBD_Device0_EnableRemoteWakeup    (void);
Nextern void              USBD_Device0_DisableRemoteWakeup   (void);
Nextern usbdRequestStatus USBD_Device0_Endpoint0_SetupPacketReceived  (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
Nextern void              USBD_Device0_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
Nextern usbdRequestStatus USBD_Device0_Endpoint0_OutDataReceived      (uint32_t len);
Nextern usbdRequestStatus USBD_Device0_Endpoint0_InDataSent           (uint32_t len);
N
Nextern void              USBD_Device1_Initialize            (void);
Nextern void              USBD_Device1_Uninitialize          (void);
Nextern void              USBD_Device1_VbusChanged           (bool level);
Xextern void              USBD_Device1_VbusChanged           (_Bool level);
Nextern void              USBD_Device1_Reset                 (void);
Nextern void              USBD_Device1_HighSpeedActivated    (void);
Nextern void              USBD_Device1_Suspended             (void);
Nextern void              USBD_Device1_Resumed               (void);
Nextern void              USBD_Device1_ConfigurationChanged  (uint8_t val);
Nextern void              USBD_Device1_EnableRemoteWakeup    (void);
Nextern void              USBD_Device1_DisableRemoteWakeup   (void);
Nextern usbdRequestStatus USBD_Device1_Endpoint0_SetupPacketReceived  (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
Nextern void              USBD_Device1_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
Nextern usbdRequestStatus USBD_Device1_Endpoint0_OutDataReceived      (uint32_t len);
Nextern usbdRequestStatus USBD_Device1_Endpoint0_InDataSent           (uint32_t len);
N
Nextern void              USBD_Device2_Initialize            (void);
Nextern void              USBD_Device2_Uninitialize          (void);
Nextern void              USBD_Device2_VbusChanged           (bool level);
Xextern void              USBD_Device2_VbusChanged           (_Bool level);
Nextern void              USBD_Device2_Reset                 (void);
Nextern void              USBD_Device2_HighSpeedActivated    (void);
Nextern void              USBD_Device2_Suspended             (void);
Nextern void              USBD_Device2_Resumed               (void);
Nextern void              USBD_Device2_ConfigurationChanged  (uint8_t val);
Nextern void              USBD_Device2_EnableRemoteWakeup    (void);
Nextern void              USBD_Device2_DisableRemoteWakeup   (void);
Nextern usbdRequestStatus USBD_Device2_Endpoint0_SetupPacketReceived  (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
Nextern void              USBD_Device2_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
Nextern usbdRequestStatus USBD_Device2_Endpoint0_OutDataReceived      (uint32_t len);
Nextern usbdRequestStatus USBD_Device2_Endpoint0_InDataSent           (uint32_t len);
N
Nextern void              USBD_Device3_Initialize            (void);
Nextern void              USBD_Device3_Uninitialize          (void);
Nextern void              USBD_Device3_VbusChanged           (bool level);
Xextern void              USBD_Device3_VbusChanged           (_Bool level);
Nextern void              USBD_Device3_Reset                 (void);
Nextern void              USBD_Device3_HighSpeedActivated    (void);
Nextern void              USBD_Device3_Suspended             (void);
Nextern void              USBD_Device3_Resumed               (void);
Nextern void              USBD_Device3_ConfigurationChanged  (uint8_t val);
Nextern void              USBD_Device3_EnableRemoteWakeup    (void);
Nextern void              USBD_Device3_DisableRemoteWakeup   (void);
Nextern usbdRequestStatus USBD_Device3_Endpoint0_SetupPacketReceived  (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
Nextern void              USBD_Device3_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
Nextern usbdRequestStatus USBD_Device3_Endpoint0_OutDataReceived      (uint32_t len);
Nextern usbdRequestStatus USBD_Device3_Endpoint0_InDataSent           (uint32_t len);
N
Nextern void              USBD_ADC0_Initialize               (void);
Nextern void              USBD_ADC0_Uninitialize             (void);
Nextern void              USBD_ADC0_PlayStart                (void);
Nextern void              USBD_ADC0_PlayStop                 (void);
Nextern void              USBD_ADC0_SetSpeakerMute           (uint8_t ch, bool on);
Xextern void              USBD_ADC0_SetSpeakerMute           (uint8_t ch, _Bool on);
Nextern void              USBD_ADC0_SetSpeakerVolume         (uint8_t ch, uint16_t vol);
Nextern void              USBD_ADC0_RecordStart              (void);
Nextern void              USBD_ADC0_RecordStop               (void);
Nextern void              USBD_ADC0_SetMicrophoneMute        (uint8_t ch, bool on);
Xextern void              USBD_ADC0_SetMicrophoneMute        (uint8_t ch, _Bool on);
Nextern void              USBD_ADC0_SetMicrophoneVolume      (uint8_t ch, uint16_t vol);
Nextern void              USBD_ADC0_ReceivedSamples          (void);
N
Nextern void              USBD_ADC1_Initialize               (void);
Nextern void              USBD_ADC1_Uninitialize             (void);
Nextern void              USBD_ADC1_PlayStart                (void);
Nextern void              USBD_ADC1_PlayStop                 (void);
Nextern void              USBD_ADC1_SetSpeakerMute           (uint8_t ch, bool on);
Xextern void              USBD_ADC1_SetSpeakerMute           (uint8_t ch, _Bool on);
Nextern void              USBD_ADC1_SetSpeakerVolume         (uint8_t ch, uint16_t vol);
Nextern void              USBD_ADC1_RecordStart              (void);
Nextern void              USBD_ADC1_RecordStop               (void);
Nextern void              USBD_ADC1_SetMicrophoneMute        (uint8_t ch, bool on);
Xextern void              USBD_ADC1_SetMicrophoneMute        (uint8_t ch, _Bool on);
Nextern void              USBD_ADC1_SetMicrophoneVolume      (uint8_t ch, uint16_t vol);
Nextern void              USBD_ADC1_ReceivedSamples          (void);
N 
Nextern void              USBD_ADC2_Initialize               (void);
Nextern void              USBD_ADC2_Uninitialize             (void);
Nextern void              USBD_ADC2_PlayStart                (void);
Nextern void              USBD_ADC2_PlayStop                 (void);
Nextern void              USBD_ADC2_SetSpeakerMute           (uint8_t ch, bool on);
Xextern void              USBD_ADC2_SetSpeakerMute           (uint8_t ch, _Bool on);
Nextern void              USBD_ADC2_SetSpeakerVolume         (uint8_t ch, uint16_t vol);
Nextern void              USBD_ADC2_RecordStart              (void);
Nextern void              USBD_ADC2_RecordStop               (void);
Nextern void              USBD_ADC2_SetMicrophoneMute        (uint8_t ch, bool on);
Xextern void              USBD_ADC2_SetMicrophoneMute        (uint8_t ch, _Bool on);
Nextern void              USBD_ADC2_SetMicrophoneVolume      (uint8_t ch, uint16_t vol);
Nextern void              USBD_ADC2_ReceivedSamples          (void);
N 
Nextern void              USBD_ADC3_Initialize               (void);
Nextern void              USBD_ADC3_Uninitialize             (void);
Nextern void              USBD_ADC3_PlayStart                (void);
Nextern void              USBD_ADC3_PlayStop                 (void);
Nextern void              USBD_ADC3_SetSpeakerMute           (uint8_t ch, bool on);
Xextern void              USBD_ADC3_SetSpeakerMute           (uint8_t ch, _Bool on);
Nextern void              USBD_ADC3_SetSpeakerVolume         (uint8_t ch, uint16_t vol);
Nextern void              USBD_ADC3_RecordStart              (void);
Nextern void              USBD_ADC3_RecordStop               (void);
Nextern void              USBD_ADC3_SetMicrophoneMute        (uint8_t ch, bool on);
Xextern void              USBD_ADC3_SetMicrophoneMute        (uint8_t ch, _Bool on);
Nextern void              USBD_ADC3_SetMicrophoneVolume      (uint8_t ch, uint16_t vol);
Nextern void              USBD_ADC3_ReceivedSamples          (void);
N 
Nextern void              USBD_CDC0_ACM_Initialize           (void);
Nextern void              USBD_CDC0_ACM_Uninitialize         (void);
Nextern void              USBD_CDC0_ACM_Reset                (void);
Nextern bool              USBD_CDC0_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Xextern _Bool              USBD_CDC0_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Nextern bool              USBD_CDC0_ACM_SetControlLineState  (uint16_t state);
Xextern _Bool              USBD_CDC0_ACM_SetControlLineState  (uint16_t state);
Nextern void              USBD_CDC0_ACM_DataReceived         (uint32_t len);
Nextern void              USBD_CDC0_ACM_DataSent             (void);
Nextern void              USBD_CDC0_NCM_Initialize           (void);
Nextern void              USBD_CDC0_NCM_Uninitialize         (void);
Nextern void              USBD_CDC0_NCM_Reset                (void);
Nextern void              USBD_CDC0_NCM_Start                (void);
Nextern void              USBD_CDC0_NCM_Stop                 (void);
Nextern bool              USBD_CDC0_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Xextern _Bool              USBD_CDC0_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Nextern bool              USBD_CDC0_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Xextern _Bool              USBD_CDC0_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Nextern bool              USBD_CDC0_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Xextern _Bool              USBD_CDC0_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Nextern bool              USBD_CDC0_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Xextern _Bool              USBD_CDC0_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Nextern bool              USBD_CDC0_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Xextern _Bool              USBD_CDC0_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Nextern bool              USBD_CDC0_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Xextern _Bool              USBD_CDC0_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Nextern bool              USBD_CDC0_NCM_GetNetAddress        (uint8_t *net_addr);
Xextern _Bool              USBD_CDC0_NCM_GetNetAddress        (uint8_t *net_addr);
Nextern bool              USBD_CDC0_NCM_SetNetAddress        (const uint8_t *net_addr);
Xextern _Bool              USBD_CDC0_NCM_SetNetAddress        (const uint8_t *net_addr);
Nextern bool              USBD_CDC0_NCM_GetNtbFormat         (uint16_t *ntb_format);
Xextern _Bool              USBD_CDC0_NCM_GetNtbFormat         (uint16_t *ntb_format);
Nextern bool              USBD_CDC0_NCM_SetNtbFormat         (uint16_t  ntb_format);
Xextern _Bool              USBD_CDC0_NCM_SetNtbFormat         (uint16_t  ntb_format);
Nextern bool              USBD_CDC0_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Xextern _Bool              USBD_CDC0_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Nextern bool              USBD_CDC0_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Xextern _Bool              USBD_CDC0_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Nextern bool              USBD_CDC0_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Xextern _Bool              USBD_CDC0_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Nextern bool              USBD_CDC0_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Xextern _Bool              USBD_CDC0_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Nextern bool              USBD_CDC0_NCM_GetCrcMode           (uint16_t *crc_mode);
Xextern _Bool              USBD_CDC0_NCM_GetCrcMode           (uint16_t *crc_mode);
Nextern bool              USBD_CDC0_NCM_SetCrcMode           (uint16_t  crc_mode);
Xextern _Bool              USBD_CDC0_NCM_SetCrcMode           (uint16_t  crc_mode);
Nextern void              USBD_CDC0_NCM_NTB_IN_Sent          (void);
Nextern void              USBD_CDC0_NCM_NTB_OUT_Received     (void);
N 
Nextern void              USBD_CDC1_ACM_Initialize           (void);
Nextern void              USBD_CDC1_ACM_Uninitialize         (void);
Nextern void              USBD_CDC1_ACM_Reset                (void);
Nextern bool              USBD_CDC1_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Xextern _Bool              USBD_CDC1_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Nextern bool              USBD_CDC1_ACM_SetControlLineState  (uint16_t state);
Xextern _Bool              USBD_CDC1_ACM_SetControlLineState  (uint16_t state);
Nextern void              USBD_CDC1_ACM_DataReceived         (uint32_t len);
Nextern void              USBD_CDC1_ACM_DataSent             (void);
Nextern void              USBD_CDC1_NCM_Initialize           (void);
Nextern void              USBD_CDC1_NCM_Uninitialize         (void);
Nextern void              USBD_CDC1_NCM_Reset                (void);
Nextern void              USBD_CDC1_NCM_Start                (void);
Nextern void              USBD_CDC1_NCM_Stop                 (void);
Nextern bool              USBD_CDC1_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Xextern _Bool              USBD_CDC1_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Nextern bool              USBD_CDC1_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Xextern _Bool              USBD_CDC1_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Nextern bool              USBD_CDC1_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Xextern _Bool              USBD_CDC1_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Nextern bool              USBD_CDC1_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Xextern _Bool              USBD_CDC1_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Nextern bool              USBD_CDC1_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Xextern _Bool              USBD_CDC1_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Nextern bool              USBD_CDC1_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Xextern _Bool              USBD_CDC1_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Nextern bool              USBD_CDC1_NCM_GetNetAddress        (uint8_t *net_addr);
Xextern _Bool              USBD_CDC1_NCM_GetNetAddress        (uint8_t *net_addr);
Nextern bool              USBD_CDC1_NCM_SetNetAddress        (const uint8_t *net_addr);
Xextern _Bool              USBD_CDC1_NCM_SetNetAddress        (const uint8_t *net_addr);
Nextern bool              USBD_CDC1_NCM_GetNtbFormat         (uint16_t *ntb_format);
Xextern _Bool              USBD_CDC1_NCM_GetNtbFormat         (uint16_t *ntb_format);
Nextern bool              USBD_CDC1_NCM_SetNtbFormat         (uint16_t  ntb_format);
Xextern _Bool              USBD_CDC1_NCM_SetNtbFormat         (uint16_t  ntb_format);
Nextern bool              USBD_CDC1_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Xextern _Bool              USBD_CDC1_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Nextern bool              USBD_CDC1_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Xextern _Bool              USBD_CDC1_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Nextern bool              USBD_CDC1_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Xextern _Bool              USBD_CDC1_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Nextern bool              USBD_CDC1_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Xextern _Bool              USBD_CDC1_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Nextern bool              USBD_CDC1_NCM_GetCrcMode           (uint16_t *crc_mode);
Xextern _Bool              USBD_CDC1_NCM_GetCrcMode           (uint16_t *crc_mode);
Nextern bool              USBD_CDC1_NCM_SetCrcMode           (uint16_t  crc_mode);
Xextern _Bool              USBD_CDC1_NCM_SetCrcMode           (uint16_t  crc_mode);
Nextern void              USBD_CDC1_NCM_NTB_IN_Sent          (void);
Nextern void              USBD_CDC1_NCM_NTB_OUT_Received     (void);
N 
Nextern void              USBD_CDC2_ACM_Initialize           (void);
Nextern void              USBD_CDC2_ACM_Uninitialize         (void);
Nextern void              USBD_CDC2_ACM_Reset                (void);
Nextern bool              USBD_CDC2_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Xextern _Bool              USBD_CDC2_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Nextern bool              USBD_CDC2_ACM_SetControlLineState  (uint16_t state);
Xextern _Bool              USBD_CDC2_ACM_SetControlLineState  (uint16_t state);
Nextern void              USBD_CDC2_ACM_DataReceived         (uint32_t len);
Nextern void              USBD_CDC2_ACM_DataSent             (void);
Nextern void              USBD_CDC2_NCM_Initialize           (void);
Nextern void              USBD_CDC2_NCM_Uninitialize         (void);
Nextern void              USBD_CDC2_NCM_Reset                (void);
Nextern void              USBD_CDC2_NCM_Start                (void);
Nextern void              USBD_CDC2_NCM_Stop                 (void);
Nextern bool              USBD_CDC2_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Xextern _Bool              USBD_CDC2_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Nextern bool              USBD_CDC2_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Xextern _Bool              USBD_CDC2_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Nextern bool              USBD_CDC2_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Xextern _Bool              USBD_CDC2_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Nextern bool              USBD_CDC2_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Xextern _Bool              USBD_CDC2_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Nextern bool              USBD_CDC2_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Xextern _Bool              USBD_CDC2_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Nextern bool              USBD_CDC2_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Xextern _Bool              USBD_CDC2_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Nextern bool              USBD_CDC2_NCM_GetNetAddress        (uint8_t *net_addr);
Xextern _Bool              USBD_CDC2_NCM_GetNetAddress        (uint8_t *net_addr);
Nextern bool              USBD_CDC2_NCM_SetNetAddress        (const uint8_t *net_addr);
Xextern _Bool              USBD_CDC2_NCM_SetNetAddress        (const uint8_t *net_addr);
Nextern bool              USBD_CDC2_NCM_GetNtbFormat         (uint16_t *ntb_format);
Xextern _Bool              USBD_CDC2_NCM_GetNtbFormat         (uint16_t *ntb_format);
Nextern bool              USBD_CDC2_NCM_SetNtbFormat         (uint16_t  ntb_format);
Xextern _Bool              USBD_CDC2_NCM_SetNtbFormat         (uint16_t  ntb_format);
Nextern bool              USBD_CDC2_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Xextern _Bool              USBD_CDC2_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Nextern bool              USBD_CDC2_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Xextern _Bool              USBD_CDC2_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Nextern bool              USBD_CDC2_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Xextern _Bool              USBD_CDC2_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Nextern bool              USBD_CDC2_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Xextern _Bool              USBD_CDC2_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Nextern bool              USBD_CDC2_NCM_GetCrcMode           (uint16_t *crc_mode);
Xextern _Bool              USBD_CDC2_NCM_GetCrcMode           (uint16_t *crc_mode);
Nextern bool              USBD_CDC2_NCM_SetCrcMode           (uint16_t  crc_mode);
Xextern _Bool              USBD_CDC2_NCM_SetCrcMode           (uint16_t  crc_mode);
Nextern void              USBD_CDC2_NCM_NTB_IN_Sent          (void);
Nextern void              USBD_CDC2_NCM_NTB_OUT_Received     (void);
N 
Nextern void              USBD_CDC3_ACM_Initialize           (void);
Nextern void              USBD_CDC3_ACM_Uninitialize         (void);
Nextern void              USBD_CDC3_ACM_Reset                (void);
Nextern bool              USBD_CDC3_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Xextern _Bool              USBD_CDC3_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Nextern bool              USBD_CDC3_ACM_SetControlLineState  (uint16_t state);
Xextern _Bool              USBD_CDC3_ACM_SetControlLineState  (uint16_t state);
Nextern void              USBD_CDC3_ACM_DataReceived         (uint32_t len);
Nextern void              USBD_CDC3_ACM_DataSent             (void);
Nextern void              USBD_CDC3_NCM_Initialize           (void);
Nextern void              USBD_CDC3_NCM_Uninitialize         (void);
Nextern void              USBD_CDC3_NCM_Reset                (void);
Nextern void              USBD_CDC3_NCM_Start                (void);
Nextern void              USBD_CDC3_NCM_Stop                 (void);
Nextern bool              USBD_CDC3_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Xextern _Bool              USBD_CDC3_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Nextern bool              USBD_CDC3_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Xextern _Bool              USBD_CDC3_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Nextern bool              USBD_CDC3_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Xextern _Bool              USBD_CDC3_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Nextern bool              USBD_CDC3_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Xextern _Bool              USBD_CDC3_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Nextern bool              USBD_CDC3_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Xextern _Bool              USBD_CDC3_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Nextern bool              USBD_CDC3_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Xextern _Bool              USBD_CDC3_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Nextern bool              USBD_CDC3_NCM_GetNetAddress        (uint8_t *net_addr);
Xextern _Bool              USBD_CDC3_NCM_GetNetAddress        (uint8_t *net_addr);
Nextern bool              USBD_CDC3_NCM_SetNetAddress        (const uint8_t *net_addr);
Xextern _Bool              USBD_CDC3_NCM_SetNetAddress        (const uint8_t *net_addr);
Nextern bool              USBD_CDC3_NCM_GetNtbFormat         (uint16_t *ntb_format);
Xextern _Bool              USBD_CDC3_NCM_GetNtbFormat         (uint16_t *ntb_format);
Nextern bool              USBD_CDC3_NCM_SetNtbFormat         (uint16_t  ntb_format);
Xextern _Bool              USBD_CDC3_NCM_SetNtbFormat         (uint16_t  ntb_format);
Nextern bool              USBD_CDC3_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Xextern _Bool              USBD_CDC3_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Nextern bool              USBD_CDC3_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Xextern _Bool              USBD_CDC3_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Nextern bool              USBD_CDC3_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Xextern _Bool              USBD_CDC3_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Nextern bool              USBD_CDC3_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Xextern _Bool              USBD_CDC3_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Nextern bool              USBD_CDC3_NCM_GetCrcMode           (uint16_t *crc_mode);
Xextern _Bool              USBD_CDC3_NCM_GetCrcMode           (uint16_t *crc_mode);
Nextern bool              USBD_CDC3_NCM_SetCrcMode           (uint16_t  crc_mode);
Xextern _Bool              USBD_CDC3_NCM_SetCrcMode           (uint16_t  crc_mode);
Nextern void              USBD_CDC3_NCM_NTB_IN_Sent          (void);
Nextern void              USBD_CDC3_NCM_NTB_OUT_Received     (void);
N 
Nextern void              USBD_CDC4_ACM_Initialize           (void);
Nextern void              USBD_CDC4_ACM_Uninitialize         (void);
Nextern void              USBD_CDC4_ACM_Reset                (void);
Nextern bool              USBD_CDC4_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Xextern _Bool              USBD_CDC4_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Nextern bool              USBD_CDC4_ACM_SetControlLineState  (uint16_t state);
Xextern _Bool              USBD_CDC4_ACM_SetControlLineState  (uint16_t state);
Nextern void              USBD_CDC4_ACM_DataReceived         (uint32_t len);
Nextern void              USBD_CDC4_ACM_DataSent             (void);
Nextern void              USBD_CDC4_NCM_Initialize           (void);
Nextern void              USBD_CDC4_NCM_Uninitialize         (void);
Nextern void              USBD_CDC4_NCM_Reset                (void);
Nextern void              USBD_CDC4_NCM_Start                (void);
Nextern void              USBD_CDC4_NCM_Stop                 (void);
Nextern bool              USBD_CDC4_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Xextern _Bool              USBD_CDC4_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Nextern bool              USBD_CDC4_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Xextern _Bool              USBD_CDC4_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Nextern bool              USBD_CDC4_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Xextern _Bool              USBD_CDC4_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Nextern bool              USBD_CDC4_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Xextern _Bool              USBD_CDC4_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Nextern bool              USBD_CDC4_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Xextern _Bool              USBD_CDC4_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Nextern bool              USBD_CDC4_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Xextern _Bool              USBD_CDC4_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Nextern bool              USBD_CDC4_NCM_GetNetAddress        (uint8_t *net_addr);
Xextern _Bool              USBD_CDC4_NCM_GetNetAddress        (uint8_t *net_addr);
Nextern bool              USBD_CDC4_NCM_SetNetAddress        (const uint8_t *net_addr);
Xextern _Bool              USBD_CDC4_NCM_SetNetAddress        (const uint8_t *net_addr);
Nextern bool              USBD_CDC4_NCM_GetNtbFormat         (uint16_t *ntb_format);
Xextern _Bool              USBD_CDC4_NCM_GetNtbFormat         (uint16_t *ntb_format);
Nextern bool              USBD_CDC4_NCM_SetNtbFormat         (uint16_t  ntb_format);
Xextern _Bool              USBD_CDC4_NCM_SetNtbFormat         (uint16_t  ntb_format);
Nextern bool              USBD_CDC4_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Xextern _Bool              USBD_CDC4_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Nextern bool              USBD_CDC4_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Xextern _Bool              USBD_CDC4_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Nextern bool              USBD_CDC4_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Xextern _Bool              USBD_CDC4_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Nextern bool              USBD_CDC4_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Xextern _Bool              USBD_CDC4_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Nextern bool              USBD_CDC4_NCM_GetCrcMode           (uint16_t *crc_mode);
Xextern _Bool              USBD_CDC4_NCM_GetCrcMode           (uint16_t *crc_mode);
Nextern bool              USBD_CDC4_NCM_SetCrcMode           (uint16_t  crc_mode);
Xextern _Bool              USBD_CDC4_NCM_SetCrcMode           (uint16_t  crc_mode);
Nextern void              USBD_CDC4_NCM_NTB_IN_Sent          (void);
Nextern void              USBD_CDC4_NCM_NTB_OUT_Received     (void);
N 
Nextern void              USBD_CDC5_ACM_Initialize           (void);
Nextern void              USBD_CDC5_ACM_Uninitialize         (void);
Nextern void              USBD_CDC5_ACM_Reset                (void);
Nextern bool              USBD_CDC5_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Xextern _Bool              USBD_CDC5_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Nextern bool              USBD_CDC5_ACM_SetControlLineState  (uint16_t state);
Xextern _Bool              USBD_CDC5_ACM_SetControlLineState  (uint16_t state);
Nextern void              USBD_CDC5_ACM_DataReceived         (uint32_t len);
Nextern void              USBD_CDC5_ACM_DataSent             (void);
Nextern void              USBD_CDC5_NCM_Initialize           (void);
Nextern void              USBD_CDC5_NCM_Uninitialize         (void);
Nextern void              USBD_CDC5_NCM_Reset                (void);
Nextern void              USBD_CDC5_NCM_Start                (void);
Nextern void              USBD_CDC5_NCM_Stop                 (void);
Nextern bool              USBD_CDC5_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Xextern _Bool              USBD_CDC5_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Nextern bool              USBD_CDC5_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Xextern _Bool              USBD_CDC5_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Nextern bool              USBD_CDC5_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Xextern _Bool              USBD_CDC5_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Nextern bool              USBD_CDC5_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Xextern _Bool              USBD_CDC5_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Nextern bool              USBD_CDC5_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Xextern _Bool              USBD_CDC5_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Nextern bool              USBD_CDC5_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Xextern _Bool              USBD_CDC5_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Nextern bool              USBD_CDC5_NCM_GetNetAddress        (uint8_t *net_addr);
Xextern _Bool              USBD_CDC5_NCM_GetNetAddress        (uint8_t *net_addr);
Nextern bool              USBD_CDC5_NCM_SetNetAddress        (const uint8_t *net_addr);
Xextern _Bool              USBD_CDC5_NCM_SetNetAddress        (const uint8_t *net_addr);
Nextern bool              USBD_CDC5_NCM_GetNtbFormat         (uint16_t *ntb_format);
Xextern _Bool              USBD_CDC5_NCM_GetNtbFormat         (uint16_t *ntb_format);
Nextern bool              USBD_CDC5_NCM_SetNtbFormat         (uint16_t  ntb_format);
Xextern _Bool              USBD_CDC5_NCM_SetNtbFormat         (uint16_t  ntb_format);
Nextern bool              USBD_CDC5_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Xextern _Bool              USBD_CDC5_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Nextern bool              USBD_CDC5_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Xextern _Bool              USBD_CDC5_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Nextern bool              USBD_CDC5_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Xextern _Bool              USBD_CDC5_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Nextern bool              USBD_CDC5_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Xextern _Bool              USBD_CDC5_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Nextern bool              USBD_CDC5_NCM_GetCrcMode           (uint16_t *crc_mode);
Xextern _Bool              USBD_CDC5_NCM_GetCrcMode           (uint16_t *crc_mode);
Nextern bool              USBD_CDC5_NCM_SetCrcMode           (uint16_t  crc_mode);
Xextern _Bool              USBD_CDC5_NCM_SetCrcMode           (uint16_t  crc_mode);
Nextern void              USBD_CDC5_NCM_NTB_IN_Sent          (void);
Nextern void              USBD_CDC5_NCM_NTB_OUT_Received     (void);
N 
Nextern void              USBD_CDC6_ACM_Initialize           (void);
Nextern void              USBD_CDC6_ACM_Uninitialize         (void);
Nextern void              USBD_CDC6_ACM_Reset                (void);
Nextern bool              USBD_CDC6_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Xextern _Bool              USBD_CDC6_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Nextern bool              USBD_CDC6_ACM_SetControlLineState  (uint16_t state);
Xextern _Bool              USBD_CDC6_ACM_SetControlLineState  (uint16_t state);
Nextern void              USBD_CDC6_ACM_DataReceived         (uint32_t len);
Nextern void              USBD_CDC6_ACM_DataSent             (void);
Nextern void              USBD_CDC6_NCM_Initialize           (void);
Nextern void              USBD_CDC6_NCM_Uninitialize         (void);
Nextern void              USBD_CDC6_NCM_Reset                (void);
Nextern void              USBD_CDC6_NCM_Start                (void);
Nextern void              USBD_CDC6_NCM_Stop                 (void);
Nextern bool              USBD_CDC6_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Xextern _Bool              USBD_CDC6_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Nextern bool              USBD_CDC6_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Xextern _Bool              USBD_CDC6_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Nextern bool              USBD_CDC6_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Xextern _Bool              USBD_CDC6_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Nextern bool              USBD_CDC6_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Xextern _Bool              USBD_CDC6_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Nextern bool              USBD_CDC6_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Xextern _Bool              USBD_CDC6_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Nextern bool              USBD_CDC6_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Xextern _Bool              USBD_CDC6_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Nextern bool              USBD_CDC6_NCM_GetNetAddress        (uint8_t *net_addr);
Xextern _Bool              USBD_CDC6_NCM_GetNetAddress        (uint8_t *net_addr);
Nextern bool              USBD_CDC6_NCM_SetNetAddress        (const uint8_t *net_addr);
Xextern _Bool              USBD_CDC6_NCM_SetNetAddress        (const uint8_t *net_addr);
Nextern bool              USBD_CDC6_NCM_GetNtbFormat         (uint16_t *ntb_format);
Xextern _Bool              USBD_CDC6_NCM_GetNtbFormat         (uint16_t *ntb_format);
Nextern bool              USBD_CDC6_NCM_SetNtbFormat         (uint16_t  ntb_format);
Xextern _Bool              USBD_CDC6_NCM_SetNtbFormat         (uint16_t  ntb_format);
Nextern bool              USBD_CDC6_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Xextern _Bool              USBD_CDC6_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Nextern bool              USBD_CDC6_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Xextern _Bool              USBD_CDC6_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Nextern bool              USBD_CDC6_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Xextern _Bool              USBD_CDC6_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Nextern bool              USBD_CDC6_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Xextern _Bool              USBD_CDC6_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Nextern bool              USBD_CDC6_NCM_GetCrcMode           (uint16_t *crc_mode);
Xextern _Bool              USBD_CDC6_NCM_GetCrcMode           (uint16_t *crc_mode);
Nextern bool              USBD_CDC6_NCM_SetCrcMode           (uint16_t  crc_mode);
Xextern _Bool              USBD_CDC6_NCM_SetCrcMode           (uint16_t  crc_mode);
Nextern void              USBD_CDC6_NCM_NTB_IN_Sent          (void);
Nextern void              USBD_CDC6_NCM_NTB_OUT_Received     (void);
N 
Nextern void              USBD_CDC7_ACM_Initialize           (void);
Nextern void              USBD_CDC7_ACM_Uninitialize         (void);
Nextern void              USBD_CDC7_ACM_Reset                (void);
Nextern bool              USBD_CDC7_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Xextern _Bool              USBD_CDC7_ACM_GetLineCoding        (      CDC_LINE_CODING *line_coding);
Nextern bool              USBD_CDC7_ACM_SetControlLineState  (uint16_t state);
Xextern _Bool              USBD_CDC7_ACM_SetControlLineState  (uint16_t state);
Nextern void              USBD_CDC7_ACM_DataReceived         (uint32_t len);
Nextern void              USBD_CDC7_ACM_DataSent             (void);
Nextern void              USBD_CDC7_NCM_Initialize           (void);
Nextern void              USBD_CDC7_NCM_Uninitialize         (void);
Nextern void              USBD_CDC7_NCM_Reset                (void);
Nextern void              USBD_CDC7_NCM_Start                (void);
Nextern void              USBD_CDC7_NCM_Stop                 (void);
Nextern bool              USBD_CDC7_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Xextern _Bool              USBD_CDC7_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters);
Nextern bool              USBD_CDC7_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Xextern _Bool              USBD_CDC7_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
Nextern bool              USBD_CDC7_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Xextern _Bool              USBD_CDC7_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
Nextern bool              USBD_CDC7_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Xextern _Bool              USBD_CDC7_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap);
Nextern bool              USBD_CDC7_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Xextern _Bool              USBD_CDC7_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data);
Nextern bool              USBD_CDC7_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Xextern _Bool              USBD_CDC7_NCM_GetNtbParameters                        (CDC_NCM_NTB_PARAM *ntb_params);
Nextern bool              USBD_CDC7_NCM_GetNetAddress        (uint8_t *net_addr);
Xextern _Bool              USBD_CDC7_NCM_GetNetAddress        (uint8_t *net_addr);
Nextern bool              USBD_CDC7_NCM_SetNetAddress        (const uint8_t *net_addr);
Xextern _Bool              USBD_CDC7_NCM_SetNetAddress        (const uint8_t *net_addr);
Nextern bool              USBD_CDC7_NCM_GetNtbFormat         (uint16_t *ntb_format);
Xextern _Bool              USBD_CDC7_NCM_GetNtbFormat         (uint16_t *ntb_format);
Nextern bool              USBD_CDC7_NCM_SetNtbFormat         (uint16_t  ntb_format);
Xextern _Bool              USBD_CDC7_NCM_SetNtbFormat         (uint16_t  ntb_format);
Nextern bool              USBD_CDC7_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Xextern _Bool              USBD_CDC7_NCM_GetNtbInputSize      (uint32_t *ntb_input_size);
Nextern bool              USBD_CDC7_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Xextern _Bool              USBD_CDC7_NCM_SetNtbInputSize      (uint32_t  ntb_input_size);
Nextern bool              USBD_CDC7_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Xextern _Bool              USBD_CDC7_NCM_GetMaxDatagramSize   (uint16_t *max_datagram_size);
Nextern bool              USBD_CDC7_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Xextern _Bool              USBD_CDC7_NCM_SetMaxDatagramSize   (uint16_t  max_datagram_size);
Nextern bool              USBD_CDC7_NCM_GetCrcMode           (uint16_t *crc_mode);
Xextern _Bool              USBD_CDC7_NCM_GetCrcMode           (uint16_t *crc_mode);
Nextern bool              USBD_CDC7_NCM_SetCrcMode           (uint16_t  crc_mode);
Xextern _Bool              USBD_CDC7_NCM_SetCrcMode           (uint16_t  crc_mode);
Nextern void              USBD_CDC7_NCM_NTB_IN_Sent          (void);
Nextern void              USBD_CDC7_NCM_NTB_OUT_Received     (void);
N 
Nextern void              USBD_HID0_Initialize               (void);
Nextern void              USBD_HID0_Uninitialize             (void);
Nextern int32_t           USBD_HID0_GetReport                (uint8_t rtype, uint8_t req, uint8_t rid,       uint8_t *buf);
Nextern bool              USBD_HID0_SetReport                (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
Xextern _Bool              USBD_HID0_SetReport                (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
N 
Nextern void              USBD_HID1_Initialize               (void);
Nextern void              USBD_HID1_Uninitialize             (void);
Nextern int32_t           USBD_HID1_GetReport                (uint8_t rtype, uint8_t req, uint8_t rid,       uint8_t *buf);
Nextern bool              USBD_HID1_SetReport                (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
Xextern _Bool              USBD_HID1_SetReport                (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
N 
Nextern void              USBD_HID2_Initialize               (void);
Nextern void              USBD_HID2_Uninitialize             (void);
Nextern int32_t           USBD_HID2_GetReport                (uint8_t rtype, uint8_t req, uint8_t rid,       uint8_t *buf);
Nextern bool              USBD_HID2_SetReport                (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
Xextern _Bool              USBD_HID2_SetReport                (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
N 
Nextern void              USBD_HID3_Initialize               (void);
Nextern void              USBD_HID3_Uninitialize             (void);
Nextern int32_t           USBD_HID3_GetReport                (uint8_t rtype, uint8_t req, uint8_t rid,       uint8_t *buf);
Nextern bool              USBD_HID3_SetReport                (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
Xextern _Bool              USBD_HID3_SetReport                (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len);
N 
Nextern void              USBD_MSC0_Initialize               (void);
Nextern void              USBD_MSC0_Uninitialize             (void);
Nextern bool              USBD_MSC0_GetCacheInfo             (uint32_t *buffer, uint32_t *size);
Xextern _Bool              USBD_MSC0_GetCacheInfo             (uint32_t *buffer, uint32_t *size);
Nextern bool              USBD_MSC0_GetMediaCapacity         (uint32_t *block_count, uint32_t *block_size);
Xextern _Bool              USBD_MSC0_GetMediaCapacity         (uint32_t *block_count, uint32_t *block_size);
Nextern bool              USBD_MSC0_StartStop                (bool start);
Xextern _Bool              USBD_MSC0_StartStop                (_Bool start);
Nextern uint32_t          USBD_MSC0_CheckMedia               (void);
Nextern uint8_t           USBD_MSC0_GetMaxLUN                (void);
Nextern bool              USBD_MSC0_LUN_GetMediaCapacity     (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
Xextern _Bool              USBD_MSC0_LUN_GetMediaCapacity     (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
Nextern bool              USBD_MSC0_LUN_Read                 (uint8_t lun, uint32_t lba, uint32_t cnt,       uint8_t *buf);
Xextern _Bool              USBD_MSC0_LUN_Read                 (uint8_t lun, uint32_t lba, uint32_t cnt,       uint8_t *buf);
Nextern bool              USBD_MSC0_LUN_Write                (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
Xextern _Bool              USBD_MSC0_LUN_Write                (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
Nextern bool              USBD_MSC0_LUN_StartStop            (uint8_t lun, bool start);
Xextern _Bool              USBD_MSC0_LUN_StartStop            (uint8_t lun, _Bool start);
Nextern uint32_t          USBD_MSC0_LUN_CheckMedia           (uint8_t lun);
N 
Nextern void              USBD_MSC1_Initialize               (void);
Nextern void              USBD_MSC1_Uninitialize             (void);
Nextern bool              USBD_MSC1_GetCacheInfo             (uint32_t *buffer, uint32_t *size);
Xextern _Bool              USBD_MSC1_GetCacheInfo             (uint32_t *buffer, uint32_t *size);
Nextern bool              USBD_MSC1_GetMediaCapacity         (uint32_t *block_count, uint32_t *block_size);
Xextern _Bool              USBD_MSC1_GetMediaCapacity         (uint32_t *block_count, uint32_t *block_size);
Nextern bool              USBD_MSC1_StartStop                (bool start);
Xextern _Bool              USBD_MSC1_StartStop                (_Bool start);
Nextern uint32_t          USBD_MSC1_CheckMedia               (void);
Nextern uint8_t           USBD_MSC1_GetMaxLUN                (void);
Nextern bool              USBD_MSC1_LUN_GetMediaCapacity     (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
Xextern _Bool              USBD_MSC1_LUN_GetMediaCapacity     (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
Nextern bool              USBD_MSC1_LUN_Read                 (uint8_t lun, uint32_t lba, uint32_t cnt,       uint8_t *buf);
Xextern _Bool              USBD_MSC1_LUN_Read                 (uint8_t lun, uint32_t lba, uint32_t cnt,       uint8_t *buf);
Nextern bool              USBD_MSC1_LUN_Write                (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
Xextern _Bool              USBD_MSC1_LUN_Write                (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
Nextern bool              USBD_MSC1_LUN_StartStop            (uint8_t lun, bool start);
Xextern _Bool              USBD_MSC1_LUN_StartStop            (uint8_t lun, _Bool start);
Nextern uint32_t          USBD_MSC1_LUN_CheckMedia           (uint8_t lun);
N 
Nextern void              USBD_MSC2_Initialize               (void);
Nextern void              USBD_MSC2_Uninitialize             (void);
Nextern bool              USBD_MSC2_GetCacheInfo             (uint32_t *buffer, uint32_t *size);
Xextern _Bool              USBD_MSC2_GetCacheInfo             (uint32_t *buffer, uint32_t *size);
Nextern bool              USBD_MSC2_GetMediaCapacity         (uint32_t *block_count, uint32_t *block_size);
Xextern _Bool              USBD_MSC2_GetMediaCapacity         (uint32_t *block_count, uint32_t *block_size);
Nextern bool              USBD_MSC2_StartStop                (bool start);
Xextern _Bool              USBD_MSC2_StartStop                (_Bool start);
Nextern uint32_t          USBD_MSC2_CheckMedia               (void);
Nextern uint8_t           USBD_MSC2_GetMaxLUN                (void);
Nextern bool              USBD_MSC2_LUN_GetMediaCapacity     (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
Xextern _Bool              USBD_MSC2_LUN_GetMediaCapacity     (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
Nextern bool              USBD_MSC2_LUN_Read                 (uint8_t lun, uint32_t lba, uint32_t cnt,       uint8_t *buf);
Xextern _Bool              USBD_MSC2_LUN_Read                 (uint8_t lun, uint32_t lba, uint32_t cnt,       uint8_t *buf);
Nextern bool              USBD_MSC2_LUN_Write                (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
Xextern _Bool              USBD_MSC2_LUN_Write                (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
Nextern bool              USBD_MSC2_LUN_StartStop            (uint8_t lun, bool start);
Xextern _Bool              USBD_MSC2_LUN_StartStop            (uint8_t lun, _Bool start);
Nextern uint32_t          USBD_MSC2_LUN_CheckMedia           (uint8_t lun);
N 
Nextern void              USBD_MSC3_Initialize               (void);
Nextern void              USBD_MSC3_Uninitialize             (void);
Nextern bool              USBD_MSC3_GetCacheInfo             (uint32_t *buffer, uint32_t *size);
Xextern _Bool              USBD_MSC3_GetCacheInfo             (uint32_t *buffer, uint32_t *size);
Nextern bool              USBD_MSC3_GetMediaCapacity         (uint32_t *block_count, uint32_t *block_size);
Xextern _Bool              USBD_MSC3_GetMediaCapacity         (uint32_t *block_count, uint32_t *block_size);
Nextern bool              USBD_MSC3_StartStop                (bool start);
Xextern _Bool              USBD_MSC3_StartStop                (_Bool start);
Nextern uint32_t          USBD_MSC3_CheckMedia               (void);
Nextern uint8_t           USBD_MSC3_GetMaxLUN                (void);
Nextern bool              USBD_MSC3_LUN_GetMediaCapacity     (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
Xextern _Bool              USBD_MSC3_LUN_GetMediaCapacity     (uint8_t lun, uint32_t *block_count, uint32_t *block_size);
Nextern bool              USBD_MSC3_LUN_Read                 (uint8_t lun, uint32_t lba, uint32_t cnt,       uint8_t *buf);
Xextern _Bool              USBD_MSC3_LUN_Read                 (uint8_t lun, uint32_t lba, uint32_t cnt,       uint8_t *buf);
Nextern bool              USBD_MSC3_LUN_Write                (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
Xextern _Bool              USBD_MSC3_LUN_Write                (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf);
Nextern bool              USBD_MSC3_LUN_StartStop            (uint8_t lun, bool start);
Xextern _Bool              USBD_MSC3_LUN_StartStop            (uint8_t lun, _Bool start);
Nextern uint32_t          USBD_MSC3_LUN_CheckMedia           (uint8_t lun);
N 
Nextern void              USBD_CustomClass0_Initialize       (void);
Nextern void              USBD_CustomClass0_Uninitialize     (void);
Nextern void              USBD_CustomClass0_Reset            (void);
Nextern void              USBD_CustomClass0_EndpointStart    (uint8_t ep_addr);
Nextern void              USBD_CustomClass0_EndpointStop     (uint8_t ep_addr);
Nextern usbdRequestStatus USBD_CustomClass0_Endpoint0_SetupPacketReceived  (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
Nextern void              USBD_CustomClass0_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
Nextern usbdRequestStatus USBD_CustomClass0_Endpoint0_OutDataReceived      (uint32_t len);
Nextern usbdRequestStatus USBD_CustomClass0_Endpoint0_InDataSent           (uint32_t len);
Nextern void              USBD_CustomClass0_Endpoint1_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint2_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint3_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint4_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint5_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint6_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint7_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint8_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint9_Event  (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint10_Event (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint11_Event (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint12_Event (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint13_Event (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint14_Event (uint32_t event);
Nextern void              USBD_CustomClass0_Endpoint15_Event (uint32_t event);
N 
Nextern void              USBD_CustomClass1_Initialize       (void);
Nextern void              USBD_CustomClass1_Uninitialize     (void);
Nextern void              USBD_CustomClass1_Reset            (void);
Nextern void              USBD_CustomClass1_EndpointStart    (uint8_t ep_addr);
Nextern void              USBD_CustomClass1_EndpointStop     (uint8_t ep_addr);
Nextern usbdRequestStatus USBD_CustomClass1_Endpoint0_SetupPacketReceived  (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
Nextern void              USBD_CustomClass1_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
Nextern usbdRequestStatus USBD_CustomClass1_Endpoint0_OutDataReceived      (uint32_t len);
Nextern usbdRequestStatus USBD_CustomClass1_Endpoint0_InDataSent           (uint32_t len);
Nextern void              USBD_CustomClass1_Endpoint1_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint2_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint3_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint4_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint5_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint6_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint7_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint8_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint9_Event  (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint10_Event (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint11_Event (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint12_Event (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint13_Event (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint14_Event (uint32_t event);
Nextern void              USBD_CustomClass1_Endpoint15_Event (uint32_t event);
N 
Nextern void              USBD_CustomClass2_Initialize       (void);
Nextern void              USBD_CustomClass2_Uninitialize     (void);
Nextern void              USBD_CustomClass2_Reset            (void);
Nextern void              USBD_CustomClass2_EndpointStart    (uint8_t ep_addr);
Nextern void              USBD_CustomClass2_EndpointStop     (uint8_t ep_addr);
Nextern usbdRequestStatus USBD_CustomClass2_Endpoint0_SetupPacketReceived  (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
Nextern void              USBD_CustomClass2_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
Nextern usbdRequestStatus USBD_CustomClass2_Endpoint0_OutDataReceived      (uint32_t len);
Nextern usbdRequestStatus USBD_CustomClass2_Endpoint0_InDataSent           (uint32_t len);
Nextern void              USBD_CustomClass2_Endpoint1_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint2_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint3_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint4_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint5_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint6_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint7_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint8_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint9_Event  (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint10_Event (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint11_Event (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint12_Event (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint13_Event (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint14_Event (uint32_t event);
Nextern void              USBD_CustomClass2_Endpoint15_Event (uint32_t event);
N 
Nextern void              USBD_CustomClass3_Initialize       (void);
Nextern void              USBD_CustomClass3_Uninitialize     (void);
Nextern void              USBD_CustomClass3_Reset            (void);
Nextern void              USBD_CustomClass3_EndpointStart    (uint8_t ep_addr);
Nextern void              USBD_CustomClass3_EndpointStop     (uint8_t ep_addr);
Nextern usbdRequestStatus USBD_CustomClass3_Endpoint0_SetupPacketReceived  (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
Nextern void              USBD_CustomClass3_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
Nextern usbdRequestStatus USBD_CustomClass3_Endpoint0_OutDataReceived      (uint32_t len);
Nextern usbdRequestStatus USBD_CustomClass3_Endpoint0_InDataSent           (uint32_t len);
Nextern void              USBD_CustomClass3_Endpoint1_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint2_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint3_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint4_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint5_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint6_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint7_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint8_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint9_Event  (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint10_Event (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint11_Event (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint12_Event (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint13_Event (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint14_Event (uint32_t event);
Nextern void              USBD_CustomClass3_Endpoint15_Event (uint32_t event);
N
N
N// USB Device library function prototypes for configuration generation
Nextern usbStatus         USBD_CustomClass_Initialize        (uint8_t instance);
Nextern usbStatus         USBD_CustomClass_Uninitialize      (uint8_t instance);
Nextern void              USBD_CustomClass_Reset             (uint8_t instance);
Nextern void              USBD_CustomClass_EndpointStart     (uint8_t instance, uint8_t ep_addr);
Nextern void              USBD_CustomClass_EndpointStop      (uint8_t instance, uint8_t ep_addr);
N
Nextern usbStatus         USBD_ADC_Initialize                (uint8_t instance);
Nextern usbStatus         USBD_ADC_Uninitialize              (uint8_t instance);
Nextern void              USBD_ADC_Reset                     (uint8_t instance);
Nextern void              USBD_ADC_EndpointStart             (uint8_t instance, uint8_t ep_addr);
Nextern void              USBD_ADC_EndpointStop              (uint8_t instance, uint8_t ep_addr);
N
Nextern usbStatus         USBD_CDC_Initialize                (uint8_t instance);
Nextern usbStatus         USBD_CDC_Uninitialize              (uint8_t instance);
Nextern void              USBD_CDC_Reset                     (uint8_t instance);
Nextern void              USBD_CDC_EndpointStart             (uint8_t instance, uint8_t ep_addr);
Nextern void              USBD_CDC_EndpointStop              (uint8_t instance, uint8_t ep_addr);
N
Nextern usbStatus         USBD_HID_Initialize                (uint8_t instance);
Nextern usbStatus         USBD_HID_Uninitialize              (uint8_t instance);
Nextern void              USBD_HID_Reset                     (uint8_t instance);
Nextern void              USBD_HID_SetConfiguration          (uint8_t instance);
Nextern void              USBD_HID_EndpointStart             (uint8_t instance, uint8_t ep_addr);
Nextern void              USBD_HID_Timer                     (void const *argument);
N
N
Nextern usbStatus         USBD_MSC_Initialize                (uint8_t instance);
Nextern usbStatus         USBD_MSC_Uninitialize              (uint8_t instance);
Nextern void              USBD_MSC_Reset                     (uint8_t instance);
Nextern void              USBD_MSC_EndpointStart             (uint8_t instance, uint8_t ep_addr);
N
N
N// USB Device library configuration generated function prototypes
Nextern void              USBD_Debug_Initialize              (uint8_t device);
N
Nextern usbStatus         USBD_ClassInitialize               (uint8_t device);
Nextern usbStatus         USBD_ClassUninitialize             (uint8_t device);
Nextern void              USBD_Reset                         (uint8_t device);
Nextern void              USBD_SetConfiguration              (uint8_t device, uint8_t configuration);
Nextern void              USBD_EndpointStart                 (uint8_t device, uint8_t ep_addr);
Nextern void              USBD_EndpointStop                  (uint8_t device, uint8_t ep_addr);
N
N
N// USB Device thread function prototypes
Nextern void              USBD_Core_Thread                   (void       *arg);
Nextern void              USBD0_Core_Thread                  (void const *arg);
Nextern void              USBD1_Core_Thread                  (void const *arg);
Nextern void              USBD2_Core_Thread                  (void const *arg);
Nextern void              USBD3_Core_Thread                  (void const *arg);
N
Nextern void              USBD_ADC_Thread                    (void       *arg);
Nextern void              USBD_ADC0_Thread                   (void const *arg);
Nextern void              USBD_ADC1_Thread                   (void const *arg);
Nextern void              USBD_ADC2_Thread                   (void const *arg);
Nextern void              USBD_ADC3_Thread                   (void const *arg);
N
Nextern void              USBD_CDC_Int_Thread                (void       *arg);
Nextern void              USBD_CDC0_Int_Thread               (void const *arg);
Nextern void              USBD_CDC1_Int_Thread               (void const *arg);
Nextern void              USBD_CDC2_Int_Thread               (void const *arg);
Nextern void              USBD_CDC3_Int_Thread               (void const *arg);
Nextern void              USBD_CDC4_Int_Thread               (void const *arg);
Nextern void              USBD_CDC5_Int_Thread               (void const *arg);
Nextern void              USBD_CDC6_Int_Thread               (void const *arg);
Nextern void              USBD_CDC7_Int_Thread               (void const *arg);
N
Nextern void              USBD_CDC_Bulk_Thread               (void       *arg);
Nextern void              USBD_CDC0_Bulk_Thread              (void const *arg);
Nextern void              USBD_CDC1_Bulk_Thread              (void const *arg);
Nextern void              USBD_CDC2_Bulk_Thread              (void const *arg);
Nextern void              USBD_CDC3_Bulk_Thread              (void const *arg);
Nextern void              USBD_CDC4_Bulk_Thread              (void const *arg);
Nextern void              USBD_CDC5_Bulk_Thread              (void const *arg);
Nextern void              USBD_CDC6_Bulk_Thread              (void const *arg);
Nextern void              USBD_CDC7_Bulk_Thread              (void const *arg);
N
Nextern void              USBD_HID_Thread                    (void       *arg);
Nextern void              USBD_HID0_Thread                   (void const *arg);
Nextern void              USBD_HID1_Thread                   (void const *arg);
Nextern void              USBD_HID2_Thread                   (void const *arg);
Nextern void              USBD_HID3_Thread                   (void const *arg);
N
Nextern void              USBD_MSC_Thread                    (void       *arg);
Nextern void              USBD_MSC0_Thread                   (void const *arg);
Nextern void              USBD_MSC1_Thread                   (void const *arg);
Nextern void              USBD_MSC2_Thread                   (void const *arg);
Nextern void              USBD_MSC3_Thread                   (void const *arg);
N
Nextern void              USBD_CustomClass_EP_Thread         (void       *arg);
N
N// USB Host OS abstraction functions
Nextern void             *USBH_ThreadCreate                  (usbhThread_t thread, uint8_t index);
Nextern void             *USBH_ThreadGetHandle               (void);
Nextern int32_t           USBH_ThreadTerminate               (void *thread_hndl);
N
Nextern int32_t           USBH_Delay                         (uint32_t millisec);
N
Nextern void             *USBH_TimerCreate                   (uint8_t ctrl);
Nextern int32_t           USBH_TimerStart                    (void *timer_hndl, uint32_t millisec);
Nextern int32_t           USBH_TimerStop                     (void *timer_hndl);
Nextern int32_t           USBH_TimerDelete                   (void *timer_hndl);
N
Nextern uint32_t          USBH_ThreadFlagsSet                (void *thread_hndl, uint32_t flags);
Nextern uint32_t          USBH_ThreadFlagsWait               (uint32_t millisec);
N
Nextern void             *USBH_MutexCreate                   (usbhMutex_t mutex, uint8_t ctrl);
Nextern int32_t           USBH_MutexAcquire                  (void *mutex_hndl, uint32_t millisec);
Nextern int32_t           USBH_MutexRelease                  (void *mutex_hndl);
Nextern int32_t           USBH_MutexDelete                   (void *mutex_hndl);
N
Nextern void             *USBH_SemaphoreCreate               (usbhSemaphore_t semaphore, uint8_t ctrl);
Nextern int32_t           USBH_SemaphoreAcquire              (void *semaphore_hndl, uint32_t millisec);
Nextern int32_t           USBH_SemaphoreRelease              (void *semaphore_hndl);
Nextern int32_t           USBH_SemaphoreDelete               (void *semaphore_hndl);
N
N// USB Host library function prototypes
Nextern void              USBH_Debug_Initialize              (uint8_t ctrl);
N
Nextern uint8_t           USBH_CDC_Configure                 (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc);
Nextern usbStatus         USBH_CDC_Unconfigure               (uint8_t instance);
Nextern usbStatus         USBH_CDC_Initialize_Lib            (uint8_t instance);
Nextern usbStatus         USBH_CDC_Uninitialize_Lib          (uint8_t instance);
N
Nextern uint8_t           USBH_HID_Configure                 (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc);
Nextern usbStatus         USBH_HID_Unconfigure               (uint8_t instance);
Nextern usbStatus         USBH_HID_Initialize_Lib            (uint8_t instance);
Nextern usbStatus         USBH_HID_Uninitialize_Lib          (uint8_t instance);
N
Nextern uint8_t           USBH_MSC_Configure                 (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc);
Nextern usbStatus         USBH_MSC_Unconfigure               (uint8_t instance);
Nextern usbStatus         USBH_MSC_Initialize_Lib            (uint8_t instance);
Nextern usbStatus         USBH_MSC_Uninitialize_Lib          (uint8_t instance);
N
Nextern uint8_t           USBH_CustomClass_Configure         (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc);
Nextern usbStatus         USBH_CustomClass_Unconfigure       (uint8_t instance);
Nextern usbStatus         USBH_CustomClass_Initialize        (uint8_t instance);
Nextern usbStatus         USBH_CustomClass_Uninitialize      (uint8_t instance);
N
N// USB Host thread function prototypes
Nextern void              USBH_Core_Thread                   (void       *arg);
Nextern void              USBH0_Core_Thread                  (void const *arg);
Nextern void              USBH1_Core_Thread                  (void const *arg);
Nextern void              USBH2_Core_Thread                  (void const *arg);
Nextern void              USBH3_Core_Thread                  (void const *arg);
N
Nextern void              USBH_CDC_IntIn_Thread              (void       *arg);
N
Nextern void              USBH_HID_IntIn_Thread              (void       *arg);
N
N// USB Host timer function prototypes
Nextern void              USBH_ConnectDebounce               (void const *arg);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 16 "USBD_User_CDC_ACM_0.c" 2
N 
N// Local Variables
Nstatic   CDC_LINE_CODING        cdc_acm_line_coding = { 0U, 0U, 0U, 0U };
N 
N 
N// Called during USBD_Initialize to initialize the USB CDC class instance (ACM).
Nvoid USBD_CDC0_ACM_Initialize (void) {
N  // Add code for initialization
N	
N	printf("USB init\n");
N	
N}
N 
N 
N// Called during USBD_Uninitialize to de-initialize the USB CDC class instance (ACM).
Nvoid USBD_CDC0_ACM_Uninitialize (void) {
N  // Add code for de-initialization
N	printf("USB deinit\n");
N	
N}
N 
N 
N// Called upon USB Bus Reset Event.
Nvoid USBD_CDC0_ACM_Reset (void) {
N  // Add code for reset
N	printf("USB_CDC0_ACM_RESET\n");
N}
N 
N 
N// Callback function called upon reception of request send encapsulated command sent by the USB Host.
N// \param[in]   buf           buffer that contains send encapsulated command request.
N// \param[in]   len           length of send encapsulated command request.
N// \return      true          send encapsulated command request processed.
N// \return      false         send encapsulated command request not supported or not processed.
Nbool USBD_CDC0_ACM_SendEncapsulatedCommand (const uint8_t *buf, uint16_t len) {
X_Bool USBD_CDC0_ACM_SendEncapsulatedCommand (const uint8_t *buf, uint16_t len) {
N	printf("USB send Encapsulation Request Command\n");
N  return true;
X  return 1;
N}
N 
N 
N// Callback function called upon reception of request to get encapsulated response sent by the USB Host.
N// \param[in]   max_len       maximum number of data bytes that USB Host expects to receive
N// \param[out]  buf           pointer to buffer containing get encapsulated response to be returned to USB Host.
N// \param[out]  len           pointer to number of data bytes to be returned to USB Host.
N// \return      true          get encapsulated response request processed.
N// \return      false         get encapsulated response request not supported or not processed.
Nbool USBD_CDC0_ACM_GetEncapsulatedResponse (uint16_t max_len, uint8_t **buf, uint16_t *len) {
X_Bool USBD_CDC0_ACM_GetEncapsulatedResponse (uint16_t max_len, uint8_t **buf, uint16_t *len) {
N	printf("USB get encapsulation response\n");
N  return true;
X  return 1;
N}
N 
N 
N// Called upon USB Host request to change communication settings.
N// \param[in]   line_coding   pointer to CDC_LINE_CODING structure.
N// \return      true          set line coding request processed.
N// \return      false         set line coding request not supported or not processed.
Nbool USBD_CDC0_ACM_SetLineCoding (const CDC_LINE_CODING *line_coding) {
X_Bool USBD_CDC0_ACM_SetLineCoding (const CDC_LINE_CODING *line_coding) {
N  // Add code for set line coding
N	printf("---USB Set Line Coding---\n");
N	printf("DTE rate bps\t\t%d\n", line_coding->dwDTERate);
N	printf("No stop bits\t\t%d\n", line_coding->bCharFormat);
N	printf("Parity type \t\t%d\n", line_coding->bParityType);
N	printf("No Data Bits\t\t%d\n", line_coding->bDataBits);
N	
N  // Store requested settings to local variable
N  cdc_acm_line_coding = *line_coding;
N 
N  return true;
X  return 1;
N}
N 
N 
N// Called upon USB Host request to retrieve communication settings.
N// \param[out]  line_coding   pointer to CDC_LINE_CODING structure.
N// \return      true          get line coding request processed.
N// \return      false         get line coding request not supported or not processed.
Nbool USBD_CDC0_ACM_GetLineCoding (CDC_LINE_CODING *line_coding) {
X_Bool USBD_CDC0_ACM_GetLineCoding (CDC_LINE_CODING *line_coding) {
N	
N	printf("USB get line coding\n");
N  // Load settings from ones stored on USBD_CDCn_ACM_SetLineCoding callback
N  *line_coding = cdc_acm_line_coding;
N 
N  return true;
X  return 1;
N}
N 
N 
N// Called upon USB Host request to set control line states.
N// \param [in]  state         control line settings bitmap.
N//                - bit 0: DTR state
N//                - bit 1: RTS state
N// \return      true          set control line state request processed.
N// \return      false         set control line state request not supported or not processed.
Nbool USBD_CDC0_ACM_SetControlLineState (uint16_t state) {
X_Bool USBD_CDC0_ACM_SetControlLineState (uint16_t state) {
N  // Add code for set control line state
N	printf("USB set control line state\n");
N 
N  (void)(state);
N 
N  return true;
X  return 1;
N}
N 
N 
N// Called when new data was received.
N// \param [in]  len           number of bytes available for reading.
Nvoid USBD_CDC0_ACM_DataReceived (uint32_t len) {
N  // Add code for handling new data reception
N	//printf("USB ACM Data Received:%d", len);
N
N	char datain[8]= { 0 };
W "USBD_User_CDC_ACM_0.c" 124 28 argument of type "char *" is incompatible with parameter of type "uint8_t *"
N	USBD_CDC_ACM_ReadData( 0, datain, len );
N	printf( "USB ACM Data Received(%d):%s", len, datain );
N
N}
N 
N 
N// Called when when all data was sent.
Nvoid USBD_CDC0_ACM_DataSent (void) {
N  // Add code for handling new data send
N	printf("USB ACM Data Sent\n");
N}
