; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\spi_stm32f10x.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spi_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTE\Device\STM32F103C8 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Driver\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\RTOS\RTX\INC -IC:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\StdPeriph_Driver\inc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\RTE_Driver -D__RTX -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\objects\spi_stm32f10x.crf C:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\RTE_Driver\SPI_STM32F10x.c]
                          THUMB

                          AREA ||i.SPI1_Control||, CODE, READONLY, ALIGN=2

                  SPI1_Control PROC
;;;1324   static uint32_t       SPI1_GetDataCount        (void)                                              { return SPI_GetDataCount (&SPI1_Resources); }
;;;1325   static int32_t        SPI1_Control             (uint32_t control, uint32_t arg)                    { return SPI_Control (control, arg, &SPI1_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L1.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       SPI_Control
000010  bd70              POP      {r4-r6,pc}
;;;1326   static ARM_SPI_STATUS SPI1_GetStatus           (void)                                              { return SPI_GetStatus (&SPI1_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_GetDataCount||, CODE, READONLY, ALIGN=2

                  SPI1_GetDataCount PROC
;;;1323   static int32_t        SPI1_Transfer            (const void *data_out, void *data_in, uint32_t num) { return SPI_Transfer (data_out, data_in, num, &SPI1_Resources); }
;;;1324   static uint32_t       SPI1_GetDataCount        (void)                                              { return SPI_GetDataCount (&SPI1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L2.12|
000004  f7fffffe          BL       SPI_GetDataCount
000008  bd10              POP      {r4,pc}
;;;1325   static int32_t        SPI1_Control             (uint32_t control, uint32_t arg)                    { return SPI_Control (control, arg, &SPI1_Resources); }
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_GetStatus||, CODE, READONLY, ALIGN=2

                  SPI1_GetStatus PROC
;;;1325   static int32_t        SPI1_Control             (uint32_t control, uint32_t arg)                    { return SPI_Control (control, arg, &SPI1_Resources); }
;;;1326   static ARM_SPI_STATUS SPI1_GetStatus           (void)                                              { return SPI_GetStatus (&SPI1_Resources); }
000000  b508              PUSH     {r3,lr}
000002  4802              LDR      r0,|L3.12|
000004  f7fffffe          BL       SPI_GetStatus
000008  9000              STR      r0,[sp,#0]
00000a  bd08              POP      {r3,pc}
;;;1327          void           SPI1_IRQHandler          (void)                                              {        SPI_IRQHandler (&SPI1_Resources); }
                          ENDP

                  |L3.12|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_IRQHandler||, CODE, READONLY, ALIGN=2

                  SPI1_IRQHandler PROC
;;;1326   static ARM_SPI_STATUS SPI1_GetStatus           (void)                                              { return SPI_GetStatus (&SPI1_Resources); }
;;;1327          void           SPI1_IRQHandler          (void)                                              {        SPI_IRQHandler (&SPI1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L4.12|
000004  f7fffffe          BL       SPI_IRQHandler
000008  bd10              POP      {r4,pc}
;;;1328   
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_Initialize||, CODE, READONLY, ALIGN=2

                  SPI1_Initialize PROC
;;;1317   #ifdef MX_SPI1
;;;1318   static int32_t        SPI1_Initialize          (ARM_SPI_SignalEvent_t pSignalEvent)                { return SPI_Initialize (pSignalEvent, &SPI1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4902              LDR      r1,|L5.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SPI_Initialize
00000c  bd10              POP      {r4,pc}
;;;1319   static int32_t        SPI1_Uninitialize        (void)                                              { return SPI_Uninitialize (&SPI1_Resources); }
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_PowerControl||, CODE, READONLY, ALIGN=2

                  SPI1_PowerControl PROC
;;;1319   static int32_t        SPI1_Uninitialize        (void)                                              { return SPI_Uninitialize (&SPI1_Resources); }
;;;1320   static int32_t        SPI1_PowerControl        (ARM_POWER_STATE state)                             { return SPI_PowerControl (state, &SPI1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4902              LDR      r1,|L6.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SPI_PowerControl
00000c  bd10              POP      {r4,pc}
;;;1321   static int32_t        SPI1_Send                (const void *data, uint32_t num)                    { return SPI_Send (data, num, &SPI1_Resources); }
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_Receive||, CODE, READONLY, ALIGN=2

                  SPI1_Receive PROC
;;;1321   static int32_t        SPI1_Send                (const void *data, uint32_t num)                    { return SPI_Send (data, num, &SPI1_Resources); }
;;;1322   static int32_t        SPI1_Receive             (void *data, uint32_t num)                          { return SPI_Receive (data, num, &SPI1_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L7.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       SPI_Receive
000010  bd70              POP      {r4-r6,pc}
;;;1323   static int32_t        SPI1_Transfer            (const void *data_out, void *data_in, uint32_t num) { return SPI_Transfer (data_out, data_in, num, &SPI1_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_Send||, CODE, READONLY, ALIGN=2

                  SPI1_Send PROC
;;;1320   static int32_t        SPI1_PowerControl        (ARM_POWER_STATE state)                             { return SPI_PowerControl (state, &SPI1_Resources); }
;;;1321   static int32_t        SPI1_Send                (const void *data, uint32_t num)                    { return SPI_Send (data, num, &SPI1_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L8.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       SPI_Send
000010  bd70              POP      {r4-r6,pc}
;;;1322   static int32_t        SPI1_Receive             (void *data, uint32_t num)                          { return SPI_Receive (data, num, &SPI1_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_Transfer||, CODE, READONLY, ALIGN=2

                  SPI1_Transfer PROC
;;;1322   static int32_t        SPI1_Receive             (void *data, uint32_t num)                          { return SPI_Receive (data, num, &SPI1_Resources); }
;;;1323   static int32_t        SPI1_Transfer            (const void *data_out, void *data_in, uint32_t num) { return SPI_Transfer (data_out, data_in, num, &SPI1_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  4b03              LDR      r3,|L9.24|
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SPI_Transfer
000014  bd70              POP      {r4-r6,pc}
;;;1324   static uint32_t       SPI1_GetDataCount        (void)                                              { return SPI_GetDataCount (&SPI1_Resources); }
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      SPI1_Resources

                          AREA ||i.SPI1_Uninitialize||, CODE, READONLY, ALIGN=2

                  SPI1_Uninitialize PROC
;;;1318   static int32_t        SPI1_Initialize          (ARM_SPI_SignalEvent_t pSignalEvent)                { return SPI_Initialize (pSignalEvent, &SPI1_Resources); }
;;;1319   static int32_t        SPI1_Uninitialize        (void)                                              { return SPI_Uninitialize (&SPI1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L10.12|
000004  f7fffffe          BL       SPI_Uninitialize
000008  bd10              POP      {r4,pc}
;;;1320   static int32_t        SPI1_PowerControl        (ARM_POWER_STATE state)                             { return SPI_PowerControl (state, &SPI1_Resources); }
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      SPI1_Resources

                          AREA ||i.SPIX_GetCapabilities||, CODE, READONLY, ALIGN=2

                  SPIX_GetCapabilities PROC
;;;355    */
;;;356    static ARM_SPI_CAPABILITIES SPIX_GetCapabilities (void) {
000000  4801              LDR      r0,|L11.8|
;;;357      return DriverCapabilities;
000002  6800              LDR      r0,[r0,#0]  ; DriverCapabilities
;;;358    }
000004  4770              BX       lr
;;;359    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      DriverCapabilities

                          AREA ||i.SPIX_GetVersion||, CODE, READONLY, ALIGN=2

                  SPIX_GetVersion PROC
;;;345    */
;;;346    static ARM_DRIVER_VERSION SPIX_GetVersion (void) {
000000  b508              PUSH     {r3,lr}
;;;347      return DriverVersion;
000002  4802              LDR      r0,|L12.12|
000004  6800              LDR      r0,[r0,#0]  ; DriverVersion
000006  9000              STR      r0,[sp,#0]
;;;348    }
000008  bd08              POP      {r3,pc}
;;;349    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      DriverVersion

                          AREA ||i.SPI_Control||, CODE, READONLY, ALIGN=1

                  SPI_Control PROC
;;;846    */
;;;847    static int32_t SPI_Control (uint32_t control, uint32_t arg, const SPI_RESOURCES *spi) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
;;;848      uint32_t           mode, val, pclk;
;;;849      uint32_t           cr1, cr2;
;;;850    
;;;851      mode  = 0U;
00000a  2500              MOVS     r5,#0
;;;852      val   = 0U;
00000c  2600              MOVS     r6,#0
;;;853      cr1   = 0U;
00000e  2700              MOVS     r7,#0
;;;854      cr2   = 0U;
000010  46ab              MOV      r11,r5
;;;855    
;;;856      if ((spi->info->state & SPI_POWERED) == 0U) { return ARM_DRIVER_ERROR; }
000012  6aa0              LDR      r0,[r4,#0x28]
000014  79c0              LDRB     r0,[r0,#7]
000016  f0000002          AND      r0,r0,#2
00001a  b910              CBNZ     r0,|L13.34|
00001c  1e68              SUBS     r0,r5,#1
                  |L13.30|
;;;857    
;;;858      if ((control & ARM_SPI_CONTROL_Msk) == ARM_SPI_ABORT_TRANSFER) {
;;;859        // Send abort
;;;860        if (spi->tx_dma != NULL) {
;;;861          // DMA mode
;;;862          // TX buffer DMA disable
;;;863          spi->reg->CR2 &= ~SPI_CR2_TXDMAEN;
;;;864    
;;;865          // Disable TX DMA transfer
;;;866          DMA_ChannelDisable (spi->tx_dma->instance);
;;;867        } else {
;;;868          // Interrupt mode
;;;869          // Disable TX buffer empty interrupt
;;;870          spi->reg->CR2 &= ~SPI_CR2_TXEIE;
;;;871        }
;;;872    
;;;873        // Receive abort
;;;874        if (spi->rx_dma != NULL) {
;;;875          // DMA mode
;;;876          // RX buffer DMA disable
;;;877          spi->reg->CR2 &= ~SPI_CR2_RXDMAEN;
;;;878    
;;;879          // Disable RX DMA transfer
;;;880          DMA_ChannelDisable (spi->rx_dma->instance);
;;;881        } else {
;;;882          // Interrupt mode
;;;883          // Disable RX buffer not empty interrupt
;;;884          spi->reg->CR2 &= ~SPI_CR2_RXNEIE;
;;;885        }
;;;886    
;;;887        memset(spi->xfer, 0, sizeof(SPI_TRANSFER_INFO));
;;;888        spi->info->status.busy = 0U;
;;;889        return ARM_DRIVER_OK;
;;;890      }
;;;891    
;;;892      // Check for busy flag
;;;893      if (spi->info->status.busy) { return ARM_DRIVER_ERROR_BUSY; }
;;;894    
;;;895      switch (control & ARM_SPI_CONTROL_Msk) {
;;;896        case ARM_SPI_MODE_INACTIVE:
;;;897          mode |= ARM_SPI_MODE_INACTIVE;
;;;898          break;
;;;899    
;;;900        case ARM_SPI_MODE_MASTER:
;;;901          mode |= ARM_SPI_MODE_MASTER;
;;;902    
;;;903          // Master enabled
;;;904          cr1 |= SPI_CR1_MSTR;
;;;905          break;
;;;906    
;;;907        case ARM_SPI_MODE_SLAVE:
;;;908          mode |= ARM_SPI_MODE_SLAVE;
;;;909          break;
;;;910    
;;;911        case ARM_SPI_MODE_MASTER_SIMPLEX:
;;;912          return ARM_SPI_ERROR_MODE;
;;;913    
;;;914        case ARM_SPI_MODE_SLAVE_SIMPLEX:
;;;915          return ARM_SPI_ERROR_MODE;
;;;916    
;;;917        case ARM_SPI_SET_BUS_SPEED:
;;;918          // Set SPI Bus Speed 
;;;919          pclk = spi->pclk;
;;;920          for (val = 0U; val < 8U; val++) {
;;;921            if (arg >= (pclk >> (val + 1U))) { break; }
;;;922          }
;;;923          if ((val == 8U) || (arg < (pclk >> (val + 1U)))) {
;;;924            // Requested Bus Speed can not be configured
;;;925            return ARM_DRIVER_ERROR;
;;;926          }
;;;927          // Disable SPI, update prescaler and enable SPI
;;;928          spi->reg->CR1 &= ~SPI_CR1_SPE;
;;;929          spi->reg->CR1  =  (spi->reg->CR1 & ~SPI_CR1_BR) | (val << 3U);
;;;930          spi->reg->CR1 |=  SPI_CR1_SPE;
;;;931          return ARM_DRIVER_OK;
;;;932    
;;;933        case ARM_SPI_GET_BUS_SPEED:
;;;934          // Return current bus speed
;;;935          return (spi->pclk >> (((spi->reg->CR1 & SPI_CR1_BR) >> 3U) + 1U));
;;;936    
;;;937        case ARM_SPI_SET_DEFAULT_TX_VALUE:
;;;938          spi->xfer->def_val = (uint16_t)(arg & 0xFFFFU);
;;;939          return ARM_DRIVER_OK;
;;;940    
;;;941        case ARM_SPI_CONTROL_SS:
;;;942          val = (spi->info->mode & ARM_SPI_CONTROL_Msk);
;;;943          // Master modes
;;;944          if (val == ARM_SPI_MODE_MASTER) {
;;;945            val = spi->info->mode & ARM_SPI_SS_MASTER_MODE_Msk;
;;;946            // Check if NSS pin is available and
;;;947            // software slave select master is selected
;;;948            if ((spi->io.nss != NULL) && (val == ARM_SPI_SS_MASTER_SW)) {
;;;949              // Set/Clear NSS pin
;;;950              if (arg == ARM_SPI_SS_INACTIVE)
;;;951                GPIO_PinWrite (spi->io.nss->port, spi->io.nss->pin, 1);
;;;952              else
;;;953                GPIO_PinWrite (spi->io.nss->port, spi->io.nss->pin, 0);
;;;954            } else return ARM_DRIVER_ERROR;
;;;955            return ARM_DRIVER_OK;
;;;956          }
;;;957          // Slave modes
;;;958          else if (val == ARM_SPI_MODE_SLAVE) {
;;;959            val = spi->info->mode & ARM_SPI_SS_SLAVE_MODE_Msk;
;;;960            // Check if slave select slave mode is selected
;;;961            if (val == ARM_SPI_SS_MASTER_SW) {
;;;962              if (arg == ARM_SPI_SS_ACTIVE) {
;;;963                spi->reg->CR1 |= SPI_CR1_SSI;
;;;964              }
;;;965              else {
;;;966                spi->reg->CR1 &= ~SPI_CR1_SSI;
;;;967              }
;;;968              return ARM_DRIVER_OK;
;;;969            } else { return ARM_DRIVER_ERROR; }
;;;970          } else { return ARM_DRIVER_ERROR; }
;;;971    
;;;972        default:
;;;973          return ARM_DRIVER_ERROR_UNSUPPORTED;
;;;974      }
;;;975    
;;;976      // Frame format:
;;;977      switch (control & ARM_SPI_FRAME_FORMAT_Msk) {
;;;978        case ARM_SPI_CPOL0_CPHA0:
;;;979          break;
;;;980        case ARM_SPI_CPOL0_CPHA1:
;;;981         cr1 |= SPI_CR1_CPHA;
;;;982          break;
;;;983        case ARM_SPI_CPOL1_CPHA0:
;;;984          cr1 |= SPI_CR1_CPOL;
;;;985          break;
;;;986        case ARM_SPI_CPOL1_CPHA1:
;;;987          cr1 |= SPI_CR1_CPHA | SPI_CR1_CPOL;
;;;988          break;
;;;989        case ARM_SPI_TI_SSI:
;;;990        case ARM_SPI_MICROWIRE:
;;;991        default:
;;;992          return ARM_SPI_ERROR_FRAME_FORMAT;
;;;993      }
;;;994    
;;;995      // Data Bits
;;;996      switch (control & ARM_SPI_DATA_BITS_Msk) {
;;;997        case ARM_SPI_DATA_BITS(8U):
;;;998          break;
;;;999        case ARM_SPI_DATA_BITS(16U):
;;;1000         cr1 |= SPI_CR1_DFF;
;;;1001         break;
;;;1002       default: return ARM_SPI_ERROR_DATA_BITS;
;;;1003     }
;;;1004   
;;;1005     // Bit order
;;;1006     if ((control & ARM_SPI_BIT_ORDER_Msk) == ARM_SPI_LSB_MSB) {
;;;1007       cr1 |= SPI_CR1_LSBFIRST;
;;;1008     }
;;;1009   
;;;1010     // Slave select master modes
;;;1011     if (mode == ARM_SPI_MODE_MASTER) {
;;;1012       switch (control & ARM_SPI_SS_MASTER_MODE_Msk) {
;;;1013         case ARM_SPI_SS_MASTER_UNUSED:
;;;1014           if (spi->io.nss != NULL) {
;;;1015             // Unconfigure NSS pin
;;;1016             GPIO_PinConfigure (spi->io.nss->port, spi->io.nss->pin, GPIO_IN_ANALOG,
;;;1017                                                                     GPIO_MODE_INPUT);
;;;1018           }
;;;1019           // Software slave management
;;;1020           // Internal NSS always active, IO value is ignored
;;;1021           cr1 |= SPI_CR1_SSM | SPI_CR1_SSI;
;;;1022           mode |= ARM_SPI_SS_MASTER_UNUSED;
;;;1023           break;
;;;1024   
;;;1025         case ARM_SPI_SS_MASTER_HW_INPUT:
;;;1026           if (spi->io.nss) {
;;;1027             // Configure NSS pin
;;;1028             GPIO_PortClock (spi->io.nss->port, true);
;;;1029   
;;;1030             GPIO_PinConfigure (spi->io.nss->port, spi->io.nss->pin, GPIO_AF_PUSHPULL,
;;;1031                                                                     GPIO_MODE_OUT50MHZ);
;;;1032           } else {
;;;1033             // NSS pin is not available
;;;1034             return ARM_SPI_ERROR_SS_MODE;
;;;1035           }
;;;1036           mode |= ARM_SPI_SS_MASTER_HW_INPUT;
;;;1037           break;
;;;1038   
;;;1039         case ARM_SPI_SS_MASTER_SW:
;;;1040           if (spi->io.nss) {
;;;1041             // Configure NSS pin as GPIO output
;;;1042             GPIO_PortClock (spi->io.nss->port, true);
;;;1043   
;;;1044             GPIO_PinConfigure (spi->io.nss->port, spi->io.nss->pin, GPIO_OUT_PUSH_PULL,
;;;1045                                                                     GPIO_MODE_OUT50MHZ);
;;;1046             // Software slave management
;;;1047             cr1 |= SPI_CR1_SSM | SPI_CR1_SSI;
;;;1048   
;;;1049             mode |= ARM_SPI_SS_MASTER_SW;
;;;1050           } else {
;;;1051             // NSS pin is not available
;;;1052             return ARM_SPI_ERROR_SS_MODE;
;;;1053           }
;;;1054           break;
;;;1055   
;;;1056         case ARM_SPI_SS_MASTER_HW_OUTPUT:
;;;1057           if (spi->io.nss) {
;;;1058             // Configure NSS pin - SPI NSS alternative function
;;;1059             GPIO_PortClock (spi->io.nss->port, true);
;;;1060   
;;;1061             GPIO_PinConfigure (spi->io.nss->port, spi->io.nss->pin, GPIO_AF_PUSHPULL,
;;;1062                                                                     GPIO_MODE_OUT50MHZ);
;;;1063             // Slave select output enable
;;;1064             cr2 |= SPI_CR2_SSOE;
;;;1065   
;;;1066             mode |= ARM_SPI_SS_MASTER_HW_OUTPUT;
;;;1067           } else {
;;;1068             // NSS pin is not available
;;;1069             return ARM_SPI_ERROR_SS_MODE;
;;;1070           }
;;;1071           break;
;;;1072           default: return ARM_SPI_ERROR_SS_MODE;
;;;1073       }
;;;1074     }
;;;1075   
;;;1076     // Slave select slave modes
;;;1077     if (mode ==  ARM_SPI_MODE_SLAVE) {
;;;1078       switch (control & ARM_SPI_SS_SLAVE_MODE_Msk) {
;;;1079         case ARM_SPI_SS_SLAVE_HW:
;;;1080           if (spi->io.nss) {
;;;1081             // Configure NSS pin - SPI NSS alternative function
;;;1082             GPIO_PortClock (spi->io.nss->port, true);
;;;1083   
;;;1084             GPIO_PinConfigure (spi->io.nss->port, spi->io.nss->pin, GPIO_AF_PUSHPULL,
;;;1085                                                                     GPIO_MODE_OUT50MHZ);
;;;1086             mode |= ARM_SPI_SS_SLAVE_HW;
;;;1087           } else {
;;;1088             // NSS pin is not available
;;;1089             return ARM_SPI_ERROR_SS_MODE;
;;;1090           }
;;;1091           break;
;;;1092   
;;;1093         case ARM_SPI_SS_SLAVE_SW:
;;;1094           if (spi->io.nss) {
;;;1095             // Unconfigure NSS pin
;;;1096             GPIO_PinConfigure (spi->io.nss->port, spi->io.nss->pin, GPIO_IN_ANALOG,
;;;1097                                                                     GPIO_MODE_INPUT);
;;;1098           }
;;;1099           // Enable software slave management
;;;1100           cr1 |= SPI_CR1_SSM;
;;;1101           mode |= ARM_SPI_SS_SLAVE_SW;
;;;1102           break;
;;;1103         default: return ARM_SPI_ERROR_SS_MODE;
;;;1104       }
;;;1105     }
;;;1106   
;;;1107     // Set SPI Bus Speed 
;;;1108     pclk = spi->pclk;
;;;1109     for (val = 0U; val < 8U; val++) {
;;;1110       if (arg >= (pclk >> (val + 1U))) break;
;;;1111     }
;;;1112     if ((val == 8U) || (arg < (pclk >> (val + 1U)))) {
;;;1113       // Requested Bus Speed can not be configured
;;;1114       return ARM_DRIVER_ERROR;
;;;1115     }
;;;1116     // Save prescaler value
;;;1117     cr1 |= (val << 3U);
;;;1118   
;;;1119     spi->info->mode = mode;
;;;1120   
;;;1121     // Configure registers
;;;1122     spi->reg->CR1 &= ~SPI_CR1_SPE;
;;;1123     spi->reg->CR2  = cr2 | SPI_CR2_ERRIE;
;;;1124     spi->reg->CR1  = cr1;
;;;1125   
;;;1126     if ((mode & ARM_SPI_CONTROL_Msk) == ARM_SPI_MODE_INACTIVE) {
;;;1127       spi->info->state &= ~SPI_CONFIGURED;
;;;1128     } else {
;;;1129       spi->info->state |=  SPI_CONFIGURED;
;;;1130     }
;;;1131   
;;;1132     // Enable SPI
;;;1133     spi->reg->CR1 |= SPI_CR1_SPE;
;;;1134   
;;;1135     return ARM_DRIVER_OK;
;;;1136   }
00001e  e8bd9ff0          POP      {r4-r12,pc}
                  |L13.34|
000022  f00800ff          AND      r0,r8,#0xff           ;858
000026  2814              CMP      r0,#0x14              ;858
000028  d133              BNE      |L13.146|
00002a  6a60              LDR      r0,[r4,#0x24]         ;860
00002c  b168              CBZ      r0,|L13.74|
00002e  6820              LDR      r0,[r4,#0]            ;863
000030  8880              LDRH     r0,[r0,#4]            ;863
000032  f0200002          BIC      r0,r0,#2              ;863
000036  6821              LDR      r1,[r4,#0]            ;863
000038  8088              STRH     r0,[r1,#4]            ;863
00003a  6a61              LDR      r1,[r4,#0x24]         ;866
00003c  6808              LDR      r0,[r1,#0]            ;866
00003e  6801              LDR      r1,[r0,#0]            ;866
000040  f0210101          BIC      r1,r1,#1              ;866
000044  6001              STR      r1,[r0,#0]            ;866
000046  bf00              NOP                            ;866
000048  e005              B        |L13.86|
                  |L13.74|
00004a  6820              LDR      r0,[r4,#0]            ;870
00004c  8880              LDRH     r0,[r0,#4]            ;870
00004e  f0200080          BIC      r0,r0,#0x80           ;870
000052  6821              LDR      r1,[r4,#0]            ;870
000054  8088              STRH     r0,[r1,#4]            ;870
                  |L13.86|
000056  6a20              LDR      r0,[r4,#0x20]         ;874
000058  b168              CBZ      r0,|L13.118|
00005a  6820              LDR      r0,[r4,#0]            ;877
00005c  8880              LDRH     r0,[r0,#4]            ;877
00005e  f0200001          BIC      r0,r0,#1              ;877
000062  6821              LDR      r1,[r4,#0]            ;877
000064  8088              STRH     r0,[r1,#4]            ;877
000066  6a21              LDR      r1,[r4,#0x20]         ;880
000068  6808              LDR      r0,[r1,#0]            ;880
00006a  6801              LDR      r1,[r0,#0]            ;880
00006c  f0210101          BIC      r1,r1,#1              ;880
000070  6001              STR      r1,[r0,#0]            ;880
000072  bf00              NOP                            ;880
000074  e005              B        |L13.130|
                  |L13.118|
000076  6820              LDR      r0,[r4,#0]            ;884
000078  8880              LDRH     r0,[r0,#4]            ;884
00007a  f0200040          BIC      r0,r0,#0x40           ;884
00007e  6821              LDR      r1,[r4,#0]            ;884
000080  8088              STRH     r0,[r1,#4]            ;884
                  |L13.130|
000082  211c              MOVS     r1,#0x1c              ;887
000084  6ae0              LDR      r0,[r4,#0x2c]         ;887
000086  f7fffffe          BL       __aeabi_memclr4
00008a  2000              MOVS     r0,#0                 ;888
00008c  6aa1              LDR      r1,[r4,#0x28]         ;888
00008e  7108              STRB     r0,[r1,#4]            ;888
000090  e7c5              B        |L13.30|
                  |L13.146|
000092  6aa0              LDR      r0,[r4,#0x28]         ;893
000094  7900              LDRB     r0,[r0,#4]            ;893
000096  b110              CBZ      r0,|L13.158|
000098  f06f0001          MVN      r0,#1                 ;893
00009c  e7bf              B        |L13.30|
                  |L13.158|
00009e  f00800ff          AND      r0,r8,#0xff           ;895
0000a2  2804              CMP      r0,#4                 ;895
0000a4  d01e              BEQ      |L13.228|
0000a6  dc07              BGT      |L13.184|
0000a8  b178              CBZ      r0,|L13.202|
0000aa  2801              CMP      r0,#1                 ;895
0000ac  d00f              BEQ      |L13.206|
0000ae  2802              CMP      r0,#2                 ;895
0000b0  d012              BEQ      |L13.216|
0000b2  2803              CMP      r0,#3                 ;895
                  |L13.180|
0000b4  d176              BNE      |L13.420|
0000b6  e012              B        |L13.222|
                  |L13.184|
0000b8  2810              CMP      r0,#0x10              ;895
0000ba  d016              BEQ      |L13.234|
0000bc  2811              CMP      r0,#0x11              ;895
0000be  d042              BEQ      |L13.326|
0000c0  2812              CMP      r0,#0x12              ;895
0000c2  d048              BEQ      |L13.342|
0000c4  2813              CMP      r0,#0x13              ;895
0000c6  d1f5              BNE      |L13.180|
0000c8  e04a              B        |L13.352|
                  |L13.202|
0000ca  bf00              NOP                            ;897
0000cc  e0a6              B        |L13.540|
                  |L13.206|
0000ce  f0450501          ORR      r5,r5,#1              ;901
0000d2  f0470704          ORR      r7,r7,#4              ;904
0000d6  e0a1              B        |L13.540|
                  |L13.216|
0000d8  f0450502          ORR      r5,r5,#2              ;908
0000dc  e09e              B        |L13.540|
                  |L13.222|
0000de  f06f0006          MVN      r0,#6                 ;912
0000e2  e79c              B        |L13.30|
                  |L13.228|
0000e4  f06f0006          MVN      r0,#6                 ;915
0000e8  e799              B        |L13.30|
                  |L13.234|
0000ea  f8d4a004          LDR      r10,[r4,#4]           ;919
0000ee  2600              MOVS     r6,#0                 ;920
0000f0  e006              B        |L13.256|
                  |L13.242|
0000f2  1c70              ADDS     r0,r6,#1              ;921
0000f4  fa2af000          LSR      r0,r10,r0             ;921
0000f8  4548              CMP      r0,r9                 ;921
0000fa  d800              BHI      |L13.254|
0000fc  e002              B        |L13.260|
                  |L13.254|
0000fe  1c76              ADDS     r6,r6,#1              ;920
                  |L13.256|
000100  2e08              CMP      r6,#8                 ;920
000102  d3f6              BCC      |L13.242|
                  |L13.260|
000104  bf00              NOP                            ;921
000106  2e08              CMP      r6,#8                 ;923
000108  d004              BEQ      |L13.276|
00010a  1c70              ADDS     r0,r6,#1              ;923
00010c  fa2af000          LSR      r0,r10,r0             ;923
000110  4548              CMP      r0,r9                 ;923
000112  d902              BLS      |L13.282|
                  |L13.276|
000114  f04f30ff          MOV      r0,#0xffffffff        ;925
000118  e781              B        |L13.30|
                  |L13.282|
00011a  6820              LDR      r0,[r4,#0]            ;928
00011c  8800              LDRH     r0,[r0,#0]            ;928
00011e  f0200040          BIC      r0,r0,#0x40           ;928
000122  6821              LDR      r1,[r4,#0]            ;928
000124  8008              STRH     r0,[r1,#0]            ;928
000126  6820              LDR      r0,[r4,#0]            ;929
000128  8800              LDRH     r0,[r0,#0]            ;929
00012a  f0200038          BIC      r0,r0,#0x38           ;929
00012e  ea4000c6          ORR      r0,r0,r6,LSL #3       ;929
000132  6821              LDR      r1,[r4,#0]            ;929
000134  8008              STRH     r0,[r1,#0]            ;929
000136  6820              LDR      r0,[r4,#0]            ;930
000138  8800              LDRH     r0,[r0,#0]            ;930
00013a  f0400040          ORR      r0,r0,#0x40           ;930
00013e  6821              LDR      r1,[r4,#0]            ;930
000140  8008              STRH     r0,[r1,#0]            ;930
000142  2000              MOVS     r0,#0                 ;931
000144  e76b              B        |L13.30|
                  |L13.326|
000146  e9d41000          LDRD     r1,r0,[r4,#0]         ;935
00014a  8809              LDRH     r1,[r1,#0]            ;935
00014c  f3c101c2          UBFX     r1,r1,#3,#3           ;935
000150  1c49              ADDS     r1,r1,#1              ;935
000152  40c8              LSRS     r0,r0,r1              ;935
000154  e763              B        |L13.30|
                  |L13.342|
000156  6ae1              LDR      r1,[r4,#0x2c]         ;938
000158  f8a19018          STRH     r9,[r1,#0x18]         ;938
00015c  2000              MOVS     r0,#0                 ;939
00015e  e75e              B        |L13.30|
                  |L13.352|
000160  6aa0              LDR      r0,[r4,#0x28]         ;942
000162  7a06              LDRB     r6,[r0,#8]            ;942
000164  2e01              CMP      r6,#1                 ;944
000166  d135              BNE      |L13.468|
000168  6aa0              LDR      r0,[r4,#0x28]         ;945
00016a  6880              LDR      r0,[r0,#8]            ;945
00016c  f40016c0          AND      r6,r0,#0x180000       ;945
000170  6920              LDR      r0,[r4,#0x10]         ;948
000172  b350              CBZ      r0,|L13.458|
000174  f5b62f00          CMP      r6,#0x80000           ;948
000178  d127              BNE      |L13.458|
00017a  f1b90f00          CMP      r9,#0                 ;950
00017e  d112              BNE      |L13.422|
000180  6923              LDR      r3,[r4,#0x10]         ;951
000182  2201              MOVS     r2,#1                 ;951
000184  cb03              LDM      r3!,{r0,r1}           ;951
000186  b11a              CBZ      r2,|L13.400|
000188  2301              MOVS     r3,#1                 ;951
00018a  408b              LSLS     r3,r3,r1              ;951
00018c  6103              STR      r3,[r0,#0x10]         ;951
00018e  e007              B        |L13.416|
                  |L13.400|
000190  f1010310          ADD      r3,r1,#0x10           ;951
000194  f04f0c01          MOV      r12,#1                ;951
000198  fa0cfc03          LSL      r12,r12,r3            ;951
00019c  f8c0c010          STR      r12,[r0,#0x10]        ;951
                  |L13.416|
0001a0  bf00              NOP                            ;951
0001a2  e015              B        |L13.464|
                  |L13.420|
0001a4  e037              B        |L13.534|
                  |L13.422|
0001a6  6923              LDR      r3,[r4,#0x10]         ;953
0001a8  2200              MOVS     r2,#0                 ;953
0001aa  cb03              LDM      r3!,{r0,r1}           ;953
0001ac  b11a              CBZ      r2,|L13.438|
0001ae  2301              MOVS     r3,#1                 ;953
0001b0  408b              LSLS     r3,r3,r1              ;953
0001b2  6103              STR      r3,[r0,#0x10]         ;953
0001b4  e007              B        |L13.454|
                  |L13.438|
0001b6  f1010310          ADD      r3,r1,#0x10           ;953
0001ba  f04f0c01          MOV      r12,#1                ;953
0001be  fa0cfc03          LSL      r12,r12,r3            ;953
0001c2  f8c0c010          STR      r12,[r0,#0x10]        ;953
                  |L13.454|
0001c6  bf00              NOP                            ;953
0001c8  e002              B        |L13.464|
                  |L13.458|
0001ca  f04f30ff          MOV      r0,#0xffffffff        ;954
0001ce  e726              B        |L13.30|
                  |L13.464|
0001d0  2000              MOVS     r0,#0                 ;955
0001d2  e724              B        |L13.30|
                  |L13.468|
0001d4  2e02              CMP      r6,#2                 ;958
0001d6  d11b              BNE      |L13.528|
0001d8  6aa0              LDR      r0,[r4,#0x28]         ;959
0001da  6880              LDR      r0,[r0,#8]            ;959
0001dc  f4001600          AND      r6,r0,#0x200000       ;959
0001e0  f5b62f00          CMP      r6,#0x80000           ;961
0001e4  d111              BNE      |L13.522|
0001e6  f1b90f01          CMP      r9,#1                 ;962
0001ea  d106              BNE      |L13.506|
0001ec  6820              LDR      r0,[r4,#0]            ;963
0001ee  8800              LDRH     r0,[r0,#0]            ;963
0001f0  f4407080          ORR      r0,r0,#0x100          ;963
0001f4  6821              LDR      r1,[r4,#0]            ;963
0001f6  8008              STRH     r0,[r1,#0]            ;963
0001f8  e005              B        |L13.518|
                  |L13.506|
0001fa  6820              LDR      r0,[r4,#0]            ;966
0001fc  8800              LDRH     r0,[r0,#0]            ;966
0001fe  f4207080          BIC      r0,r0,#0x100          ;966
000202  6821              LDR      r1,[r4,#0]            ;966
000204  8008              STRH     r0,[r1,#0]            ;966
                  |L13.518|
000206  2000              MOVS     r0,#0                 ;968
000208  e709              B        |L13.30|
                  |L13.522|
00020a  f04f30ff          MOV      r0,#0xffffffff        ;969
00020e  e706              B        |L13.30|
                  |L13.528|
000210  f04f30ff          MOV      r0,#0xffffffff        ;970
000214  e703              B        |L13.30|
                  |L13.534|
000216  f06f0003          MVN      r0,#3                 ;973
00021a  e700              B        |L13.30|
                  |L13.540|
00021c  bf00              NOP                            ;898
00021e  f40860e0          AND      r0,r8,#0x700          ;977
000222  f5b07f40          CMP      r0,#0x300             ;977
000226  d016              BEQ      |L13.598|
000228  dc07              BGT      |L13.570|
00022a  b168              CBZ      r0,|L13.584|
00022c  f5b07f80          CMP      r0,#0x100             ;977
000230  d00b              BEQ      |L13.586|
000232  f5b07f00          CMP      r0,#0x200             ;977
000236  d111              BNE      |L13.604|
000238  e00a              B        |L13.592|
                  |L13.570|
00023a  f5b06f80          CMP      r0,#0x400             ;977
00023e  d00e              BEQ      |L13.606|
000240  f5b06fa0          CMP      r0,#0x500             ;977
000244  d10a              BNE      |L13.604|
000246  e00b              B        |L13.608|
                  |L13.584|
000248  e00d              B        |L13.614|
                  |L13.586|
00024a  f0470701          ORR      r7,r7,#1              ;981
00024e  e00a              B        |L13.614|
                  |L13.592|
000250  f0470702          ORR      r7,r7,#2              ;984
000254  e007              B        |L13.614|
                  |L13.598|
000256  f0470703          ORR      r7,r7,#3              ;987
00025a  e004              B        |L13.614|
                  |L13.604|
00025c  bf00              NOP                            ;989
                  |L13.606|
00025e  bf00              NOP                            ;990
                  |L13.608|
000260  f06f0007          MVN      r0,#7                 ;992
000264  e6db              B        |L13.30|
                  |L13.614|
000266  bf00              NOP                            ;979
000268  f408307c          AND      r0,r8,#0x3f000        ;996
00026c  f5b04f00          CMP      r0,#0x8000            ;996
000270  d003              BEQ      |L13.634|
000272  f5b03f80          CMP      r0,#0x10000           ;996
000276  d104              BNE      |L13.642|
000278  e000              B        |L13.636|
                  |L13.634|
00027a  e005              B        |L13.648|
                  |L13.636|
00027c  f4476700          ORR      r7,r7,#0x800          ;1000
000280  e002              B        |L13.648|
                  |L13.642|
000282  f06f0008          MVN      r0,#8                 ;1002
000286  e6ca              B        |L13.30|
                  |L13.648|
000288  bf00              NOP                            ;998
00028a  f4082080          AND      r0,r8,#0x40000        ;1006
00028e  f5b02f80          CMP      r0,#0x40000           ;1006
000292  d101              BNE      |L13.664|
000294  f0470780          ORR      r7,r7,#0x80           ;1007
                  |L13.664|
000298  2d01              CMP      r5,#1                 ;1011
00029a  d15c              BNE      |L13.854|
00029c  f40810c0          AND      r0,r8,#0x180000       ;1012
0002a0  b148              CBZ      r0,|L13.694|
0002a2  f5b02f00          CMP      r0,#0x80000           ;1012
0002a6  d026              BEQ      |L13.758|
0002a8  f5b01f80          CMP      r0,#0x100000          ;1012
0002ac  d039              BEQ      |L13.802|
0002ae  f5b01fc0          CMP      r0,#0x180000          ;1012
0002b2  d14c              BNE      |L13.846|
0002b4  e00b              B        |L13.718|
                  |L13.694|
0002b6  6920              LDR      r0,[r4,#0x10]         ;1014
0002b8  b128              CBZ      r0,|L13.710|
0002ba  6922              LDR      r2,[r4,#0x10]         ;1016
0002bc  2300              MOVS     r3,#0                 ;1016
0002be  ca03              LDM      r2!,{r0,r1}           ;1016
0002c0  461a              MOV      r2,r3                 ;1016
0002c2  f7fffffe          BL       GPIO_PinConfigure
                  |L13.710|
0002c6  f4477740          ORR      r7,r7,#0x300          ;1021
0002ca  bf00              NOP                            ;1022
0002cc  e042              B        |L13.852|
                  |L13.718|
0002ce  6920              LDR      r0,[r4,#0x10]         ;1026
0002d0  b158              CBZ      r0,|L13.746|
0002d2  6921              LDR      r1,[r4,#0x10]         ;1028
0002d4  6808              LDR      r0,[r1,#0]            ;1028
0002d6  2101              MOVS     r1,#1                 ;1028
0002d8  f7fffffe          BL       GPIO_PortClock
0002dc  6922              LDR      r2,[r4,#0x10]         ;1030
0002de  2303              MOVS     r3,#3                 ;1030
0002e0  ca03              LDM      r2!,{r0,r1}           ;1030
0002e2  2202              MOVS     r2,#2                 ;1030
0002e4  f7fffffe          BL       GPIO_PinConfigure
0002e8  e002              B        |L13.752|
                  |L13.746|
0002ea  f06f000a          MVN      r0,#0xa               ;1034
0002ee  e696              B        |L13.30|
                  |L13.752|
0002f0  f44515c0          ORR      r5,r5,#0x180000       ;1036
0002f4  e02e              B        |L13.852|
                  |L13.758|
0002f6  6920              LDR      r0,[r4,#0x10]         ;1040
0002f8  b178              CBZ      r0,|L13.794|
0002fa  6921              LDR      r1,[r4,#0x10]         ;1042
0002fc  6808              LDR      r0,[r1,#0]            ;1042
0002fe  2101              MOVS     r1,#1                 ;1042
000300  f7fffffe          BL       GPIO_PortClock
000304  6922              LDR      r2,[r4,#0x10]         ;1044
000306  2303              MOVS     r3,#3                 ;1044
000308  ca03              LDM      r2!,{r0,r1}           ;1044
00030a  2200              MOVS     r2,#0                 ;1044
00030c  f7fffffe          BL       GPIO_PinConfigure
000310  f4477740          ORR      r7,r7,#0x300          ;1047
000314  f4452500          ORR      r5,r5,#0x80000        ;1049
000318  e002              B        |L13.800|
                  |L13.794|
00031a  f06f000a          MVN      r0,#0xa               ;1052
00031e  e67e              B        |L13.30|
                  |L13.800|
000320  e018              B        |L13.852|
                  |L13.802|
000322  6920              LDR      r0,[r4,#0x10]         ;1057
000324  b178              CBZ      r0,|L13.838|
000326  6921              LDR      r1,[r4,#0x10]         ;1059
000328  6808              LDR      r0,[r1,#0]            ;1059
00032a  2101              MOVS     r1,#1                 ;1059
00032c  f7fffffe          BL       GPIO_PortClock
000330  6922              LDR      r2,[r4,#0x10]         ;1061
000332  2303              MOVS     r3,#3                 ;1061
000334  ca03              LDM      r2!,{r0,r1}           ;1061
000336  2202              MOVS     r2,#2                 ;1061
000338  f7fffffe          BL       GPIO_PinConfigure
00033c  f04b0b04          ORR      r11,r11,#4            ;1064
000340  f4451580          ORR      r5,r5,#0x100000       ;1066
000344  e002              B        |L13.844|
                  |L13.838|
000346  f06f000a          MVN      r0,#0xa               ;1069
00034a  e668              B        |L13.30|
                  |L13.844|
00034c  e002              B        |L13.852|
                  |L13.846|
00034e  f06f000a          MVN      r0,#0xa               ;1072
000352  e664              B        |L13.30|
                  |L13.852|
000354  bf00              NOP                            ;1023
                  |L13.854|
000356  2d02              CMP      r5,#2                 ;1077
000358  d129              BNE      |L13.942|
00035a  f4081000          AND      r0,r8,#0x200000       ;1078
00035e  b118              CBZ      r0,|L13.872|
000360  f5b01f00          CMP      r0,#0x200000          ;1078
000364  d11f              BNE      |L13.934|
000366  e011              B        |L13.908|
                  |L13.872|
000368  6920              LDR      r0,[r4,#0x10]         ;1080
00036a  b158              CBZ      r0,|L13.900|
00036c  6921              LDR      r1,[r4,#0x10]         ;1082
00036e  6808              LDR      r0,[r1,#0]            ;1082
000370  2101              MOVS     r1,#1                 ;1082
000372  f7fffffe          BL       GPIO_PortClock
000376  6922              LDR      r2,[r4,#0x10]         ;1084
000378  2303              MOVS     r3,#3                 ;1084
00037a  ca03              LDM      r2!,{r0,r1}           ;1084
00037c  2202              MOVS     r2,#2                 ;1084
00037e  f7fffffe          BL       GPIO_PinConfigure
000382  e002              B        |L13.906|
                  |L13.900|
000384  f06f000a          MVN      r0,#0xa               ;1089
000388  e649              B        |L13.30|
                  |L13.906|
00038a  e00f              B        |L13.940|
                  |L13.908|
00038c  6920              LDR      r0,[r4,#0x10]         ;1094
00038e  b128              CBZ      r0,|L13.924|
000390  6922              LDR      r2,[r4,#0x10]         ;1096
000392  2300              MOVS     r3,#0                 ;1096
000394  ca03              LDM      r2!,{r0,r1}           ;1096
000396  461a              MOV      r2,r3                 ;1096
000398  f7fffffe          BL       GPIO_PinConfigure
                  |L13.924|
00039c  f4477700          ORR      r7,r7,#0x200          ;1100
0003a0  f4451500          ORR      r5,r5,#0x200000       ;1101
0003a4  e002              B        |L13.940|
                  |L13.934|
0003a6  f06f000a          MVN      r0,#0xa               ;1103
0003aa  e638              B        |L13.30|
                  |L13.940|
0003ac  bf00              NOP                            ;1091
                  |L13.942|
0003ae  f8d4a004          LDR      r10,[r4,#4]           ;1108
0003b2  2600              MOVS     r6,#0                 ;1109
0003b4  e006              B        |L13.964|
                  |L13.950|
0003b6  1c70              ADDS     r0,r6,#1              ;1110
0003b8  fa2af000          LSR      r0,r10,r0             ;1110
0003bc  4548              CMP      r0,r9                 ;1110
0003be  d800              BHI      |L13.962|
0003c0  e002              B        |L13.968|
                  |L13.962|
0003c2  1c76              ADDS     r6,r6,#1              ;1109
                  |L13.964|
0003c4  2e08              CMP      r6,#8                 ;1109
0003c6  d3f6              BCC      |L13.950|
                  |L13.968|
0003c8  bf00              NOP                            ;1110
0003ca  2e08              CMP      r6,#8                 ;1112
0003cc  d004              BEQ      |L13.984|
0003ce  1c70              ADDS     r0,r6,#1              ;1112
0003d0  fa2af000          LSR      r0,r10,r0             ;1112
0003d4  4548              CMP      r0,r9                 ;1112
0003d6  d902              BLS      |L13.990|
                  |L13.984|
0003d8  f04f30ff          MOV      r0,#0xffffffff        ;1114
0003dc  e61f              B        |L13.30|
                  |L13.990|
0003de  ea4707c6          ORR      r7,r7,r6,LSL #3       ;1117
0003e2  6aa0              LDR      r0,[r4,#0x28]         ;1119
0003e4  6085              STR      r5,[r0,#8]            ;1119
0003e6  6820              LDR      r0,[r4,#0]            ;1122
0003e8  8800              LDRH     r0,[r0,#0]            ;1122
0003ea  f0200040          BIC      r0,r0,#0x40           ;1122
0003ee  6821              LDR      r1,[r4,#0]            ;1122
0003f0  8008              STRH     r0,[r1,#0]            ;1122
0003f2  fa1ff08b          UXTH     r0,r11                ;1123
0003f6  f0400020          ORR      r0,r0,#0x20           ;1123
0003fa  6821              LDR      r1,[r4,#0]            ;1123
0003fc  8088              STRH     r0,[r1,#4]            ;1123
0003fe  6821              LDR      r1,[r4,#0]            ;1124
000400  800f              STRH     r7,[r1,#0]            ;1124
000402  b2e8              UXTB     r0,r5                 ;1126
000404  b930              CBNZ     r0,|L13.1044|
000406  6aa0              LDR      r0,[r4,#0x28]         ;1127
000408  79c0              LDRB     r0,[r0,#7]            ;1127
00040a  f0200004          BIC      r0,r0,#4              ;1127
00040e  6aa1              LDR      r1,[r4,#0x28]         ;1127
000410  71c8              STRB     r0,[r1,#7]            ;1127
000412  e005              B        |L13.1056|
                  |L13.1044|
000414  6aa0              LDR      r0,[r4,#0x28]         ;1129
000416  79c0              LDRB     r0,[r0,#7]            ;1129
000418  f0400004          ORR      r0,r0,#4              ;1129
00041c  6aa1              LDR      r1,[r4,#0x28]         ;1129
00041e  71c8              STRB     r0,[r1,#7]            ;1129
                  |L13.1056|
000420  6820              LDR      r0,[r4,#0]            ;1133
000422  8800              LDRH     r0,[r0,#0]            ;1133
000424  f0400040          ORR      r0,r0,#0x40           ;1133
000428  6821              LDR      r1,[r4,#0]            ;1133
00042a  8008              STRH     r0,[r1,#0]            ;1133
00042c  2000              MOVS     r0,#0                 ;1135
00042e  e5f6              B        |L13.30|
;;;1137   
                          ENDP


                          AREA ||i.SPI_GetDataCount||, CODE, READONLY, ALIGN=1

                  SPI_GetDataCount PROC
;;;834    */
;;;835    static uint32_t SPI_GetDataCount (const SPI_RESOURCES *spi) {
000000  4601              MOV      r1,r0
;;;836      return (spi->xfer->rx_cnt);
000002  6ac8              LDR      r0,[r1,#0x2c]
000004  68c0              LDR      r0,[r0,#0xc]
;;;837    }
000006  4770              BX       lr
;;;838    
                          ENDP


                          AREA ||i.SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetStatus PROC
;;;1143   */
;;;1144   static ARM_SPI_STATUS SPI_GetStatus (const SPI_RESOURCES *spi) {
000000  b50c              PUSH     {r2,r3,lr}
000002  4601              MOV      r1,r0
;;;1145     ARM_SPI_STATUS status;
;;;1146   
;;;1147     status.busy       = spi->info->status.busy;
000004  6a88              LDR      r0,[r1,#0x28]
000006  7902              LDRB     r2,[r0,#4]
000008  9801              LDR      r0,[sp,#4]
00000a  f3620000          BFI      r0,r2,#0,#1
00000e  9001              STR      r0,[sp,#4]
;;;1148     status.data_lost  = spi->info->status.data_lost;
000010  6a88              LDR      r0,[r1,#0x28]
000012  7942              LDRB     r2,[r0,#5]
000014  9801              LDR      r0,[sp,#4]
000016  f3620041          BFI      r0,r2,#1,#1
00001a  9001              STR      r0,[sp,#4]
;;;1149     status.mode_fault = spi->info->status.mode_fault;
00001c  6a88              LDR      r0,[r1,#0x28]
00001e  7982              LDRB     r2,[r0,#6]
000020  9801              LDR      r0,[sp,#4]
000022  f3620082          BFI      r0,r2,#2,#1
000026  9001              STR      r0,[sp,#4]
;;;1150   
;;;1151     return status;
000028  9801              LDR      r0,[sp,#4]
00002a  9a00              LDR      r2,[sp,#0]
00002c  f3600200          BFI      r2,r0,#0,#1
000030  9200              STR      r2,[sp,#0]
000032  9801              LDR      r0,[sp,#4]
000034  0842              LSRS     r2,r0,#1
000036  9800              LDR      r0,[sp,#0]
000038  f3620041          BFI      r0,r2,#1,#1
00003c  9000              STR      r0,[sp,#0]
00003e  9801              LDR      r0,[sp,#4]
000040  0882              LSRS     r2,r0,#2
000042  9800              LDR      r0,[sp,#0]
000044  f3620082          BFI      r0,r2,#2,#1
000048  9000              STR      r0,[sp,#0]
00004a  9801              LDR      r0,[sp,#4]
00004c  08c2              LSRS     r2,r0,#3
00004e  9800              LDR      r0,[sp,#0]
000050  f36200df          BFI      r0,r2,#3,#29
000054  9000              STR      r0,[sp,#0]
000056  9800              LDR      r0,[sp,#0]
;;;1152   }
000058  bd0c              POP      {r2,r3,pc}
;;;1153   
                          ENDP


                          AREA ||i.SPI_IRQHandler||, CODE, READONLY, ALIGN=1

                  SPI_IRQHandler PROC
;;;1154   /*SPI IRQ Handler */
;;;1155   void SPI_IRQHandler (const SPI_RESOURCES *spi) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;1156     uint8_t  data_8bit;
;;;1157     uint16_t data_16bit, sr;
;;;1158     uint32_t event;
;;;1159   
;;;1160     // Save status register
;;;1161     sr = spi->reg->SR;
000006  6820              LDR      r0,[r4,#0]
000008  8907              LDRH     r7,[r0,#8]
;;;1162   
;;;1163     event = 0U;
00000a  2500              MOVS     r5,#0
;;;1164   
;;;1165     if ((sr & SPI_SR_OVR) != 0U) {
00000c  f0070040          AND      r0,r7,#0x40
000010  2800              CMP      r0,#0
000012  d03c              BEQ      |L16.142|
;;;1166       // Clear Overrun flag by reading data and status register
;;;1167       if ((spi->reg->CR1 & SPI_CR1_DFF) == 0U) {
000014  6820              LDR      r0,[r4,#0]
000016  8800              LDRH     r0,[r0,#0]
000018  f4006000          AND      r0,r0,#0x800
00001c  b998              CBNZ     r0,|L16.70|
;;;1168         // 8-bit data frame
;;;1169         data_8bit = *(volatile uint8_t *)(&spi->reg->DR);
00001e  6820              LDR      r0,[r4,#0]
000020  f890800c          LDRB     r8,[r0,#0xc]
;;;1170         if (spi->xfer->rx_cnt < spi->xfer->num) {
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  68c0              LDR      r0,[r0,#0xc]
000028  6ae1              LDR      r1,[r4,#0x2c]
00002a  6809              LDR      r1,[r1,#0]
00002c  4288              CMP      r0,r1
00002e  d222              BCS      |L16.118|
;;;1171           if (spi->xfer->rx_buf != NULL) {
000030  6ae0              LDR      r0,[r4,#0x2c]
000032  6840              LDR      r0,[r0,#4]
000034  b1f8              CBZ      r0,|L16.118|
;;;1172             *(spi->xfer->rx_buf++) = data_8bit;
000036  6ae0              LDR      r0,[r4,#0x2c]
000038  6841              LDR      r1,[r0,#4]
00003a  1c48              ADDS     r0,r1,#1
00003c  6ae2              LDR      r2,[r4,#0x2c]
00003e  6050              STR      r0,[r2,#4]
000040  f8818000          STRB     r8,[r1,#0]
000044  e017              B        |L16.118|
                  |L16.70|
;;;1173           }
;;;1174         }
;;;1175       } else {
;;;1176         // 16-bit data frame
;;;1177         data_16bit = *(volatile uint16_t *)(&spi->reg->DR);
000046  6820              LDR      r0,[r4,#0]
000048  8986              LDRH     r6,[r0,#0xc]
;;;1178         if (spi->xfer->rx_cnt < spi->xfer->num) {
00004a  6ae0              LDR      r0,[r4,#0x2c]
00004c  68c0              LDR      r0,[r0,#0xc]
00004e  6ae1              LDR      r1,[r4,#0x2c]
000050  6809              LDR      r1,[r1,#0]
000052  4288              CMP      r0,r1
000054  d20f              BCS      |L16.118|
;;;1179           if (spi->xfer->rx_buf != NULL) {
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  6840              LDR      r0,[r0,#4]
00005a  b160              CBZ      r0,|L16.118|
;;;1180             *(spi->xfer->rx_buf++) = (uint8_t) data_16bit;
00005c  6ae0              LDR      r0,[r4,#0x2c]
00005e  6842              LDR      r2,[r0,#4]
000060  1c50              ADDS     r0,r2,#1
000062  6ae3              LDR      r3,[r4,#0x2c]
000064  6058              STR      r0,[r3,#4]
000066  7016              STRB     r6,[r2,#0]
;;;1181             *(spi->xfer->rx_buf++) = (uint8_t)(data_16bit >> 8U);
000068  1231              ASRS     r1,r6,#8
00006a  6ae0              LDR      r0,[r4,#0x2c]
00006c  6842              LDR      r2,[r0,#4]
00006e  1c50              ADDS     r0,r2,#1
000070  6ae3              LDR      r3,[r4,#0x2c]
000072  6058              STR      r0,[r3,#4]
000074  7011              STRB     r1,[r2,#0]
                  |L16.118|
;;;1182           }
;;;1183         }
;;;1184       }
;;;1185       spi->xfer->rx_cnt++;
000076  6ae0              LDR      r0,[r4,#0x2c]
000078  68c0              LDR      r0,[r0,#0xc]
00007a  1c40              ADDS     r0,r0,#1
00007c  6ae1              LDR      r1,[r4,#0x2c]
00007e  60c8              STR      r0,[r1,#0xc]
;;;1186       sr = spi->reg->SR;
000080  6820              LDR      r0,[r4,#0]
000082  8907              LDRH     r7,[r0,#8]
;;;1187   
;;;1188       spi->info->status.data_lost = 1U;
000084  2101              MOVS     r1,#1
000086  6aa0              LDR      r0,[r4,#0x28]
000088  7141              STRB     r1,[r0,#5]
;;;1189       event |=ARM_SPI_EVENT_DATA_LOST;
00008a  f0450502          ORR      r5,r5,#2
                  |L16.142|
;;;1190     }
;;;1191     if ((sr & SPI_SR_UDR) != 0U) {
00008e  f0070008          AND      r0,r7,#8
000092  b120              CBZ      r0,|L16.158|
;;;1192       // Underrun flag is set
;;;1193       spi->info->status.data_lost = 1U;
000094  2101              MOVS     r1,#1
000096  6aa0              LDR      r0,[r4,#0x28]
000098  7141              STRB     r1,[r0,#5]
;;;1194       event |= ARM_SPI_EVENT_DATA_LOST;
00009a  f0450502          ORR      r5,r5,#2
                  |L16.158|
;;;1195     }
;;;1196     if ((sr & SPI_SR_MODF) != 0U) {
00009e  f0070020          AND      r0,r7,#0x20
0000a2  b140              CBZ      r0,|L16.182|
;;;1197       // Mode fault flag is set
;;;1198       spi->info->status.mode_fault = 1U;
0000a4  2101              MOVS     r1,#1
0000a6  6aa0              LDR      r0,[r4,#0x28]
0000a8  7181              STRB     r1,[r0,#6]
;;;1199   
;;;1200       // Write CR1 register to clear MODF flag
;;;1201       spi->reg->CR1 = spi->reg->CR1;
0000aa  6820              LDR      r0,[r4,#0]
0000ac  8800              LDRH     r0,[r0,#0]
0000ae  6821              LDR      r1,[r4,#0]
0000b0  8008              STRH     r0,[r1,#0]
;;;1202       event |= ARM_SPI_EVENT_MODE_FAULT;
0000b2  f0450504          ORR      r5,r5,#4
                  |L16.182|
;;;1203     }
;;;1204   
;;;1205     if (((sr & SPI_SR_RXNE) != 0U) && ((spi->reg->CR2 & SPI_CR2_RXNEIE) != 0U)) {
0000b6  f0070001          AND      r0,r7,#1
0000ba  2800              CMP      r0,#0
0000bc  d049              BEQ      |L16.338|
0000be  6820              LDR      r0,[r4,#0]
0000c0  8880              LDRH     r0,[r0,#4]
0000c2  f0000040          AND      r0,r0,#0x40
0000c6  2800              CMP      r0,#0
0000c8  d043              BEQ      |L16.338|
;;;1206       // Receive Buffer Not Empty
;;;1207   
;;;1208       if (spi->xfer->rx_cnt < spi->xfer->num) {
0000ca  6ae0              LDR      r0,[r4,#0x2c]
0000cc  68c0              LDR      r0,[r0,#0xc]
0000ce  6ae1              LDR      r1,[r4,#0x2c]
0000d0  6809              LDR      r1,[r1,#0]
0000d2  4288              CMP      r0,r1
0000d4  d23b              BCS      |L16.334|
;;;1209         if ((spi->reg->CR1 & SPI_CR1_DFF) == 0U) {
0000d6  6820              LDR      r0,[r4,#0]
0000d8  8800              LDRH     r0,[r0,#0]
0000da  f4006000          AND      r0,r0,#0x800
0000de  b968              CBNZ     r0,|L16.252|
;;;1210           // 8-bit data frame
;;;1211           data_8bit = *(volatile uint8_t *)(&spi->reg->DR);
0000e0  6820              LDR      r0,[r4,#0]
0000e2  f890800c          LDRB     r8,[r0,#0xc]
;;;1212           if (spi->xfer->rx_buf != NULL) {
0000e6  6ae0              LDR      r0,[r4,#0x2c]
0000e8  6840              LDR      r0,[r0,#4]
0000ea  b1c8              CBZ      r0,|L16.288|
;;;1213             *(spi->xfer->rx_buf++) = data_8bit;
0000ec  6ae0              LDR      r0,[r4,#0x2c]
0000ee  6841              LDR      r1,[r0,#4]
0000f0  1c48              ADDS     r0,r1,#1
0000f2  6ae2              LDR      r2,[r4,#0x2c]
0000f4  6050              STR      r0,[r2,#4]
0000f6  f8818000          STRB     r8,[r1,#0]
0000fa  e011              B        |L16.288|
                  |L16.252|
;;;1214           }
;;;1215         } else {
;;;1216           // 16-bit data frame
;;;1217           data_16bit = *(volatile uint16_t *)(&spi->reg->DR);
0000fc  6820              LDR      r0,[r4,#0]
0000fe  8986              LDRH     r6,[r0,#0xc]
;;;1218           if (spi->xfer->rx_buf != NULL) {
000100  6ae0              LDR      r0,[r4,#0x2c]
000102  6840              LDR      r0,[r0,#4]
000104  b160              CBZ      r0,|L16.288|
;;;1219             *(spi->xfer->rx_buf++) = (uint8_t) data_16bit;
000106  6ae0              LDR      r0,[r4,#0x2c]
000108  6842              LDR      r2,[r0,#4]
00010a  1c50              ADDS     r0,r2,#1
00010c  6ae3              LDR      r3,[r4,#0x2c]
00010e  6058              STR      r0,[r3,#4]
000110  7016              STRB     r6,[r2,#0]
;;;1220             *(spi->xfer->rx_buf++) = (uint8_t)(data_16bit >> 8U);
000112  1231              ASRS     r1,r6,#8
000114  6ae0              LDR      r0,[r4,#0x2c]
000116  6842              LDR      r2,[r0,#4]
000118  1c50              ADDS     r0,r2,#1
00011a  6ae3              LDR      r3,[r4,#0x2c]
00011c  6058              STR      r0,[r3,#4]
00011e  7011              STRB     r1,[r2,#0]
                  |L16.288|
;;;1221           }
;;;1222         }
;;;1223   
;;;1224         spi->xfer->rx_cnt++;
000120  6ae0              LDR      r0,[r4,#0x2c]
000122  68c0              LDR      r0,[r0,#0xc]
000124  1c40              ADDS     r0,r0,#1
000126  6ae1              LDR      r1,[r4,#0x2c]
000128  60c8              STR      r0,[r1,#0xc]
;;;1225   
;;;1226         if (spi->xfer->rx_cnt == spi->xfer->num) {
00012a  6ae0              LDR      r0,[r4,#0x2c]
00012c  68c0              LDR      r0,[r0,#0xc]
00012e  6ae1              LDR      r1,[r4,#0x2c]
000130  6809              LDR      r1,[r1,#0]
000132  4288              CMP      r0,r1
000134  d10d              BNE      |L16.338|
;;;1227   
;;;1228           // Disable RX Buffer Not Empty Interrupt
;;;1229           spi->reg->CR2 &= ~SPI_CR2_RXNEIE;
000136  6820              LDR      r0,[r4,#0]
000138  8880              LDRH     r0,[r0,#4]
00013a  f0200040          BIC      r0,r0,#0x40
00013e  6821              LDR      r1,[r4,#0]
000140  8088              STRH     r0,[r1,#4]
;;;1230   
;;;1231           // Clear busy flag
;;;1232           spi->info->status.busy = 0U;
000142  2000              MOVS     r0,#0
000144  6aa1              LDR      r1,[r4,#0x28]
000146  7108              STRB     r0,[r1,#4]
;;;1233   
;;;1234           // Transfer completed
;;;1235           event |= ARM_SPI_EVENT_TRANSFER_COMPLETE;
000148  f0450501          ORR      r5,r5,#1
00014c  e001              B        |L16.338|
                  |L16.334|
;;;1236         }
;;;1237       }
;;;1238       else {
;;;1239         // Unexpected transfer, data lost
;;;1240         event |= ARM_SPI_EVENT_DATA_LOST;
00014e  f0450502          ORR      r5,r5,#2
                  |L16.338|
;;;1241       }
;;;1242     }
;;;1243   
;;;1244     if (((sr & SPI_SR_TXE) != 0U) && ((spi->reg->CR2 & SPI_CR2_TXEIE) != 0U)) {
000152  f0070002          AND      r0,r7,#2
000156  2800              CMP      r0,#0
000158  d04c              BEQ      |L16.500|
00015a  6820              LDR      r0,[r4,#0]
00015c  8880              LDRH     r0,[r0,#4]
00015e  f0000080          AND      r0,r0,#0x80
000162  2800              CMP      r0,#0
000164  d046              BEQ      |L16.500|
;;;1245       if (spi->xfer->tx_cnt < spi->xfer->num) {
000166  6ae0              LDR      r0,[r4,#0x2c]
000168  6900              LDR      r0,[r0,#0x10]
00016a  6ae1              LDR      r1,[r4,#0x2c]
00016c  6809              LDR      r1,[r1,#0]
00016e  4288              CMP      r0,r1
000170  d23e              BCS      |L16.496|
;;;1246         if ((spi->reg->CR1 & SPI_CR1_DFF) == 0U) {
000172  6820              LDR      r0,[r4,#0]
000174  8800              LDRH     r0,[r0,#0]
000176  f4006000          AND      r0,r0,#0x800
00017a  b988              CBNZ     r0,|L16.416|
;;;1247           if (spi->xfer->tx_buf != NULL) {
00017c  6ae0              LDR      r0,[r4,#0x2c]
00017e  6880              LDR      r0,[r0,#8]
000180  b138              CBZ      r0,|L16.402|
;;;1248             data_8bit = *(spi->xfer->tx_buf++);
000182  6ae0              LDR      r0,[r4,#0x2c]
000184  6881              LDR      r1,[r0,#8]
000186  1c48              ADDS     r0,r1,#1
000188  6ae2              LDR      r2,[r4,#0x2c]
00018a  6090              STR      r0,[r2,#8]
00018c  f8918000          LDRB     r8,[r1,#0]
000190  e002              B        |L16.408|
                  |L16.402|
;;;1249           } else {
;;;1250             data_8bit = (uint8_t)spi->xfer->def_val;
000192  6ae0              LDR      r0,[r4,#0x2c]
000194  f8908018          LDRB     r8,[r0,#0x18]
                  |L16.408|
;;;1251           }
;;;1252           // Write data to data register
;;;1253           *(volatile uint8_t *)(&spi->reg->DR) = data_8bit;
000198  6820              LDR      r0,[r4,#0]
00019a  f880800c          STRB     r8,[r0,#0xc]
00019e  e015              B        |L16.460|
                  |L16.416|
;;;1254         } else {
;;;1255           if (spi->xfer->tx_buf != NULL) {
0001a0  6ae0              LDR      r0,[r4,#0x2c]
0001a2  6880              LDR      r0,[r0,#8]
0001a4  b170              CBZ      r0,|L16.452|
;;;1256             data_16bit  = *(spi->xfer->tx_buf++);
0001a6  6ae0              LDR      r0,[r4,#0x2c]
0001a8  6881              LDR      r1,[r0,#8]
0001aa  1c48              ADDS     r0,r1,#1
0001ac  6ae2              LDR      r2,[r4,#0x2c]
0001ae  6090              STR      r0,[r2,#8]
0001b0  780e              LDRB     r6,[r1,#0]
;;;1257             data_16bit |= *(spi->xfer->tx_buf++) << 8U;
0001b2  6ae0              LDR      r0,[r4,#0x2c]
0001b4  6881              LDR      r1,[r0,#8]
0001b6  1c48              ADDS     r0,r1,#1
0001b8  6ae2              LDR      r2,[r4,#0x2c]
0001ba  6090              STR      r0,[r2,#8]
0001bc  7808              LDRB     r0,[r1,#0]
0001be  ea462600          ORR      r6,r6,r0,LSL #8
0001c2  e001              B        |L16.456|
                  |L16.452|
;;;1258           } else {
;;;1259             data_16bit  = (uint16_t)spi->xfer->def_val;
0001c4  6ae0              LDR      r0,[r4,#0x2c]
0001c6  8b06              LDRH     r6,[r0,#0x18]
                  |L16.456|
;;;1260           }
;;;1261           // Write data to data register
;;;1262           *(volatile uint16_t *)(&spi->reg->DR) = data_16bit;
0001c8  6820              LDR      r0,[r4,#0]
0001ca  8186              STRH     r6,[r0,#0xc]
                  |L16.460|
;;;1263         }
;;;1264   
;;;1265         spi->xfer->tx_cnt++;
0001cc  6ae0              LDR      r0,[r4,#0x2c]
0001ce  6900              LDR      r0,[r0,#0x10]
0001d0  1c40              ADDS     r0,r0,#1
0001d2  6ae1              LDR      r1,[r4,#0x2c]
0001d4  6108              STR      r0,[r1,#0x10]
;;;1266   
;;;1267         if (spi->xfer->tx_cnt == spi->xfer->num) {
0001d6  6ae0              LDR      r0,[r4,#0x2c]
0001d8  6900              LDR      r0,[r0,#0x10]
0001da  6ae1              LDR      r1,[r4,#0x2c]
0001dc  6809              LDR      r1,[r1,#0]
0001de  4288              CMP      r0,r1
0001e0  d108              BNE      |L16.500|
;;;1268           // All data sent, disable TX Buffer Empty Interrupt
;;;1269           spi->reg->CR2 &= ~SPI_CR2_TXEIE;
0001e2  6820              LDR      r0,[r4,#0]
0001e4  8880              LDRH     r0,[r0,#4]
0001e6  f0200080          BIC      r0,r0,#0x80
0001ea  6821              LDR      r1,[r4,#0]
0001ec  8088              STRH     r0,[r1,#4]
0001ee  e001              B        |L16.500|
                  |L16.496|
;;;1270         }
;;;1271       } else {
;;;1272         // Unexpected transfer, data lost
;;;1273         event |= ARM_SPI_EVENT_DATA_LOST;
0001f0  f0450502          ORR      r5,r5,#2
                  |L16.500|
;;;1274       }
;;;1275     }
;;;1276   
;;;1277     // Send event
;;;1278     if ((event != 0U) && ((spi->info->cb_event != NULL))) {
0001f4  b135              CBZ      r5,|L16.516|
0001f6  6aa0              LDR      r0,[r4,#0x28]
0001f8  6800              LDR      r0,[r0,#0]
0001fa  b118              CBZ      r0,|L16.516|
;;;1279       spi->info->cb_event(event);
0001fc  6aa0              LDR      r0,[r4,#0x28]
0001fe  6801              LDR      r1,[r0,#0]
000200  4628              MOV      r0,r5
000202  4788              BLX      r1
                  |L16.516|
;;;1280     }
;;;1281   }
000204  e8bd81f0          POP      {r4-r8,pc}
;;;1282   
                          ENDP


                          AREA ||i.SPI_Initialize||, CODE, READONLY, ALIGN=1

                  SPI_Initialize PROC
;;;367    */
;;;368    static int32_t SPI_Initialize (ARM_SPI_SignalEvent_t cb_event, const SPI_RESOURCES *spi) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;369      bool ok = true;
000006  2501              MOVS     r5,#1
;;;370    
;;;371      if (spi->info->state & SPI_INITIALIZED) { return ARM_DRIVER_OK; }
000008  6aa0              LDR      r0,[r4,#0x28]
00000a  79c0              LDRB     r0,[r0,#7]
00000c  f0000001          AND      r0,r0,#1
000010  b108              CBZ      r0,|L17.22|
000012  2000              MOVS     r0,#0
                  |L17.20|
;;;372    
;;;373      // Initialize SPI Run-Time Resources
;;;374      spi->info->cb_event = cb_event;
;;;375      spi->info->status.busy       = 0U;
;;;376      spi->info->status.data_lost  = 0U;
;;;377      spi->info->status.mode_fault = 0U;
;;;378    
;;;379      // Clear transfer information
;;;380      memset(spi->xfer, 0, sizeof(SPI_TRANSFER_INFO));
;;;381    
;;;382      // Setup pin remap
;;;383      GPIO_AFConfigure(spi->io.afio);
;;;384    
;;;385      // Configure SPI SCK pin
;;;386      GPIO_PortClock (spi->io.sck->port, true);
;;;387      ok = GPIO_PinConfigure(spi->io.sck->port, spi->io.sck->pin, GPIO_AF_PUSHPULL,
;;;388                                                                  GPIO_MODE_OUT50MHZ);
;;;389      if (ok && (spi->io.mosi != NULL)) {
;;;390        // Configure SPI MOSI pin
;;;391        GPIO_PortClock (spi->io.mosi->port, true);
;;;392        ok = GPIO_PinConfigure(spi->io.mosi->port, spi->io.mosi->pin, GPIO_AF_PUSHPULL,
;;;393                                                                      GPIO_MODE_OUT50MHZ);
;;;394      }
;;;395      if (ok && (spi->io.miso != NULL)) {
;;;396        // Configure SPI MISO pin
;;;397        GPIO_PortClock (spi->io.miso->port, true);
;;;398        ok = GPIO_PinConfigure(spi->io.miso->port, spi->io.miso->pin, GPIO_AF_PUSHPULL,
;;;399                                                                      GPIO_MODE_INPUT);
;;;400      }
;;;401    
;;;402    #ifdef __SPI_DMA
;;;403      if ((spi->rx_dma != NULL) || (spi->tx_dma != NULL)) {
;;;404        if (spi->rx_dma != NULL) {
;;;405          DMA_ChannelInitialize (spi->rx_dma->dma_num, spi->rx_dma->ch_num);
;;;406        }
;;;407        if (spi->tx_dma != NULL) {
;;;408          DMA_ChannelInitialize (spi->tx_dma->dma_num, spi->tx_dma->ch_num);
;;;409        }
;;;410      }
;;;411    #endif
;;;412    
;;;413      spi->info->state = SPI_INITIALIZED;
;;;414    
;;;415      return (ok) ? (ARM_DRIVER_OK) : (ARM_DRIVER_ERROR);
;;;416    }
000014  bd70              POP      {r4-r6,pc}
                  |L17.22|
000016  6aa0              LDR      r0,[r4,#0x28]         ;374
000018  6006              STR      r6,[r0,#0]            ;374
00001a  2000              MOVS     r0,#0                 ;375
00001c  6aa1              LDR      r1,[r4,#0x28]         ;375
00001e  7108              STRB     r0,[r1,#4]            ;375
000020  2100              MOVS     r1,#0                 ;376
000022  6aa0              LDR      r0,[r4,#0x28]         ;376
000024  7141              STRB     r1,[r0,#5]            ;376
000026  6aa0              LDR      r0,[r4,#0x28]         ;377
000028  7181              STRB     r1,[r0,#6]            ;377
00002a  211c              MOVS     r1,#0x1c              ;380
00002c  6ae0              LDR      r0,[r4,#0x2c]         ;380
00002e  f7fffffe          BL       __aeabi_memclr4
000032  8b60              LDRH     r0,[r4,#0x1a]         ;383
000034  f7fffffe          BL       GPIO_AFConfigure
000038  6961              LDR      r1,[r4,#0x14]         ;386
00003a  6808              LDR      r0,[r1,#0]            ;386
00003c  2101              MOVS     r1,#1                 ;386
00003e  f7fffffe          BL       GPIO_PortClock
000042  6962              LDR      r2,[r4,#0x14]         ;387
000044  2303              MOVS     r3,#3                 ;387
000046  ca03              LDM      r2!,{r0,r1}           ;387
000048  2202              MOVS     r2,#2                 ;387
00004a  f7fffffe          BL       GPIO_PinConfigure
00004e  4605              MOV      r5,r0                 ;387
000050  b16d              CBZ      r5,|L17.110|
000052  68a0              LDR      r0,[r4,#8]            ;389
000054  b158              CBZ      r0,|L17.110|
000056  68a1              LDR      r1,[r4,#8]            ;391
000058  6808              LDR      r0,[r1,#0]            ;391
00005a  2101              MOVS     r1,#1                 ;391
00005c  f7fffffe          BL       GPIO_PortClock
000060  68a2              LDR      r2,[r4,#8]            ;392
000062  2303              MOVS     r3,#3                 ;392
000064  ca03              LDM      r2!,{r0,r1}           ;392
000066  2202              MOVS     r2,#2                 ;392
000068  f7fffffe          BL       GPIO_PinConfigure
00006c  4605              MOV      r5,r0                 ;392
                  |L17.110|
00006e  b16d              CBZ      r5,|L17.140|
000070  68e0              LDR      r0,[r4,#0xc]          ;395
000072  b158              CBZ      r0,|L17.140|
000074  68e1              LDR      r1,[r4,#0xc]          ;397
000076  6808              LDR      r0,[r1,#0]            ;397
000078  2101              MOVS     r1,#1                 ;397
00007a  f7fffffe          BL       GPIO_PortClock
00007e  68e2              LDR      r2,[r4,#0xc]          ;398
000080  2300              MOVS     r3,#0                 ;398
000082  ca03              LDM      r2!,{r0,r1}           ;398
000084  2202              MOVS     r2,#2                 ;398
000086  f7fffffe          BL       GPIO_PinConfigure
00008a  4605              MOV      r5,r0                 ;398
                  |L17.140|
00008c  2001              MOVS     r0,#1                 ;413
00008e  6aa1              LDR      r1,[r4,#0x28]         ;413
000090  71c8              STRB     r0,[r1,#7]            ;413
000092  b10d              CBZ      r5,|L17.152|
000094  2000              MOVS     r0,#0                 ;415
000096  e7bd              B        |L17.20|
                  |L17.152|
000098  f04f30ff          MOV      r0,#0xffffffff        ;415
00009c  e7ba              B        |L17.20|
;;;417    
                          ENDP


                          AREA ||i.SPI_PeripheralReset||, CODE, READONLY, ALIGN=2

                  SPI_PeripheralReset PROC
;;;319    */
;;;320    static void SPI_PeripheralReset (const SPI_TypeDef *spi) {
000000  4914              LDR      r1,|L18.84|
;;;321    
;;;322      if (spi == SPI1) { RCC->APB2RSTR |= RCC_APB2RSTR_SPI1RST; }
000002  4288              CMP      r0,r1
000004  d105              BNE      |L18.18|
000006  4914              LDR      r1,|L18.88|
000008  68c9              LDR      r1,[r1,#0xc]
00000a  f4415180          ORR      r1,r1,#0x1000
00000e  4a12              LDR      r2,|L18.88|
000010  60d1              STR      r1,[r2,#0xc]
                  |L18.18|
;;;323    #if !defined(STM32F10X_LD) && !defined(STM32F10X_LD_VL)
;;;324      if (spi == SPI2) { RCC->APB1RSTR |= RCC_APB1RSTR_SPI2RST; }
000012  4912              LDR      r1,|L18.92|
000014  4288              CMP      r0,r1
000016  d105              BNE      |L18.36|
000018  490f              LDR      r1,|L18.88|
00001a  6909              LDR      r1,[r1,#0x10]
00001c  f4414180          ORR      r1,r1,#0x4000
000020  4a0d              LDR      r2,|L18.88|
000022  6111              STR      r1,[r2,#0x10]
                  |L18.36|
;;;325    #endif
;;;326    #if defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F10X_XL) || defined(STM32F10X_HD_VL)
;;;327      if (spi == SPI3) { RCC->APB1RSTR |= RCC_APB1RSTR_SPI3RST; }
;;;328    #endif
;;;329    
;;;330      __NOP(); __NOP(); __NOP(); __NOP();
000024  bf00              NOP      
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
;;;331    
;;;332      if (spi == SPI1) { RCC->APB2RSTR &= ~RCC_APB2RSTR_SPI1RST; }
00002c  4909              LDR      r1,|L18.84|
00002e  4288              CMP      r0,r1
000030  d105              BNE      |L18.62|
000032  4909              LDR      r1,|L18.88|
000034  68c9              LDR      r1,[r1,#0xc]
000036  f4215180          BIC      r1,r1,#0x1000
00003a  4a07              LDR      r2,|L18.88|
00003c  60d1              STR      r1,[r2,#0xc]
                  |L18.62|
;;;333    #if !defined(STM32F10X_LD) && !defined(STM32F10X_LD_VL)
;;;334      if (spi == SPI2) { RCC->APB1RSTR &= ~RCC_APB1RSTR_SPI2RST; }
00003e  4907              LDR      r1,|L18.92|
000040  4288              CMP      r0,r1
000042  d105              BNE      |L18.80|
000044  4904              LDR      r1,|L18.88|
000046  6909              LDR      r1,[r1,#0x10]
000048  f4214180          BIC      r1,r1,#0x4000
00004c  4a02              LDR      r2,|L18.88|
00004e  6111              STR      r1,[r2,#0x10]
                  |L18.80|
;;;335    #endif
;;;336    #if defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F10X_XL) || defined(STM32F10X_HD_VL)
;;;337      if (spi == SPI3) { RCC->APB1RSTR &= ~RCC_APB1RSTR_SPI3RST; }
;;;338    #endif
;;;339    }
000050  4770              BX       lr
;;;340    
                          ENDP

000052  0000              DCW      0x0000
                  |L18.84|
                          DCD      0x40013000
                  |L18.88|
                          DCD      0x40021000
                  |L18.92|
                          DCD      0x40003800

                          AREA ||i.SPI_PowerControl||, CODE, READONLY, ALIGN=2

                  SPI_PowerControl PROC
;;;465    */
;;;466    static int32_t SPI_PowerControl (ARM_POWER_STATE state, const SPI_RESOURCES *spi) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;467    
;;;468      switch (state) {
000006  b125              CBZ      r5,|L19.18|
000008  2d01              CMP      r5,#1
00000a  d07d              BEQ      |L19.264|
00000c  2d02              CMP      r5,#2
00000e  d17c              BNE      |L19.266|
000010  e042              B        |L19.152|
                  |L19.18|
;;;469        case ARM_POWER_OFF:
;;;470          // SPI peripheral reset
;;;471          SPI_PeripheralReset (spi->reg);
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       SPI_PeripheralReset
;;;472    
;;;473          NVIC_DisableIRQ (spi->irq_num);
000018  f994001c          LDRSB    r0,[r4,#0x1c]
00001c  2800              CMP      r0,#0
00001e  db17              BLT      |L19.80|
000020  f000021f          AND      r2,r0,#0x1f
000024  2101              MOVS     r1,#1
000026  4091              LSLS     r1,r1,r2
000028  4a4c              LDR      r2,|L19.348|
00002a  0943              LSRS     r3,r0,#5
00002c  f8421023          STR      r1,[r2,r3,LSL #2]
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
000036  f3bf8f4f          DSB      
00003a  bf00              NOP      
00003c  bf00              NOP      
00003e  bf00              NOP      
000040  bf00              NOP      
000042  bf00              NOP      
000044  bf00              NOP      
000046  f3bf8f6f          ISB      
00004a  bf00              NOP      
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L19.80|
000050  bf00              NOP      
;;;474    
;;;475          // Disable SPI clock
;;;476          if (spi->reg == SPI1) { RCC->APB2ENR &= ~RCC_APB2ENR_SPI1EN; }
000052  4943              LDR      r1,|L19.352|
000054  6820              LDR      r0,[r4,#0]
000056  4288              CMP      r0,r1
000058  d105              BNE      |L19.102|
00005a  4842              LDR      r0,|L19.356|
00005c  6980              LDR      r0,[r0,#0x18]
00005e  f4205080          BIC      r0,r0,#0x1000
000062  4940              LDR      r1,|L19.356|
000064  6188              STR      r0,[r1,#0x18]
                  |L19.102|
;;;477    #if !defined(STM32F10X_LD) && !defined(STM32F10X_LD_VL)
;;;478          if (spi->reg == SPI2) { RCC->APB1ENR &= ~RCC_APB1ENR_SPI2EN; }
000066  4940              LDR      r1,|L19.360|
000068  6820              LDR      r0,[r4,#0]
00006a  4288              CMP      r0,r1
00006c  d105              BNE      |L19.122|
00006e  483d              LDR      r0,|L19.356|
000070  69c0              LDR      r0,[r0,#0x1c]
000072  f4204080          BIC      r0,r0,#0x4000
000076  493b              LDR      r1,|L19.356|
000078  61c8              STR      r0,[r1,#0x1c]
                  |L19.122|
;;;479    #endif
;;;480    #if defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F10X_XL) || defined(STM32F10X_HD_VL)
;;;481          if (spi->reg == SPI3) { RCC->APB1ENR &= ~RCC_APB1ENR_SPI3EN; }
;;;482    #endif
;;;483    
;;;484          // Clear status flags
;;;485          spi->info->status.busy       = 0U;
00007a  2000              MOVS     r0,#0
00007c  6aa1              LDR      r1,[r4,#0x28]
00007e  7108              STRB     r0,[r1,#4]
;;;486          spi->info->status.data_lost  = 0U;
000080  2100              MOVS     r1,#0
000082  6aa0              LDR      r0,[r4,#0x28]
000084  7141              STRB     r1,[r0,#5]
;;;487          spi->info->status.mode_fault = 0U;
000086  6aa0              LDR      r0,[r4,#0x28]
000088  7181              STRB     r1,[r0,#6]
;;;488    
;;;489          // Clear powered flag
;;;490          spi->info->state &= ~SPI_POWERED;
00008a  6aa0              LDR      r0,[r4,#0x28]
00008c  79c0              LDRB     r0,[r0,#7]
00008e  f0200002          BIC      r0,r0,#2
000092  6aa1              LDR      r1,[r4,#0x28]
000094  71c8              STRB     r0,[r1,#7]
;;;491          break;
000096  e05e              B        |L19.342|
                  |L19.152|
;;;492    
;;;493        case ARM_POWER_FULL:
;;;494          if ((spi->info->state & SPI_INITIALIZED) == 0U) {
000098  6aa0              LDR      r0,[r4,#0x28]
00009a  79c0              LDRB     r0,[r0,#7]
00009c  f0000001          AND      r0,r0,#1
0000a0  b910              CBNZ     r0,|L19.168|
;;;495            return ARM_DRIVER_ERROR;
0000a2  f04f30ff          MOV      r0,#0xffffffff
                  |L19.166|
;;;496          }
;;;497          if ((spi->info->state & SPI_POWERED)     != 0U) {
;;;498            return ARM_DRIVER_OK;
;;;499          }
;;;500    
;;;501          // Clear status flags
;;;502          spi->info->status.busy       = 0U;
;;;503          spi->info->status.data_lost  = 0U;
;;;504          spi->info->status.mode_fault = 0U;
;;;505    
;;;506          spi->xfer->def_val           = 0U;
;;;507    
;;;508          // Ready for operation - set powered flag
;;;509          spi->info->state |= SPI_POWERED;
;;;510    
;;;511          // Enable SPI clock
;;;512          if (spi->reg == SPI1) { RCC->APB2ENR |= RCC_APB2ENR_SPI1EN; }
;;;513    #if !defined(STM32F10X_LD) && !defined(STM32F10X_LD_VL)
;;;514          if (spi->reg == SPI2) { RCC->APB1ENR |= RCC_APB1ENR_SPI2EN; }
;;;515    #endif
;;;516    #if defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F10X_XL) || defined(STM32F10X_HD_VL)
;;;517          if (spi->reg == SPI3) { RCC->APB1ENR |= RCC_APB1ENR_SPI3EN; }
;;;518    #endif
;;;519    
;;;520          // SPI peripheral reset
;;;521          SPI_PeripheralReset (spi->reg);
;;;522    
;;;523          // Clear and Enable SPI IRQ
;;;524          NVIC_ClearPendingIRQ(spi->irq_num);
;;;525          NVIC_EnableIRQ(spi->irq_num);
;;;526          break;
;;;527    
;;;528        case ARM_POWER_LOW:
;;;529        default: return ARM_DRIVER_ERROR_UNSUPPORTED;
;;;530      }
;;;531      return ARM_DRIVER_OK;
;;;532    }
0000a6  bd70              POP      {r4-r6,pc}
                  |L19.168|
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;497
0000aa  79c0              LDRB     r0,[r0,#7]            ;497
0000ac  f0000002          AND      r0,r0,#2              ;497
0000b0  b108              CBZ      r0,|L19.182|
0000b2  2000              MOVS     r0,#0                 ;498
0000b4  e7f7              B        |L19.166|
                  |L19.182|
0000b6  2000              MOVS     r0,#0                 ;502
0000b8  6aa1              LDR      r1,[r4,#0x28]         ;502
0000ba  7108              STRB     r0,[r1,#4]            ;502
0000bc  2100              MOVS     r1,#0                 ;503
0000be  6aa0              LDR      r0,[r4,#0x28]         ;503
0000c0  7141              STRB     r1,[r0,#5]            ;503
0000c2  6aa0              LDR      r0,[r4,#0x28]         ;504
0000c4  7181              STRB     r1,[r0,#6]            ;504
0000c6  2000              MOVS     r0,#0                 ;506
0000c8  6ae1              LDR      r1,[r4,#0x2c]         ;506
0000ca  8308              STRH     r0,[r1,#0x18]         ;506
0000cc  6aa0              LDR      r0,[r4,#0x28]         ;509
0000ce  79c0              LDRB     r0,[r0,#7]            ;509
0000d0  f0400002          ORR      r0,r0,#2              ;509
0000d4  6aa1              LDR      r1,[r4,#0x28]         ;509
0000d6  71c8              STRB     r0,[r1,#7]            ;509
0000d8  4921              LDR      r1,|L19.352|
0000da  6820              LDR      r0,[r4,#0]            ;512
0000dc  4288              CMP      r0,r1                 ;512
0000de  d105              BNE      |L19.236|
0000e0  4820              LDR      r0,|L19.356|
0000e2  6980              LDR      r0,[r0,#0x18]         ;512
0000e4  f4405080          ORR      r0,r0,#0x1000         ;512
0000e8  491e              LDR      r1,|L19.356|
0000ea  6188              STR      r0,[r1,#0x18]         ;512
                  |L19.236|
0000ec  491e              LDR      r1,|L19.360|
0000ee  6820              LDR      r0,[r4,#0]            ;514
0000f0  4288              CMP      r0,r1                 ;514
0000f2  d105              BNE      |L19.256|
0000f4  481b              LDR      r0,|L19.356|
0000f6  69c0              LDR      r0,[r0,#0x1c]         ;514
0000f8  f4404080          ORR      r0,r0,#0x4000         ;514
0000fc  4919              LDR      r1,|L19.356|
0000fe  61c8              STR      r0,[r1,#0x1c]         ;514
                  |L19.256|
000100  6820              LDR      r0,[r4,#0]            ;521
000102  f7fffffe          BL       SPI_PeripheralReset
000106  e001              B        |L19.268|
                  |L19.264|
000108  e022              B        |L19.336|
                  |L19.266|
00010a  e020              B        |L19.334|
                  |L19.268|
00010c  f994001c          LDRSB    r0,[r4,#0x1c]         ;524
000110  2800              CMP      r0,#0                 ;524
000112  db07              BLT      |L19.292|
000114  f000011f          AND      r1,r0,#0x1f           ;524
000118  2201              MOVS     r2,#1                 ;524
00011a  408a              LSLS     r2,r2,r1              ;524
00011c  4913              LDR      r1,|L19.364|
00011e  0943              LSRS     r3,r0,#5              ;524
000120  f8412023          STR      r2,[r1,r3,LSL #2]     ;524
                  |L19.292|
000124  bf00              NOP                            ;524
000126  f994001c          LDRSB    r0,[r4,#0x1c]         ;525
00012a  2800              CMP      r0,#0                 ;525
00012c  db0d              BLT      |L19.330|
00012e  bf00              NOP                            ;525
000130  bf00              NOP                            ;525
000132  f000021f          AND      r2,r0,#0x1f           ;525
000136  2101              MOVS     r1,#1                 ;525
000138  4091              LSLS     r1,r1,r2              ;525
00013a  0942              LSRS     r2,r0,#5              ;525
00013c  0092              LSLS     r2,r2,#2              ;525
00013e  f10222e0          ADD      r2,r2,#0xe000e000     ;525
000142  f8c21100          STR      r1,[r2,#0x100]        ;525
000146  bf00              NOP                            ;525
000148  bf00              NOP                            ;525
                  |L19.330|
00014a  bf00              NOP                            ;525
00014c  e003              B        |L19.342|
                  |L19.334|
00014e  bf00              NOP                            ;528
                  |L19.336|
000150  f06f0003          MVN      r0,#3                 ;529
000154  e7a7              B        |L19.166|
                  |L19.342|
000156  bf00              NOP                            ;491
000158  2000              MOVS     r0,#0                 ;531
00015a  e7a4              B        |L19.166|
;;;533    
                          ENDP

                  |L19.348|
                          DCD      0xe000e180
                  |L19.352|
                          DCD      0x40013000
                  |L19.356|
                          DCD      0x40021000
                  |L19.360|
                          DCD      0x40003800
                  |L19.364|
                          DCD      0xe000e280

                          AREA ||i.SPI_Receive||, CODE, READONLY, ALIGN=1

                  SPI_Receive PROC
;;;642    */
;;;643    static int32_t SPI_Receive (void *data, uint32_t num, const SPI_RESOURCES *spi) {
000000  b510              PUSH     {r4,lr}
000002  4603              MOV      r3,r0
;;;644    #ifdef __SPI_DMA
;;;645      uint32_t cfg;
;;;646    #endif
;;;647    
;;;648      if ((data == NULL) || (num == 0U))             { return ARM_DRIVER_ERROR_PARAMETER; }
000004  b103              CBZ      r3,|L20.8|
000006  b911              CBNZ     r1,|L20.14|
                  |L20.8|
000008  f06f0004          MVN      r0,#4
                  |L20.12|
;;;649      if ((spi->info->state & SPI_CONFIGURED) == 0U) { return ARM_DRIVER_ERROR; }
;;;650      if ( spi->info->status.busy)                   { return ARM_DRIVER_ERROR_BUSY; }
;;;651    
;;;652      // Check if receive pin available
;;;653      if ((((spi->io.miso != NULL) && ((spi->info->mode & ARM_SPI_CONTROL_Msk) == ARM_SPI_MODE_MASTER)) ||
;;;654           ((spi->io.mosi != NULL) && ((spi->info->mode & ARM_SPI_CONTROL_Msk) == ARM_SPI_MODE_SLAVE ))) == 0U) {
;;;655        return ARM_DRIVER_ERROR;
;;;656      }
;;;657    
;;;658      // Update SPI statuses
;;;659      spi->info->status.busy       = 1U;
;;;660      spi->info->status.data_lost  = 0U;
;;;661      spi->info->status.mode_fault = 0U;
;;;662    
;;;663      // Save transfer info
;;;664      spi->xfer->rx_buf = (uint8_t *)data;
;;;665      spi->xfer->tx_buf = NULL;
;;;666      spi->xfer->num    = num;
;;;667      spi->xfer->rx_cnt = 0U;
;;;668      spi->xfer->tx_cnt = 0U;
;;;669    
;;;670    #ifdef __SPI_DMA_RX
;;;671      // DMA mode
;;;672      if (spi->rx_dma != NULL) {
;;;673        cfg = ((spi->rx_dma->priority << DMA_PRIORITY_POS) & DMA_PRIORITY_MASK) |
;;;674              DMA_PERIPHERAL_TO_MEMORY        |
;;;675              DMA_MEMORY_INCREMENT            |
;;;676              DMA_TRANSFER_COMPLETE_INTERRUPT ;
;;;677    
;;;678        if (spi->reg->CR1 & SPI_CR1_DFF) {
;;;679          // 16 - bit data frame
;;;680          cfg |= DMA_PERIPHERAL_DATA_16BIT | DMA_MEMORY_DATA_16BIT;
;;;681        } else {
;;;682          //  8 - bit data frame
;;;683          cfg |= DMA_PERIPHERAL_DATA_8BIT | DMA_MEMORY_DATA_8BIT;
;;;684        }
;;;685    
;;;686        DMA_ChannelConfigure(spi->rx_dma->instance,
;;;687                             cfg,
;;;688                             (uint32_t)(&spi->reg->DR),
;;;689                             (uint32_t)data,
;;;690                             num);
;;;691        DMA_ChannelEnable(spi->rx_dma->instance);
;;;692    
;;;693        // RX Buffer DMA enable
;;;694        spi->reg->CR2 |= SPI_CR2_RXDMAEN;
;;;695      } else
;;;696    #endif
;;;697      {
;;;698        // Interrupt mode
;;;699        // RX Buffer not empty interrupt enable
;;;700        spi->reg->CR2 |= SPI_CR2_RXNEIE;
;;;701      }
;;;702    
;;;703    #ifdef __SPI_DMA_TX
;;;704      // DMA mode
;;;705      if (spi->tx_dma != NULL) {
;;;706        cfg = ((spi->tx_dma->priority << DMA_PRIORITY_POS) & DMA_PRIORITY_MASK) |
;;;707              DMA_READ_MEMORY                |
;;;708              DMA_TRANSFER_COMPLETE_INTERRUPT;
;;;709    
;;;710        if (spi->reg->CR1 & SPI_CR1_DFF) {
;;;711          // 16 - bit data frame
;;;712          cfg |= DMA_PERIPHERAL_DATA_16BIT | DMA_MEMORY_DATA_16BIT;
;;;713        } else {
;;;714          //  8 - bit data frame
;;;715          cfg |= DMA_PERIPHERAL_DATA_8BIT | DMA_MEMORY_DATA_8BIT;
;;;716        }
;;;717    
;;;718        DMA_ChannelConfigure(spi->tx_dma->instance,
;;;719                             cfg,
;;;720                             (uint32_t)(&spi->reg->DR),
;;;721                             (uint32_t)(&spi->xfer->def_val),
;;;722                             num);
;;;723        DMA_ChannelEnable(spi->tx_dma->instance);
;;;724    
;;;725        // TX Buffer DMA enable
;;;726        spi->reg->CR2 |= SPI_CR2_TXDMAEN;
;;;727      } else
;;;728    #endif
;;;729      {
;;;730        // Interrupt mode
;;;731        // TX buffer empty interrupt enable
;;;732        spi->reg->CR2 |= SPI_CR2_TXEIE;
;;;733      }
;;;734    
;;;735      return ARM_DRIVER_OK;
;;;736    }
00000c  bd10              POP      {r4,pc}
                  |L20.14|
00000e  6a90              LDR      r0,[r2,#0x28]         ;649
000010  79c0              LDRB     r0,[r0,#7]            ;649
000012  f0000004          AND      r0,r0,#4              ;649
000016  b910              CBNZ     r0,|L20.30|
000018  f04f30ff          MOV      r0,#0xffffffff        ;649
00001c  e7f6              B        |L20.12|
                  |L20.30|
00001e  6a90              LDR      r0,[r2,#0x28]         ;650
000020  7900              LDRB     r0,[r0,#4]            ;650
000022  b110              CBZ      r0,|L20.42|
000024  f06f0001          MVN      r0,#1                 ;650
000028  e7f0              B        |L20.12|
                  |L20.42|
00002a  68d0              LDR      r0,[r2,#0xc]          ;653
00002c  b118              CBZ      r0,|L20.54|
00002e  6a90              LDR      r0,[r2,#0x28]         ;653
000030  7a00              LDRB     r0,[r0,#8]            ;653
000032  2801              CMP      r0,#1                 ;653
000034  d005              BEQ      |L20.66|
                  |L20.54|
000036  6890              LDR      r0,[r2,#8]            ;654
000038  b128              CBZ      r0,|L20.70|
00003a  6a90              LDR      r0,[r2,#0x28]         ;654
00003c  7a00              LDRB     r0,[r0,#8]            ;654
00003e  2802              CMP      r0,#2                 ;654
000040  d101              BNE      |L20.70|
                  |L20.66|
000042  2001              MOVS     r0,#1                 ;654
000044  e000              B        |L20.72|
                  |L20.70|
000046  2000              MOVS     r0,#0                 ;654
                  |L20.72|
000048  b910              CBNZ     r0,|L20.80|
00004a  f04f30ff          MOV      r0,#0xffffffff        ;655
00004e  e7dd              B        |L20.12|
                  |L20.80|
000050  2001              MOVS     r0,#1                 ;659
000052  6a94              LDR      r4,[r2,#0x28]         ;659
000054  7120              STRB     r0,[r4,#4]            ;659
000056  2400              MOVS     r4,#0                 ;660
000058  6a90              LDR      r0,[r2,#0x28]         ;660
00005a  7144              STRB     r4,[r0,#5]            ;660
00005c  6a90              LDR      r0,[r2,#0x28]         ;661
00005e  7184              STRB     r4,[r0,#6]            ;661
000060  6ad0              LDR      r0,[r2,#0x2c]         ;664
000062  6043              STR      r3,[r0,#4]            ;664
000064  2000              MOVS     r0,#0                 ;665
000066  6ad4              LDR      r4,[r2,#0x2c]         ;665
000068  60a0              STR      r0,[r4,#8]            ;665
00006a  6ad0              LDR      r0,[r2,#0x2c]         ;666
00006c  6001              STR      r1,[r0,#0]            ;666
00006e  2000              MOVS     r0,#0                 ;667
000070  6ad4              LDR      r4,[r2,#0x2c]         ;667
000072  60e0              STR      r0,[r4,#0xc]          ;667
000074  6ad4              LDR      r4,[r2,#0x2c]         ;668
000076  6120              STR      r0,[r4,#0x10]         ;668
000078  6810              LDR      r0,[r2,#0]            ;700
00007a  8880              LDRH     r0,[r0,#4]            ;700
00007c  f0400040          ORR      r0,r0,#0x40           ;700
000080  6814              LDR      r4,[r2,#0]            ;700
000082  80a0              STRH     r0,[r4,#4]            ;700
000084  6810              LDR      r0,[r2,#0]            ;732
000086  8880              LDRH     r0,[r0,#4]            ;732
000088  f0400080          ORR      r0,r0,#0x80           ;732
00008c  6814              LDR      r4,[r2,#0]            ;732
00008e  80a0              STRH     r0,[r4,#4]            ;732
000090  2000              MOVS     r0,#0                 ;735
000092  e7bb              B        |L20.12|
;;;737    
                          ENDP


                          AREA ||i.SPI_Send||, CODE, READONLY, ALIGN=1

                  SPI_Send PROC
;;;541    */
;;;542    static int32_t SPI_Send (const void *data, uint32_t num, const SPI_RESOURCES *spi) {
000000  b510              PUSH     {r4,lr}
000002  4603              MOV      r3,r0
;;;543    #ifdef __SPI_DMA
;;;544      uint32_t cfg;
;;;545    #endif
;;;546    
;;;547      if ((data == NULL) || (num == 0U))             { return ARM_DRIVER_ERROR_PARAMETER; }
000004  b103              CBZ      r3,|L21.8|
000006  b911              CBNZ     r1,|L21.14|
                  |L21.8|
000008  f06f0004          MVN      r0,#4
                  |L21.12|
;;;548      if ((spi->info->state & SPI_CONFIGURED) == 0U) { return ARM_DRIVER_ERROR; }
;;;549      if ( spi->info->status.busy)                   { return ARM_DRIVER_ERROR_BUSY; }
;;;550    
;;;551      // Check if transmit pin available
;;;552      if ((((spi->io.mosi != NULL) && ((spi->info->mode & ARM_SPI_CONTROL_Msk) == ARM_SPI_MODE_MASTER)) ||
;;;553           ((spi->io.miso != NULL) && ((spi->info->mode & ARM_SPI_CONTROL_Msk) == ARM_SPI_MODE_SLAVE ))) == 0U) {
;;;554        return ARM_DRIVER_ERROR;
;;;555      }
;;;556    
;;;557      // Update SPI statuses
;;;558      spi->info->status.busy       = 1U;
;;;559      spi->info->status.data_lost  = 0U;
;;;560      spi->info->status.mode_fault = 0U;
;;;561    
;;;562      // Save transfer info
;;;563      spi->xfer->rx_buf = NULL;
;;;564      spi->xfer->tx_buf = (uint8_t *)data;
;;;565      spi->xfer->num    = num;
;;;566      spi->xfer->rx_cnt = 0U;
;;;567      spi->xfer->tx_cnt = 0U;
;;;568    
;;;569    #ifdef __SPI_DMA_RX
;;;570      if (spi->rx_dma != NULL) {
;;;571        // Configure and enable rx DMA channel
;;;572        cfg = ((spi->rx_dma->priority << DMA_PRIORITY_POS) & DMA_PRIORITY_MASK) |
;;;573              DMA_PERIPHERAL_TO_MEMORY       |
;;;574              DMA_TRANSFER_COMPLETE_INTERRUPT;
;;;575    
;;;576        if (spi->reg->CR1 & SPI_CR1_DFF) {
;;;577          // 16 - bit data frame
;;;578          cfg |= DMA_PERIPHERAL_DATA_16BIT | DMA_MEMORY_DATA_16BIT;
;;;579        } else {
;;;580          //  8 - bit data frame
;;;581          cfg |= DMA_PERIPHERAL_DATA_8BIT | DMA_MEMORY_DATA_8BIT;
;;;582        }
;;;583    
;;;584        DMA_ChannelConfigure(spi->rx_dma->instance,
;;;585                             cfg,
;;;586                             (uint32_t)(&spi->reg->DR),
;;;587                             (uint32_t)(&spi->xfer->dump_val),
;;;588                             num);
;;;589        DMA_ChannelEnable(spi->rx_dma->instance);
;;;590    
;;;591        // RX Buffer DMA enable
;;;592        spi->reg->CR2 |= SPI_CR2_RXDMAEN;
;;;593      } else
;;;594    #endif
;;;595      {
;;;596        // Interrupt mode
;;;597        // RX Buffer not empty interrupt enable
;;;598        spi->reg->CR2 |= SPI_CR2_RXNEIE;
;;;599      }
;;;600    
;;;601    #ifdef __SPI_DMA_TX
;;;602      if (spi->tx_dma != NULL) {
;;;603        cfg = ((spi->tx_dma->priority << DMA_PRIORITY_POS) & DMA_PRIORITY_MASK) |
;;;604              DMA_READ_MEMORY                 |
;;;605              DMA_MEMORY_INCREMENT            |
;;;606              DMA_TRANSFER_COMPLETE_INTERRUPT ;
;;;607    
;;;608        if (spi->reg->CR1 & SPI_CR1_DFF) {
;;;609          // 16 - bit data frame
;;;610          cfg |= DMA_PERIPHERAL_DATA_16BIT | DMA_MEMORY_DATA_16BIT;
;;;611        } else {
;;;612          //  8 - bit data frame
;;;613          cfg |= DMA_PERIPHERAL_DATA_8BIT | DMA_MEMORY_DATA_8BIT;
;;;614        }
;;;615    
;;;616        DMA_ChannelConfigure(spi->tx_dma->instance,
;;;617                             cfg,
;;;618                             (uint32_t)&spi->reg->DR,
;;;619                             (uint32_t)data,
;;;620                             num);
;;;621        DMA_ChannelEnable(spi->tx_dma->instance);
;;;622    
;;;623        // TX Buffer DMA enable
;;;624        spi->reg->CR2 |= SPI_CR2_TXDMAEN;
;;;625      } else
;;;626    #endif
;;;627      {
;;;628        // Interrupt mode
;;;629        // TX Buffer empty interrupt enable
;;;630        spi->reg->CR2 |= SPI_CR2_TXEIE;
;;;631      }
;;;632      return ARM_DRIVER_OK;
;;;633    }
00000c  bd10              POP      {r4,pc}
                  |L21.14|
00000e  6a90              LDR      r0,[r2,#0x28]         ;548
000010  79c0              LDRB     r0,[r0,#7]            ;548
000012  f0000004          AND      r0,r0,#4              ;548
000016  b910              CBNZ     r0,|L21.30|
000018  f04f30ff          MOV      r0,#0xffffffff        ;548
00001c  e7f6              B        |L21.12|
                  |L21.30|
00001e  6a90              LDR      r0,[r2,#0x28]         ;549
000020  7900              LDRB     r0,[r0,#4]            ;549
000022  b110              CBZ      r0,|L21.42|
000024  f06f0001          MVN      r0,#1                 ;549
000028  e7f0              B        |L21.12|
                  |L21.42|
00002a  6890              LDR      r0,[r2,#8]            ;552
00002c  b118              CBZ      r0,|L21.54|
00002e  6a90              LDR      r0,[r2,#0x28]         ;552
000030  7a00              LDRB     r0,[r0,#8]            ;552
000032  2801              CMP      r0,#1                 ;552
000034  d005              BEQ      |L21.66|
                  |L21.54|
000036  68d0              LDR      r0,[r2,#0xc]          ;553
000038  b128              CBZ      r0,|L21.70|
00003a  6a90              LDR      r0,[r2,#0x28]         ;553
00003c  7a00              LDRB     r0,[r0,#8]            ;553
00003e  2802              CMP      r0,#2                 ;553
000040  d101              BNE      |L21.70|
                  |L21.66|
000042  2001              MOVS     r0,#1                 ;553
000044  e000              B        |L21.72|
                  |L21.70|
000046  2000              MOVS     r0,#0                 ;553
                  |L21.72|
000048  b910              CBNZ     r0,|L21.80|
00004a  f04f30ff          MOV      r0,#0xffffffff        ;554
00004e  e7dd              B        |L21.12|
                  |L21.80|
000050  2001              MOVS     r0,#1                 ;558
000052  6a94              LDR      r4,[r2,#0x28]         ;558
000054  7120              STRB     r0,[r4,#4]            ;558
000056  2400              MOVS     r4,#0                 ;559
000058  6a90              LDR      r0,[r2,#0x28]         ;559
00005a  7144              STRB     r4,[r0,#5]            ;559
00005c  6a90              LDR      r0,[r2,#0x28]         ;560
00005e  7184              STRB     r4,[r0,#6]            ;560
000060  2000              MOVS     r0,#0                 ;563
000062  6ad4              LDR      r4,[r2,#0x2c]         ;563
000064  6060              STR      r0,[r4,#4]            ;563
000066  6ad0              LDR      r0,[r2,#0x2c]         ;564
000068  6083              STR      r3,[r0,#8]            ;564
00006a  6ad0              LDR      r0,[r2,#0x2c]         ;565
00006c  6001              STR      r1,[r0,#0]            ;565
00006e  2000              MOVS     r0,#0                 ;566
000070  6ad4              LDR      r4,[r2,#0x2c]         ;566
000072  60e0              STR      r0,[r4,#0xc]          ;566
000074  6ad4              LDR      r4,[r2,#0x2c]         ;567
000076  6120              STR      r0,[r4,#0x10]         ;567
000078  6810              LDR      r0,[r2,#0]            ;598
00007a  8880              LDRH     r0,[r0,#4]            ;598
00007c  f0400040          ORR      r0,r0,#0x40           ;598
000080  6814              LDR      r4,[r2,#0]            ;598
000082  80a0              STRH     r0,[r4,#4]            ;598
000084  6810              LDR      r0,[r2,#0]            ;630
000086  8880              LDRH     r0,[r0,#4]            ;630
000088  f0400080          ORR      r0,r0,#0x80           ;630
00008c  6814              LDR      r4,[r2,#0]            ;630
00008e  80a0              STRH     r0,[r4,#4]            ;630
000090  2000              MOVS     r0,#0                 ;632
000092  e7bb              B        |L21.12|
;;;634    
                          ENDP


                          AREA ||i.SPI_Transfer||, CODE, READONLY, ALIGN=1

                  SPI_Transfer PROC
;;;746    */
;;;747    static int32_t SPI_Transfer (const void *data_out, void *data_in, uint32_t num, const SPI_RESOURCES *spi) {
000000  b530              PUSH     {r4,r5,lr}
000002  4604              MOV      r4,r0
;;;748    #ifdef __SPI_DMA
;;;749      uint32_t cfg;
;;;750    #endif
;;;751    
;;;752      if ((data_out == NULL) || (data_in == NULL) || (num == 0U)) { return ARM_DRIVER_ERROR_PARAMETER; }
000004  b10c              CBZ      r4,|L22.10|
000006  b101              CBZ      r1,|L22.10|
000008  b912              CBNZ     r2,|L22.16|
                  |L22.10|
00000a  f06f0004          MVN      r0,#4
                  |L22.14|
;;;753      if ((spi->info->state & SPI_CONFIGURED) == 0U)              { return ARM_DRIVER_ERROR; }
;;;754      if ( spi->info->status.busy)                                { return ARM_DRIVER_ERROR_BUSY; }
;;;755    
;;;756      // Check if receive and transmit pins available
;;;757      if ((spi->io.miso == NULL) || (spi->io.mosi == NULL)) {
;;;758        return ARM_DRIVER_ERROR;
;;;759      }
;;;760    
;;;761      // Update SPI statuses
;;;762      spi->info->status.busy       = 1U;
;;;763      spi->info->status.data_lost  = 0U;
;;;764      spi->info->status.mode_fault = 0U;
;;;765    
;;;766      // Save transfer info
;;;767      spi->xfer->rx_buf = (uint8_t *)data_in;
;;;768      spi->xfer->tx_buf = (uint8_t *)data_out;
;;;769      spi->xfer->num    = num;
;;;770      spi->xfer->rx_cnt = 0U;
;;;771      spi->xfer->tx_cnt = 0U;
;;;772    
;;;773    #ifdef __SPI_DMA
;;;774      if ((spi->rx_dma != NULL) || (spi->tx_dma != NULL)) {
;;;775        // DMA mode
;;;776    
;;;777        if (spi->rx_dma != NULL) {
;;;778          cfg = ((spi->rx_dma->priority << DMA_PRIORITY_POS) & DMA_PRIORITY_MASK) |
;;;779                DMA_PERIPHERAL_TO_MEMORY       |
;;;780                DMA_MEMORY_INCREMENT           |
;;;781                DMA_TRANSFER_COMPLETE_INTERRUPT;
;;;782    
;;;783          if (spi->reg->CR1 & SPI_CR1_DFF) {
;;;784            // 16 - bit data frame
;;;785            cfg |= DMA_PERIPHERAL_DATA_16BIT | DMA_MEMORY_DATA_16BIT;
;;;786          } else {
;;;787            //  8 - bit data frame
;;;788            cfg |= DMA_PERIPHERAL_DATA_8BIT | DMA_MEMORY_DATA_8BIT;
;;;789          }
;;;790    
;;;791          DMA_ChannelConfigure(spi->rx_dma->instance,
;;;792                              cfg,
;;;793                              (uint32_t)(&spi->reg->DR),
;;;794                              (uint32_t)data_in,
;;;795                              num);
;;;796          DMA_ChannelEnable(spi->rx_dma->instance);
;;;797    
;;;798          // RX Buffer DMA enable
;;;799          spi->reg->CR2 |= SPI_CR2_RXDMAEN;
;;;800        }
;;;801    
;;;802        if (spi->tx_dma != NULL) {
;;;803          cfg = ((spi->tx_dma->priority << DMA_PRIORITY_POS) & DMA_PRIORITY_MASK) |
;;;804                DMA_READ_MEMORY                |
;;;805                DMA_MEMORY_INCREMENT           |
;;;806                DMA_TRANSFER_COMPLETE_INTERRUPT;
;;;807    
;;;808          DMA_ChannelConfigure(spi->tx_dma->instance,
;;;809                               cfg,
;;;810                               (uint32_t)(&spi->reg->DR),
;;;811                               (uint32_t)data_out,
;;;812                               num);
;;;813          DMA_ChannelEnable(spi->tx_dma->instance);
;;;814    
;;;815          // TX Buffer DMA enable
;;;816          spi->reg->CR2 |= SPI_CR2_TXDMAEN;
;;;817        }
;;;818      } else
;;;819    #endif
;;;820      {
;;;821        // Interrupt mode
;;;822        // TX Buffer empty and RX Buffer not empty interrupt enable
;;;823        spi->reg->CR2 |= SPI_CR2_RXNEIE | SPI_CR2_TXEIE;
;;;824      }
;;;825    
;;;826      return ARM_DRIVER_OK;
;;;827    }
00000e  bd30              POP      {r4,r5,pc}
                  |L22.16|
000010  6a98              LDR      r0,[r3,#0x28]         ;753
000012  79c0              LDRB     r0,[r0,#7]            ;753
000014  f0000004          AND      r0,r0,#4              ;753
000018  b910              CBNZ     r0,|L22.32|
00001a  f04f30ff          MOV      r0,#0xffffffff        ;753
00001e  e7f6              B        |L22.14|
                  |L22.32|
000020  6a98              LDR      r0,[r3,#0x28]         ;754
000022  7900              LDRB     r0,[r0,#4]            ;754
000024  b110              CBZ      r0,|L22.44|
000026  f06f0001          MVN      r0,#1                 ;754
00002a  e7f0              B        |L22.14|
                  |L22.44|
00002c  68d8              LDR      r0,[r3,#0xc]          ;757
00002e  b108              CBZ      r0,|L22.52|
000030  6898              LDR      r0,[r3,#8]            ;757
000032  b910              CBNZ     r0,|L22.58|
                  |L22.52|
000034  f04f30ff          MOV      r0,#0xffffffff        ;758
000038  e7e9              B        |L22.14|
                  |L22.58|
00003a  2001              MOVS     r0,#1                 ;762
00003c  6a9d              LDR      r5,[r3,#0x28]         ;762
00003e  7128              STRB     r0,[r5,#4]            ;762
000040  2500              MOVS     r5,#0                 ;763
000042  6a98              LDR      r0,[r3,#0x28]         ;763
000044  7145              STRB     r5,[r0,#5]            ;763
000046  6a98              LDR      r0,[r3,#0x28]         ;764
000048  7185              STRB     r5,[r0,#6]            ;764
00004a  6ad8              LDR      r0,[r3,#0x2c]         ;767
00004c  6041              STR      r1,[r0,#4]            ;767
00004e  6ad8              LDR      r0,[r3,#0x2c]         ;768
000050  6084              STR      r4,[r0,#8]            ;768
000052  6ad8              LDR      r0,[r3,#0x2c]         ;769
000054  6002              STR      r2,[r0,#0]            ;769
000056  2000              MOVS     r0,#0                 ;770
000058  6add              LDR      r5,[r3,#0x2c]         ;770
00005a  60e8              STR      r0,[r5,#0xc]          ;770
00005c  6add              LDR      r5,[r3,#0x2c]         ;771
00005e  6128              STR      r0,[r5,#0x10]         ;771
000060  6818              LDR      r0,[r3,#0]            ;823
000062  8880              LDRH     r0,[r0,#4]            ;823
000064  f04000c0          ORR      r0,r0,#0xc0           ;823
000068  681d              LDR      r5,[r3,#0]            ;823
00006a  80a8              STRH     r0,[r5,#4]            ;823
00006c  2000              MOVS     r0,#0                 ;826
00006e  e7ce              B        |L22.14|
;;;828    
                          ENDP


                          AREA ||i.SPI_Uninitialize||, CODE, READONLY, ALIGN=1

                  SPI_Uninitialize PROC
;;;423    */
;;;424    static int32_t SPI_Uninitialize (const SPI_RESOURCES *spi) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;425    
;;;426      // Uninitialize SPI pins
;;;427      GPIO_PinConfigure (spi->io.sck->port, spi->io.sck->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
000004  6962              LDR      r2,[r4,#0x14]
000006  2300              MOVS     r3,#0
000008  ca03              LDM      r2!,{r0,r1}
00000a  461a              MOV      r2,r3
00000c  f7fffffe          BL       GPIO_PinConfigure
;;;428    
;;;429      if (spi->io.miso != NULL) {
000010  68e0              LDR      r0,[r4,#0xc]
000012  b128              CBZ      r0,|L23.32|
;;;430        GPIO_PinConfigure (spi->io.miso->port, spi->io.miso->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
000014  68e2              LDR      r2,[r4,#0xc]
000016  2300              MOVS     r3,#0
000018  ca03              LDM      r2!,{r0,r1}
00001a  461a              MOV      r2,r3
00001c  f7fffffe          BL       GPIO_PinConfigure
                  |L23.32|
;;;431      }
;;;432      if (spi->io.mosi != NULL) {
000020  68a0              LDR      r0,[r4,#8]
000022  b128              CBZ      r0,|L23.48|
;;;433        GPIO_PinConfigure (spi->io.mosi->port, spi->io.mosi->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
000024  68a2              LDR      r2,[r4,#8]
000026  2300              MOVS     r3,#0
000028  ca03              LDM      r2!,{r0,r1}
00002a  461a              MOV      r2,r3
00002c  f7fffffe          BL       GPIO_PinConfigure
                  |L23.48|
;;;434      }
;;;435      if (spi->io.nss != NULL) {
000030  6920              LDR      r0,[r4,#0x10]
000032  b128              CBZ      r0,|L23.64|
;;;436        GPIO_PinConfigure (spi->io.nss->port, spi->io.nss->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
000034  6922              LDR      r2,[r4,#0x10]
000036  2300              MOVS     r3,#0
000038  ca03              LDM      r2!,{r0,r1}
00003a  461a              MOV      r2,r3
00003c  f7fffffe          BL       GPIO_PinConfigure
                  |L23.64|
;;;437      }
;;;438    
;;;439      // Uncofigure pin remapping
;;;440      GPIO_AFConfigure(spi->io.afio_def);
000040  8b20              LDRH     r0,[r4,#0x18]
000042  f7fffffe          BL       GPIO_AFConfigure
;;;441    
;;;442    #ifdef __SPI_DMA
;;;443      if ((spi->rx_dma != NULL) || (spi->tx_dma != NULL)) {
;;;444        if (spi->rx_dma != NULL) {
;;;445          DMA_ChannelUninitialize (spi->rx_dma->dma_num, spi->rx_dma->ch_num);
;;;446        }
;;;447        if (spi->tx_dma != NULL) {
;;;448          DMA_ChannelUninitialize (spi->tx_dma->dma_num, spi->tx_dma->ch_num);
;;;449        }
;;;450      }
;;;451    #endif
;;;452    
;;;453      // Clear SPI state
;;;454      spi->info->state = 0U;
000046  2000              MOVS     r0,#0
000048  6aa1              LDR      r1,[r4,#0x28]
00004a  71c8              STRB     r0,[r1,#7]
;;;455    
;;;456      return ARM_DRIVER_OK;
;;;457    }
00004c  bd10              POP      {r4,pc}
;;;458    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  SPI1_Info
                          %        12
                  SPI1_TransferInfo
                          %        28

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  DriverVersion
000000  02020202          DCW      0x0202,0x0202
                  DriverCapabilities
000004  08000000          DCB      0x08,0x00,0x00,0x00
                  SPI1_mosi
                          DCD      0x40010800
                          DCD      0x00000007
                  SPI1_miso
                          DCD      0x40010800
                          DCD      0x00000006
                  SPI1_nss
                          DCD      0x40010800
                          DCD      0x00000004
                  SPI1_sck
                          DCD      0x40010800
                          DCD      0x00000005
                  SPI1_Resources
                          DCD      0x40013000
                          DCD      0x044aa200
                          DCD      SPI1_mosi
                          DCD      SPI1_miso
                          DCD      SPI1_nss
                          DCD      SPI1_sck
000040  00200020          DCW      0x0020,0x0020
000044  23000000          DCB      0x23,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      SPI1_Info
                          DCD      SPI1_TransferInfo
                  Driver_SPI1
                          DCD      SPIX_GetVersion
                          DCD      SPIX_GetCapabilities
                          DCD      SPI1_Initialize
                          DCD      SPI1_Uninitialize
                          DCD      SPI1_PowerControl
                          DCD      SPI1_Send
                          DCD      SPI1_Receive
                          DCD      SPI1_Transfer
                          DCD      SPI1_GetDataCount
                          DCD      SPI1_Control
                          DCD      SPI1_GetStatus

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\STM32F1xx_DFP\\2.3.0\\RTE_Driver\\SPI_STM32F10x.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_SPI_STM32F10x_c_a316419e____REV16|
#line 492 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_SPI_STM32F10x_c_a316419e____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_SPI_STM32F10x_c_a316419e____REVSH|
#line 507
|__asm___15_SPI_STM32F10x_c_a316419e____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_SPI_STM32F10x_c_a316419e____RRX|
#line 694
|__asm___15_SPI_STM32F10x_c_a316419e____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
