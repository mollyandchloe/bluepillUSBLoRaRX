; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\radio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\radio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTE\Device\STM32F103C8 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Driver\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\RTOS\RTX\INC -IC:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\StdPeriph_Driver\inc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\RTE_Driver -D__RTX -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_MD -W --omf_browse=.\objects\radio.crf Radio.c]
                          THUMB

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;20     
;;;21     void Delay (unsigned long tick){
000000  f04f22e0          MOV      r2,#0xe000e000
;;;22     	unsigned long systickcnt;
;;;23     	
;;;24     	systickcnt = SysTick->VAL;
000004  6991              LDR      r1,[r2,#0x18]
;;;25     	while((SysTick->VAL - systickcnt ) < tick);
000006  bf00              NOP      
                  |L1.8|
000008  f04f22e0          MOV      r2,#0xe000e000
00000c  6992              LDR      r2,[r2,#0x18]
00000e  1a52              SUBS     r2,r2,r1
000010  4282              CMP      r2,r0
000012  d3f9              BCC      |L1.8|
;;;26     }
000014  4770              BX       lr
;;;27     
                          ENDP


                          AREA ||i.RadioRX||, CODE, READONLY, ALIGN=2

                  RadioRX PROC
;;;271    
;;;272    void RadioRX( void ){
000000  b53e              PUSH     {r1-r5,lr}
;;;273    
;;;274    		RadioSendByte(0x81, 0x01);	//Standby Mode
000002  2101              MOVS     r1,#1
000004  2081              MOVS     r0,#0x81
000006  f7fffffe          BL       RadioSendByte
;;;275    		osDelay(shortDelay);
00000a  2064              MOVS     r0,#0x64
00000c  f7fffffe          BL       osDelay
;;;276    		RadioSendByte(0x92, 0xFF);	// Clear the interrupt flags!
000010  21ff              MOVS     r1,#0xff
000012  2092              MOVS     r0,#0x92
000014  f7fffffe          BL       RadioSendByte
;;;277    		osDelay(shortDelay);
000018  2064              MOVS     r0,#0x64
00001a  f7fffffe          BL       osDelay
;;;278    		RadioSendByte(0x92, 0xFF);
00001e  21ff              MOVS     r1,#0xff
000020  2092              MOVS     r0,#0x92
000022  f7fffffe          BL       RadioSendByte
;;;279    		
;;;280    		RadioSendByte(0x81, 0x05);	// Continious recieve mode
000026  2105              MOVS     r1,#5
000028  2081              MOVS     r0,#0x81
00002a  f7fffffe          BL       RadioSendByte
;;;281    	
;;;282    		RadioSendByte(0xC0, 0x40);
00002e  2140              MOVS     r1,#0x40
000030  20c0              MOVS     r0,#0xc0
000032  f7fffffe          BL       RadioSendByte
;;;283    		
;;;284    		// NEED CODE TO WAIT ON D0 Asseted!
;;;285    		uint32_t pinstate = GPIO_PinRead( GPIOA, 2); //Read the start DIO value
000036  2002              MOVS     r0,#2
000038  4923              LDR      r1,|L2.200|
00003a  6889              LDR      r1,[r1,#8]
00003c  40c1              LSRS     r1,r1,r0
00003e  f0010101          AND      r1,r1,#1
000042  460c              MOV      r4,r1
;;;286    		while( pinstate == GPIO_PinRead( GPIOA, 2)){} // Wait for it to change
000044  bf00              NOP      
                  |L2.70|
000046  2002              MOVS     r0,#2
000048  491f              LDR      r1,|L2.200|
00004a  6889              LDR      r1,[r1,#8]
00004c  40c1              LSRS     r1,r1,r0
00004e  f0010101          AND      r1,r1,#1
000052  42a1              CMP      r1,r4
000054  d0f7              BEQ      |L2.70|
;;;287    
;;;288    		RadioSendByte(0x12, 0x00);	// Read the interrupt flags - expect 0x50 - Rx Done, Valid Header
000056  2100              MOVS     r1,#0
000058  2012              MOVS     r0,#0x12
00005a  f7fffffe          BL       RadioSendByte
;;;289    		RadioSendByte(0x1C, 0x00);	// Read expect 0x40 - CRC on?
00005e  2100              MOVS     r1,#0
000060  201c              MOVS     r0,#0x1c
000062  f7fffffe          BL       RadioSendByte
;;;290    		
;;;291    		RadioSendByte(0x13, 0x00);	// Read no of bytes in packet payload
000066  2100              MOVS     r1,#0
000068  2013              MOVS     r0,#0x13
00006a  f7fffffe          BL       RadioSendByte
;;;292    		
;;;293    		RadioSendByte(0x10, 0xFF);	// Get the FIFO Address of packet
00006e  21ff              MOVS     r1,#0xff
000070  2010              MOVS     r0,#0x10
000072  f7fffffe          BL       RadioSendByte
;;;294    		
;;;295    		RadioSendByte(0x8D, 0x00);  // Write the packet address
000076  2100              MOVS     r1,#0
000078  208d              MOVS     r0,#0x8d
00007a  f7fffffe          BL       RadioSendByte
;;;296    		
;;;297    		uint8_t readmessage[10]={ 0x00 };
00007e  2000              MOVS     r0,#0
000080  9000              STR      r0,[sp,#0]
000082  9001              STR      r0,[sp,#4]
000084  9002              STR      r0,[sp,#8]
;;;298    		SendToRadio(readmessage, sizeof(readmessage));
000086  210a              MOVS     r1,#0xa
000088  4668              MOV      r0,sp
00008a  f7fffffe          BL       SendToRadio
;;;299    		
;;;300    		
;;;301    		RadioSendByte(0x92, 0xFF);	// Clear the IRQ
00008e  21ff              MOVS     r1,#0xff
000090  2092              MOVS     r0,#0x92
000092  f7fffffe          BL       RadioSendByte
;;;302    		RadioSendByte(0x19, 0x00);	// Get the SNR
000096  2100              MOVS     r1,#0
000098  2019              MOVS     r0,#0x19
00009a  f7fffffe          BL       RadioSendByte
;;;303    		RadioSendByte(0x1A, 0x00);	// Get the RSSI value
00009e  2100              MOVS     r1,#0
0000a0  201a              MOVS     r0,#0x1a
0000a2  f7fffffe          BL       RadioSendByte
;;;304    		RadioSendByte(0x10, 0xFF);
0000a6  21ff              MOVS     r1,#0xff
0000a8  2010              MOVS     r0,#0x10
0000aa  f7fffffe          BL       RadioSendByte
;;;305    		RadioSendByte(0x81, 0x01);	// Standby mode
0000ae  2101              MOVS     r1,#1
0000b0  2081              MOVS     r0,#0x81
0000b2  f7fffffe          BL       RadioSendByte
;;;306    		RadioSendByte(0x92, 0xFF);	// Clear the IRQ
0000b6  21ff              MOVS     r1,#0xff
0000b8  2092              MOVS     r0,#0x92
0000ba  f7fffffe          BL       RadioSendByte
;;;307    		RadioSendByte(0x92, 0xFF);	// Clear the IRQ
0000be  21ff              MOVS     r1,#0xff
0000c0  2092              MOVS     r0,#0x92
0000c2  f7fffffe          BL       RadioSendByte
;;;308    		
;;;309    		
;;;310    }
0000c6  bd3e              POP      {r1-r5,pc}
;;;311    
                          ENDP

                  |L2.200|
                          DCD      0x40010800

                          AREA ||i.RadioSendByte||, CODE, READONLY, ALIGN=1

                  RadioSendByte PROC
;;;322    
;;;323    int32_t RadioSendByte(uint8_t Byte, uint8_t Address){
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;324    		uint8_t thedata[2]={Byte, Address};
000006  f88d4000          STRB     r4,[sp,#0]
00000a  f88d5001          STRB     r5,[sp,#1]
;;;325    		SendToRadio(thedata, 2);
00000e  2102              MOVS     r1,#2
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       SendToRadio
;;;326    }
000016  bd38              POP      {r3-r5,pc}
;;;327    
                          ENDP


                          AREA ||i.SendToRadio||, CODE, READONLY, ALIGN=2

                  SendToRadio PROC
;;;313    
;;;314    int32_t	SendToRadio(const void *data, uint32_t num){
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;315    	
;;;316    			ARM_DRIVER_SPI* SPIdrv = &Driver_SPI1;		//Get a handle to the driver
000006  4c0b              LDR      r4,|L4.52|
;;;317    			SPIdrv->Control(ARM_SPI_CONTROL_SS, ARM_SPI_SS_ACTIVE);
000008  2101              MOVS     r1,#1
00000a  2013              MOVS     r0,#0x13
00000c  6a62              LDR      r2,[r4,#0x24]
00000e  4790              BLX      r2
;;;318    			SPIdrv->Send(data, num);
000010  4631              MOV      r1,r6
000012  4628              MOV      r0,r5
000014  6962              LDR      r2,[r4,#0x14]
000016  4790              BLX      r2
;;;319    			while(SPIdrv->GetStatus().busy == 1); // Wait for data to be sent.
000018  bf00              NOP      
                  |L4.26|
00001a  6aa0              LDR      r0,[r4,#0x28]
00001c  4780              BLX      r0
00001e  9000              STR      r0,[sp,#0]
000020  f0000001          AND      r0,r0,#1
000024  2800              CMP      r0,#0
000026  d1f8              BNE      |L4.26|
;;;320    			SPIdrv->Control(ARM_SPI_CONTROL_SS, ARM_SPI_SS_INACTIVE);
000028  2100              MOVS     r1,#0
00002a  2013              MOVS     r0,#0x13
00002c  6a62              LDR      r2,[r4,#0x24]
00002e  4790              BLX      r2
;;;321    }
000030  bdf8              POP      {r3-r7,pc}
;;;322    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      Driver_SPI1

                          AREA ||i.initialiseRadio||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  initialiseRadio PROC
;;;58     
;;;59     uint32_t initialiseRadio( void ){
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  b086              SUB      sp,sp,#0x18
;;;60     	
;;;61     		//printf("Setting up the radio\n");
;;;62     	
;;;63         //Set up the GPIO for Radio Reset Pin
;;;64         GPIO_PortClock   (GPIOA, true);
000006  2101              MOVS     r1,#1
000008  48af              LDR      r0,|L5.712|
00000a  f7fffffe          BL       GPIO_PortClock
;;;65         GPIO_PinWrite    (GPIOA, 3, 1);
00000e  2003              MOVS     r0,#3
000010  2101              MOVS     r1,#1
000012  b121              CBZ      r1,|L5.30|
000014  2201              MOVS     r2,#1
000016  4082              LSLS     r2,r2,r0
000018  4bab              LDR      r3,|L5.712|
00001a  611a              STR      r2,[r3,#0x10]
00001c  e005              B        |L5.42|
                  |L5.30|
00001e  f1000210          ADD      r2,r0,#0x10
000022  2301              MOVS     r3,#1
000024  4093              LSLS     r3,r3,r2
000026  4aa8              LDR      r2,|L5.712|
000028  6113              STR      r3,[r2,#0x10]
                  |L5.42|
00002a  bf00              NOP      
;;;66         GPIO_PinConfigure(GPIOA, 3,
00002c  2302              MOVS     r3,#2
00002e  2200              MOVS     r2,#0
000030  2103              MOVS     r1,#3
000032  48a5              LDR      r0,|L5.712|
000034  f7fffffe          BL       GPIO_PinConfigure
;;;67                           GPIO_OUT_PUSH_PULL,
;;;68                           GPIO_MODE_OUT2MHZ);
;;;69     	
;;;70     			//Set up the GPIO for DIO0 signal
;;;71     	
;;;72         GPIO_PortClock   (GPIOA, true);
000038  2101              MOVS     r1,#1
00003a  48a3              LDR      r0,|L5.712|
00003c  f7fffffe          BL       GPIO_PortClock
;;;73         GPIO_PinConfigure(GPIOA, 2,
000040  2300              MOVS     r3,#0
000042  2203              MOVS     r2,#3
000044  2102              MOVS     r1,#2
000046  48a0              LDR      r0,|L5.712|
000048  f7fffffe          BL       GPIO_PinConfigure
;;;74                           GPIO_IN_PULL_UP,
;;;75                           GPIO_MODE_INPUT);
;;;76     
;;;77     	
;;;78     	
;;;79     	//Set up the SPI
;;;80     	ARM_DRIVER_SPI* SPIdrv = &Driver_SPI1;		//Get a handle to the driver
00004c  4c9f              LDR      r4,|L5.716|
;;;81     	
;;;82     	ARM_DRIVER_VERSION version;
;;;83     	ARM_SPI_CAPABILITIES drv_capabilities;	
;;;84     	version = SPIdrv->GetVersion();
00004e  6820              LDR      r0,[r4,#0]
000050  4780              BLX      r0
000052  9005              STR      r0,[sp,#0x14]
;;;85     	drv_capabilities = SPIdrv->GetCapabilities();	//Useful for debugging
000054  6860              LDR      r0,[r4,#4]
000056  4780              BLX      r0
000058  9004              STR      r0,[sp,#0x10]
;;;86     	
;;;87     	/* Initialize the SPI driver */
;;;88         SPIdrv->Initialize(mySPI_callback);
00005a  489d              LDR      r0,|L5.720|
00005c  68a1              LDR      r1,[r4,#8]
00005e  4788              BLX      r1
;;;89         /* Power up the SPI peripheral */
;;;90         SPIdrv->PowerControl(ARM_POWER_FULL);
000060  2002              MOVS     r0,#2
000062  6921              LDR      r1,[r4,#0x10]
000064  4788              BLX      r1
;;;91         /* Configure the SPI to Master, 8-bit mode @1000 kBits/sec */
;;;92         SPIdrv->Control(ARM_SPI_MODE_MASTER | ARM_SPI_CPOL0_CPHA0 | ARM_SPI_MSB_LSB | ARM_SPI_SS_MASTER_SW | ARM_SPI_DATA_BITS(8), 1000000);
000066  499b              LDR      r1,|L5.724|
000068  489b              LDR      r0,|L5.728|
00006a  6a62              LDR      r2,[r4,#0x24]
00006c  4790              BLX      r2
;;;93         SPIdrv->Control(ARM_SPI_CONTROL_SS, ARM_SPI_SS_INACTIVE);
00006e  2100              MOVS     r1,#0
000070  2013              MOVS     r0,#0x13
000072  6a62              LDR      r2,[r4,#0x24]
000074  4790              BLX      r2
;;;94     
;;;95     	
;;;96     	printf("Reseting...\n");
000076  a099              ADR      r0,|L5.732|
000078  f7fffffe          BL       __2printf
;;;97     	// Do a RFM95 Reset!
;;;98     		osDelay(100);
00007c  2064              MOVS     r0,#0x64
00007e  f7fffffe          BL       osDelay
;;;99     		GPIO_PinWrite    (GPIOA, 3, 0);	// Make sure it is low for reset!
000082  2003              MOVS     r0,#3
000084  2100              MOVS     r1,#0
000086  b121              CBZ      r1,|L5.146|
000088  2201              MOVS     r2,#1
00008a  4082              LSLS     r2,r2,r0
00008c  4b8e              LDR      r3,|L5.712|
00008e  611a              STR      r2,[r3,#0x10]
000090  e005              B        |L5.158|
                  |L5.146|
000092  f1000210          ADD      r2,r0,#0x10
000096  2301              MOVS     r3,#1
000098  4093              LSLS     r3,r3,r2
00009a  4a8b              LDR      r2,|L5.712|
00009c  6113              STR      r3,[r2,#0x10]
                  |L5.158|
00009e  bf00              NOP      
;;;100    		GPIO_PinWrite    (GPIOC, 13, 0);	//Led on
0000a0  200d              MOVS     r0,#0xd
0000a2  2100              MOVS     r1,#0
0000a4  b121              CBZ      r1,|L5.176|
0000a6  2201              MOVS     r2,#1
0000a8  4082              LSLS     r2,r2,r0
0000aa  4b90              LDR      r3,|L5.748|
0000ac  611a              STR      r2,[r3,#0x10]
0000ae  e005              B        |L5.188|
                  |L5.176|
0000b0  f1000210          ADD      r2,r0,#0x10
0000b4  2301              MOVS     r3,#1
0000b6  4093              LSLS     r3,r3,r2
0000b8  4a8c              LDR      r2,|L5.748|
0000ba  6113              STR      r3,[r2,#0x10]
                  |L5.188|
0000bc  bf00              NOP      
;;;101    		osDelay(100);
0000be  2064              MOVS     r0,#0x64
0000c0  f7fffffe          BL       osDelay
;;;102    		GPIO_PinWrite    (GPIOC, 13, 1); //LED off
0000c4  200d              MOVS     r0,#0xd
0000c6  2101              MOVS     r1,#1
0000c8  b121              CBZ      r1,|L5.212|
0000ca  2201              MOVS     r2,#1
0000cc  4082              LSLS     r2,r2,r0
0000ce  4b87              LDR      r3,|L5.748|
0000d0  611a              STR      r2,[r3,#0x10]
0000d2  e005              B        |L5.224|
                  |L5.212|
0000d4  f1000210          ADD      r2,r0,#0x10
0000d8  2301              MOVS     r3,#1
0000da  4093              LSLS     r3,r3,r2
0000dc  4a83              LDR      r2,|L5.748|
0000de  6113              STR      r3,[r2,#0x10]
                  |L5.224|
0000e0  bf00              NOP      
;;;103    		GPIO_PinWrite    (GPIOA, 3, 1);	// Bring high to enable chip
0000e2  2003              MOVS     r0,#3
0000e4  2101              MOVS     r1,#1
0000e6  b121              CBZ      r1,|L5.242|
0000e8  2201              MOVS     r2,#1
0000ea  4082              LSLS     r2,r2,r0
0000ec  4b76              LDR      r3,|L5.712|
0000ee  611a              STR      r2,[r3,#0x10]
0000f0  e005              B        |L5.254|
                  |L5.242|
0000f2  f1000210          ADD      r2,r0,#0x10
0000f6  2301              MOVS     r3,#1
0000f8  4093              LSLS     r3,r3,r2
0000fa  4a73              LDR      r2,|L5.712|
0000fc  6113              STR      r3,[r2,#0x10]
                  |L5.254|
0000fe  bf00              NOP      
;;;104    		osDelay(100);
000100  2064              MOVS     r0,#0x64
000102  f7fffffe          BL       osDelay
;;;105    		
;;;106    	printf("Reset Complete, configuring radio\n");
000106  a07a              ADR      r0,|L5.752|
000108  f7fffffe          BL       __2printf
;;;107        
;;;108    		RadioSendByte(0x81, 0x80); // Sleep mode, into Lora Mode
00010c  2180              MOVS     r1,#0x80
00010e  2081              MOVS     r0,#0x81
000110  f7fffffe          BL       RadioSendByte
;;;109    		osDelay(100);
000114  2064              MOVS     r0,#0x64
000116  f7fffffe          BL       osDelay
;;;110    		
;;;111    		RadioSendByte(0x81, 0x80); // Sleep mode, into Lora Mode
00011a  2180              MOVS     r1,#0x80
00011c  2081              MOVS     r0,#0x81
00011e  f7fffffe          BL       RadioSendByte
;;;112    		osDelay(100);
000122  2064              MOVS     r0,#0x64
000124  f7fffffe          BL       osDelay
;;;113    		
;;;114    		RadioSendByte(0x81, 0x80); // Sleep mode, into Lora Mode
000128  2180              MOVS     r1,#0x80
00012a  2081              MOVS     r0,#0x81
00012c  f7fffffe          BL       RadioSendByte
;;;115    		osDelay(100);
000130  2064              MOVS     r0,#0x64
000132  f7fffffe          BL       osDelay
;;;116    		
;;;117    		RadioSendByte(0x01, 0x00); // Read mode back
000136  2100              MOVS     r1,#0
000138  2001              MOVS     r0,#1
00013a  f7fffffe          BL       RadioSendByte
;;;118    		
;;;119    		osDelay(shortDelay);
00013e  2064              MOVS     r0,#0x64
000140  f7fffffe          BL       osDelay
;;;120    		
;;;121    		RadioSendByte(0x8E, 0x00); // TX Fifo Base Address
000144  2100              MOVS     r1,#0
000146  208e              MOVS     r0,#0x8e
000148  f7fffffe          BL       RadioSendByte
;;;122    		RadioSendByte(0x8F, 0x00); // RX ''
00014c  2100              MOVS     r1,#0
00014e  208f              MOVS     r0,#0x8f
000150  f7fffffe          BL       RadioSendByte
;;;123    		
;;;124    		osDelay(shortDelay);
000154  2064              MOVS     r0,#0x64
000156  f7fffffe          BL       osDelay
;;;125    		
;;;126    		RadioSendByte(0x81, 0x01); // Set mode to StandBy
00015a  2101              MOVS     r1,#1
00015c  2081              MOVS     r0,#0x81
00015e  f7fffffe          BL       RadioSendByte
;;;127    		
;;;128    		osDelay(shortDelay);
000162  2064              MOVS     r0,#0x64
000164  f7fffffe          BL       osDelay
;;;129    		
;;;130    		RadioSendByte(0x9D, 0x72); // ModemConfReg1 - 125kHz, 4/5 Error Coding Rate, Explicit Header Mode
000168  2172              MOVS     r1,#0x72
00016a  209d              MOVS     r0,#0x9d
00016c  f7fffffe          BL       RadioSendByte
;;;131    		RadioSendByte(0x9E, 0x74); // ModemConfReg2 - SF7, 128chips/Symbol, Header indicates CRC on
000170  2174              MOVS     r1,#0x74
000172  209e              MOVS     r0,#0x9e
000174  f7fffffe          BL       RadioSendByte
;;;132    		RadioSendByte(0xA6, 0x04); // ModemConfReg3 - LNA Gain Set by internal AGC loop
000178  2104              MOVS     r1,#4
00017a  20a6              MOVS     r0,#0xa6
00017c  f7fffffe          BL       RadioSendByte
;;;133    		
;;;134    		osDelay(shortDelay);
000180  2064              MOVS     r0,#0x64
000182  f7fffffe          BL       osDelay
;;;135    		
;;;136    		RadioSendByte(0xA0, 0x00); // Preamble MSB 00
000186  2100              MOVS     r1,#0
000188  20a0              MOVS     r0,#0xa0
00018a  f7fffffe          BL       RadioSendByte
;;;137    		RadioSendByte(0xA1, 0x08); // Preamble LSB 08   - 8 preamble bits, chips or bytes?
00018e  2108              MOVS     r1,#8
000190  20a1              MOVS     r0,#0xa1
000192  f7fffffe          BL       RadioSendByte
;;;138    		
;;;139    		osDelay(shortDelay);
000196  2064              MOVS     r0,#0x64
000198  f7fffffe          BL       osDelay
;;;140    		
;;;141    		RadioSendByte(0x86, 0xD9); //
00019c  21d9              MOVS     r1,#0xd9
00019e  2086              MOVS     r0,#0x86
0001a0  f7fffffe          BL       RadioSendByte
;;;142    		RadioSendByte(0x87, 0x59); // Frequency Set - 0xD9599A gives frequency of 869.4 MHz
0001a4  2159              MOVS     r1,#0x59
0001a6  2087              MOVS     r0,#0x87
0001a8  f7fffffe          BL       RadioSendByte
;;;143    		RadioSendByte(0x88, 0x9A); //
0001ac  219a              MOVS     r1,#0x9a
0001ae  2088              MOVS     r0,#0x88
0001b0  f7fffffe          BL       RadioSendByte
;;;144    		
;;;145    		osDelay(shortDelay);
0001b4  2064              MOVS     r0,#0x64
0001b6  f7fffffe          BL       osDelay
;;;146    		
;;;147    		RadioSendByte(0xCD, 0x04); // Higher power settings of the PA
0001ba  2104              MOVS     r1,#4
0001bc  20cd              MOVS     r0,#0xcd
0001be  f7fffffe          BL       RadioSendByte
;;;148    		RadioSendByte(0x89, 0x8f); // PA Boost Pin and other stuff
0001c2  218f              MOVS     r1,#0x8f
0001c4  2089              MOVS     r0,#0x89
0001c6  f7fffffe          BL       RadioSendByte
;;;149    		
;;;150    		osDelay(shortDelay);
0001ca  2064              MOVS     r0,#0x64
0001cc  f7fffffe          BL       osDelay
;;;151    		
;;;152    		printf("Transmit data\n");
0001d0  a050              ADR      r0,|L5.788|
0001d2  f7fffffe          BL       __2printf
;;;153    		
;;;154    		RadioSendByte(0x8D, 0x80); // Set FIFO Address Pointer to 0x00
0001d6  2180              MOVS     r1,#0x80
0001d8  208d              MOVS     r0,#0x8d
0001da  f7fffffe          BL       RadioSendByte
;;;155    		
;;;156    		RadioSendByte(0x80, 0xff); //
0001de  21ff              MOVS     r1,#0xff
0001e0  2080              MOVS     r0,#0x80
0001e2  f7fffffe          BL       RadioSendByte
;;;157    		RadioSendByte(0x80, 0xff); // Is this setting up the preamble and CRC data into the TX buffer?
0001e6  21ff              MOVS     r1,#0xff
0001e8  2080              MOVS     r0,#0x80
0001ea  f7fffffe          BL       RadioSendByte
;;;158    		RadioSendByte(0x80, 0x00); //
0001ee  2100              MOVS     r1,#0
0001f0  2080              MOVS     r0,#0x80
0001f2  f7fffffe          BL       RadioSendByte
;;;159    		RadioSendByte(0x80, 0x00); //
0001f6  2100              MOVS     r1,#0
0001f8  2080              MOVS     r0,#0x80
0001fa  f7fffffe          BL       RadioSendByte
;;;160    		
;;;161    		uint8_t amessage[10]={0x80, 'H', 'i', ' ', 'T', 'h', 'e', 'r', 'e', 0x00};
0001fe  a249              ADR      r2,|L5.804|
000200  ca07              LDM      r2,{r0-r2}
000202  ab01              ADD      r3,sp,#4
000204  c307              STM      r3!,{r0-r2}
;;;162    		SendToRadio(amessage, sizeof(amessage));
000206  210a              MOVS     r1,#0xa
000208  a801              ADD      r0,sp,#4
00020a  f7fffffe          BL       SendToRadio
;;;163    		
;;;164    		osDelay(shortDelay);
00020e  2064              MOVS     r0,#0x64
000210  f7fffffe          BL       osDelay
;;;165    		
;;;166    		RadioSendByte(0xA2, (uint8_t) sizeof(amessage)+3 );  //Set the size of the message (+3 as the message contains address 0x80, which does not count!)
000214  210d              MOVS     r1,#0xd
000216  20a2              MOVS     r0,#0xa2
000218  f7fffffe          BL       RadioSendByte
;;;167    		
;;;168    		osDelay(shortDelay);
00021c  2064              MOVS     r0,#0x64
00021e  f7fffffe          BL       osDelay
;;;169    		
;;;170    		RadioSendByte(0x11, 0x00); // Look at the mask
000222  2100              MOVS     r1,#0
000224  2011              MOVS     r0,#0x11
000226  f7fffffe          BL       RadioSendByte
;;;171    		uint32_t RegIrqFlagsMask = SPI1->DR;
00022a  4841              LDR      r0,|L5.816|
00022c  8985              LDRH     r5,[r0,#0xc]
;;;172    		printf("IFMSK:0x%2X\n", (uint8_t)RegIrqFlagsMask);
00022e  b2e9              UXTB     r1,r5
000230  a040              ADR      r0,|L5.820|
000232  f7fffffe          BL       __2printf
;;;173    		
;;;174    		RadioSendByte(0x81, 0x03); // Transmit the message
000236  2103              MOVS     r1,#3
000238  2081              MOVS     r0,#0x81
00023a  f7fffffe          BL       RadioSendByte
;;;175    		
;;;176    		// Need code to check for TX done!
;;;177    		
;;;178    		osDelay(1000);
00023e  f44f707a          MOV      r0,#0x3e8
000242  f7fffffe          BL       osDelay
;;;179    		
;;;180    		// Up to here should be enough to TX a message over the air if its connected properly!!
;;;181    		
;;;182    		RadioSendByte(0xC0, 0x40); // Reg DIO Mapping1 - Maps pins of DIO0 to DIO3  D0 - will interrupt if CRCOK 
000246  2140              MOVS     r1,#0x40
000248  20c0              MOVS     r0,#0xc0
00024a  f7fffffe          BL       RadioSendByte
;;;183    		
;;;184    		osDelay(100); //Does the D0 now change after a while?
00024e  2064              MOVS     r0,#0x64
000250  f7fffffe          BL       osDelay
;;;185    		uint32_t pinstate = GPIO_PinRead( GPIOA, 2); //Read the start DIO value
000254  2002              MOVS     r0,#2
000256  491c              LDR      r1,|L5.712|
000258  6889              LDR      r1,[r1,#8]
00025a  40c1              LSRS     r1,r1,r0
00025c  f0010601          AND      r6,r1,#1
000260  bf00              NOP      
;;;186    		RadioSendByte(0x12, 0x00);	// Read the interrupt flags to see what had caused interrupt (likely the TX complete)	
000262  2100              MOVS     r1,#0
000264  2012              MOVS     r0,#0x12
000266  f7fffffe          BL       RadioSendByte
;;;187    	
;;;188    
;;;189    		uint32_t RegIRQFlags = SPI1->DR;
00026a  4831              LDR      r0,|L5.816|
00026c  8987              LDRH     r7,[r0,#0xc]
;;;190    		
;;;191    		
;;;192    		
;;;193    		
;;;194    		osDelay(100); //Does the D0 now change after a while?
00026e  2064              MOVS     r0,#0x64
000270  f7fffffe          BL       osDelay
;;;195    		
;;;196    		//D0 will change after a period, either TX completed, or there is a message recieved? Not sure.
;;;197    		
;;;198    		RadioSendByte(0x81, 0x01);	//Standby Mode
000274  2101              MOVS     r1,#1
000276  2081              MOVS     r0,#0x81
000278  f7fffffe          BL       RadioSendByte
;;;199    		
;;;200    		RadioSendByte(0x92, 0xFF);	// Clear the interrupt flags!
00027c  21ff              MOVS     r1,#0xff
00027e  2092              MOVS     r0,#0x92
000280  f7fffffe          BL       RadioSendByte
;;;201    		RadioSendByte(0x92, 0xFF);
000284  21ff              MOVS     r1,#0xff
000286  2092              MOVS     r0,#0x92
000288  f7fffffe          BL       RadioSendByte
;;;202    		
;;;203    		RadioSendByte(0x81, 0x05);	// Continious recieve mode
00028c  2105              MOVS     r1,#5
00028e  2081              MOVS     r0,#0x81
000290  f7fffffe          BL       RadioSendByte
;;;204    	
;;;205    		RadioSendByte(0xC0, 0x40);
000294  2140              MOVS     r1,#0x40
000296  20c0              MOVS     r0,#0xc0
000298  f7fffffe          BL       RadioSendByte
;;;206    		
;;;207    		
;;;208    		printf("Entering Listen \n");
00029c  a029              ADR      r0,|L5.836|
00029e  f7fffffe          BL       __2printf
;;;209    		
;;;210    		RadioSendByte(0x11, 0x00); // Look at the IRQ mask
0002a2  2100              MOVS     r1,#0
0002a4  2011              MOVS     r0,#0x11
0002a6  f7fffffe          BL       RadioSendByte
;;;211    		RegIrqFlagsMask = SPI1->DR;
0002aa  4821              LDR      r0,|L5.816|
0002ac  8985              LDRH     r5,[r0,#0xc]
;;;212    		printf("IFMSK:0x%2X\n", (uint8_t)RegIrqFlagsMask);
0002ae  b2e9              UXTB     r1,r5
0002b0  a020              ADR      r0,|L5.820|
0002b2  f7fffffe          BL       __2printf
;;;213    		
;;;214    		uint32_t oldflag=0x00;
0002b6  f04f0800          MOV      r8,#0
;;;215    		while(0){		//CANT HAVE AN INFINITE LOOP HERE - REMOVED FOR NOW!!!
0002ba  bf00              NOP      
0002bc  bf00              NOP      
;;;216    					RadioSendByte(0x12, 0x00);	// Read the interrupt flags - expect 0x00 as cleared them recently.
;;;217    					RegIRQFlags = SPI1->DR;
;;;218    					for(int c = 0; c < 10000; c++ ){}		// Non os Delay
;;;219    					if( RegIRQFlags != oldflag ){
;;;220    						oldflag = RegIRQFlags;
;;;221    						printf("IF:0x%2X\n", (uint8_t)RegIRQFlags);
;;;222    //					
;;;223    						for(int c = 0; c < 10000; c++ ){}		// Non os Delay
;;;224    						RadioSendByte(0x11, 0x00); // Look at the IRQ mask
;;;225    						RegIrqFlagsMask = SPI1->DR;
;;;226    						printf("IFMSK:0x%2X\n", (uint8_t)RegIrqFlagsMask);
;;;227    //						RadioSendByte(0x81, 0x01);	//Standby Mode
;;;228    //						RadioSendByte(0x92, 0xFF);	// Clear the interrupt flags!
;;;229    //						RadioSendByte(0x92, 0xFF);
;;;230    //						RadioSendByte(0x81, 0x05);	// Continious recieve mode
;;;231    					}
;;;232    		}
;;;233    		
;;;234    		
;;;235    		/*
;;;236    		
;;;237    		// NEED CODE TO WAIT ON D0 Asseted!
;;;238    		 pinstate = GPIO_PinRead( GPIOA, 2); //Read the start DIO value
;;;239    		while( pinstate == GPIO_PinRead( GPIOA, 2)){} // Wait for it to change
;;;240    			
;;;241    		
;;;242    		RadioSendByte(0x12, 0x00);	// Read the interrupt flags - expect 0x50 - Rx Done, Valid Header
;;;243    		RadioSendByte(0x1C, 0x00);	// Read expect 0x40 - CRC on?
;;;244    		
;;;245    		RadioSendByte(0x13, 0x00);	// Read no of bytes in packet payload
;;;246    		
;;;247    		RadioSendByte(0x10, 0xFF);	// Get the FIFO Address of packet
;;;248    		
;;;249    		RadioSendByte(0x8D, 0x00);  // Write the packet address
;;;250    		
;;;251    		uint8_t readmessage[50]={ 0x00 };
;;;252    		SendToRadio(readmessage, sizeof(readmessage));
;;;253    		
;;;254    		
;;;255    		RadioSendByte(0x92, 0xFF);	// Clear the IRQ
;;;256    		RadioSendByte(0x19, 0x00);	// Get the SNR
;;;257    		RadioSendByte(0x1A, 0x00);	// Get the RSSI value
;;;258    		RadioSendByte(0x10, 0xFF);
;;;259    		RadioSendByte(0x81, 0x01);	// Standby mode
;;;260    		RadioSendByte(0x92, 0xFF);	// Clear the IRQ
;;;261    		RadioSendByte(0x92, 0xFF);	// Clear the IRQ
;;;262    		
;;;263    		
;;;264    		*/
;;;265    		
;;;266    		
;;;267    	return(1);
0002be  2001              MOVS     r0,#1
;;;268    }
0002c0  b006              ADD      sp,sp,#0x18
0002c2  e8bd81f0          POP      {r4-r8,pc}
;;;269    
                          ENDP

0002c6  0000              DCW      0x0000
                  |L5.712|
                          DCD      0x40010800
                  |L5.716|
                          DCD      Driver_SPI1
                  |L5.720|
                          DCD      mySPI_callback
                  |L5.724|
                          DCD      0x000f4240
                  |L5.728|
                          DCD      0x00088001
                  |L5.732|
0002dc  52657365          DCB      "Reseting...\n",0
0002e0  74696e67
0002e4  2e2e2e0a
0002e8  00      
0002e9  00                DCB      0
0002ea  00                DCB      0
0002eb  00                DCB      0
                  |L5.748|
                          DCD      0x40011000
                  |L5.752|
0002f0  52657365          DCB      "Reset Complete, configuring radio\n",0
0002f4  7420436f
0002f8  6d706c65
0002fc  74652c20
000300  636f6e66
000304  69677572
000308  696e6720
00030c  72616469
000310  6f0a00  
000313  00                DCB      0
                  |L5.788|
000314  5472616e          DCB      "Transmit data\n",0
000318  736d6974
00031c  20646174
000320  610a00  
000323  00                DCB      0
                  |L5.804|
000324  80486920          DCB      128,"Hi There",0
000328  54686572
00032c  6500    
00032e  00                DCB      0
00032f  00                DCB      0
                  |L5.816|
                          DCD      0x40013000
                  |L5.820|
000334  49464d53          DCB      "IFMSK:0x%2X\n",0
000338  4b3a3078
00033c  2532580a
000340  00      
000341  00                DCB      0
000342  00                DCB      0
000343  00                DCB      0
                  |L5.836|
000344  456e7465          DCB      "Entering Listen \n",0
000348  72696e67
00034c  204c6973
000350  74656e20
000354  0a00    
000356  00                DCB      0
000357  00                DCB      0

                          AREA ||i.mySPI_callback||, CODE, READONLY, ALIGN=1

                  mySPI_callback PROC
;;;27     
;;;28     void mySPI_callback(uint32_t event)
000000  2801              CMP      r0,#1
;;;29     {
;;;30     	switch (event)
000002  d004              BEQ      |L6.14|
000004  2802              CMP      r0,#2
000006  d003              BEQ      |L6.16|
000008  2804              CMP      r0,#4
00000a  d105              BNE      |L6.24|
00000c  e002              B        |L6.20|
                  |L6.14|
;;;31         {
;;;32         case ARM_SPI_EVENT_TRANSFER_COMPLETE:
;;;33             /* Success: Wakeup Thread */
;;;34             //osSignalSet(tid_mySPI_Thread, 0x01);
;;;35             break;
00000e  e003              B        |L6.24|
                  |L6.16|
;;;36         case ARM_SPI_EVENT_DATA_LOST:
;;;37             /*  Occurs in slave mode when data is requested/sent by master
;;;38                 but send/receive/transfer operation has not been started
;;;39                 and indicates that data is lost. Occurs also in master mode
;;;40                 when driver cannot transfer data fast enough. */
;;;41             __breakpoint(0);  /* Error: Call debugger or replace with custom error handling */
000010  be00              BKPT     #0
;;;42             break;
000012  e001              B        |L6.24|
                  |L6.20|
;;;43         case ARM_SPI_EVENT_MODE_FAULT:
;;;44             /*  Occurs in master mode when Slave Select is deactivated and
;;;45                 indicates Master Mode Fault. */
;;;46             __breakpoint(0);  /* Error: Call debugger or replace with custom error handling */
000014  be00              BKPT     #0
;;;47             break;
000016  bf00              NOP      
                  |L6.24|
000018  bf00              NOP                            ;35
;;;48         }
;;;49     }
00001a  4770              BX       lr
;;;50     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  _buf
                          %        255

                          AREA ||.data||, DATA, ALIGN=0

                  _bufLen
000000  00                DCB      0x00
                  _rxBufValid
000001  00                DCB      0x00
                  _usingHFport
000002  00                DCB      0x00
                  _lastSNR
000003  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "Radio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_Radio_c_Delay____REV16|
#line 492 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___7_Radio_c_Delay____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_Radio_c_Delay____REVSH|
#line 507
|__asm___7_Radio_c_Delay____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_Radio_c_Delay____RRX|
#line 694
|__asm___7_Radio_c_Delay____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
