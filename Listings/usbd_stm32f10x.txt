; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\usbd_stm32f10x.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usbd_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTE\Device\STM32F103C8 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Driver\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\RTOS\RTX\INC -IC:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\StdPeriph_Driver\inc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\RTE_Driver -D__RTX -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\objects\usbd_stm32f10x.crf C:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\RTE_Driver\USBD_STM32F10x.c]
                          THUMB

                          AREA ||i.IN_EP_Status||, CODE, READONLY, ALIGN=2

                  IN_EP_Status PROC
;;;226    */
;;;227    void IN_EP_Status (uint8_t ep_num, uint32_t stat) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;228      uint32_t num, val, ep_reg;
;;;229    
;;;230      num         =  ep_num & ARM_USB_ENDPOINT_NUMBER_MASK;
000002  f000020f          AND      r2,r0,#0xf
;;;231      stat       &=  EP_STAT_TX;
000006  f0010130          AND      r1,r1,#0x30
;;;232      ep_reg      =  EPxREG(num);
00000a  4e0c              LDR      r6,|L1.60|
00000c  eb060582          ADD      r5,r6,r2,LSL #2
000010  f8d53c00          LDR      r3,[r5,#0xc00]
;;;233      val         = (ep_reg & EP_STAT_TX) ^ stat;
000014  f0030530          AND      r5,r3,#0x30
000018  ea850401          EOR      r4,r5,r1
;;;234      val         = (ep_reg & ~EP_STAT_TX) | val;
00001c  f0230530          BIC      r5,r3,#0x30
000020  432c              ORRS     r4,r4,r5
;;;235      EPxREG(num) = (val & (EP_MASK | EP_STAT_TX)) | EP_CTR_TX | EP_CTR_RX;
000022  f64875bf          MOV      r5,#0x8fbf
000026  4025              ANDS     r5,r5,r4
000028  f0450580          ORR      r5,r5,#0x80
00002c  f4454500          ORR      r5,r5,#0x8000
000030  4637              MOV      r7,r6
000032  eb070682          ADD      r6,r7,r2,LSL #2
000036  f8c65c00          STR      r5,[r6,#0xc00]
;;;236    }
00003a  bdf0              POP      {r4-r7,pc}
;;;237    
                          ENDP

                  |L1.60|
                          DCD      0x40005000

                          AREA ||i.OUT_EP_Status||, CODE, READONLY, ALIGN=2

                  OUT_EP_Status PROC
;;;241    */
;;;242    void OUT_EP_Status (uint8_t ep_num, uint32_t stat) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;243      uint32_t num, val, ep_reg;
;;;244    
;;;245      num         =  ep_num & ARM_USB_ENDPOINT_NUMBER_MASK;
000002  f000020f          AND      r2,r0,#0xf
;;;246      stat       &=  EP_STAT_RX;
000006  f4015140          AND      r1,r1,#0x3000
;;;247      ep_reg      =  EPxREG(num);
00000a  4e0c              LDR      r6,|L2.60|
00000c  eb060582          ADD      r5,r6,r2,LSL #2
000010  f8d53c00          LDR      r3,[r5,#0xc00]
;;;248      val         = (ep_reg & EP_STAT_RX) ^ stat;
000014  f4035540          AND      r5,r3,#0x3000
000018  ea850401          EOR      r4,r5,r1
;;;249      val         = (ep_reg & ~EP_STAT_RX) | val;
00001c  f4235540          BIC      r5,r3,#0x3000
000020  432c              ORRS     r4,r4,r5
;;;250      EPxREG(num) = (val & (EP_MASK | EP_STAT_RX)) | EP_CTR_TX | EP_CTR_RX;
000022  f64b758f          MOV      r5,#0xbf8f
000026  4025              ANDS     r5,r5,r4
000028  f0450580          ORR      r5,r5,#0x80
00002c  f4454500          ORR      r5,r5,#0x8000
000030  4637              MOV      r7,r6
000032  eb070682          ADD      r6,r7,r2,LSL #2
000036  f8c65c00          STR      r5,[r6,#0xc00]
;;;251    }
00003a  bdf0              POP      {r4-r7,pc}
;;;252    
                          ENDP

                  |L2.60|
                          DCD      0x40005000

                          AREA ||i.USBD_DeviceConnect||, CODE, READONLY, ALIGN=2

                  USBD_DeviceConnect PROC
;;;493    */
;;;494    static int32_t USBD_DeviceConnect (void) {
000000  4809              LDR      r0,|L3.40|
;;;495    
;;;496      if (hw_powered == false) { return ARM_DRIVER_ERROR; }
000002  7800              LDRB     r0,[r0,#0]  ; hw_powered
000004  b910              CBNZ     r0,|L3.12|
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L3.10|
;;;497    
;;;498      // Soft connect
;;;499    #if (RTE_USB_DEVICE_CON_PIN)
;;;500      GPIO_PinWrite (RTE_USB_DEVICE_CON_PORT, RTE_USB_DEVICE_CON_BIT, RTE_USB_DEVICE_CON_ACTIVE);
;;;501    #endif
;;;502    
;;;503      CNTR = CNTR_FRES;                             // Force USB Reset
;;;504      CNTR = 0;
;;;505      ISTR = 0;                                     // Clear Interrupt Status
;;;506      CNTR = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; // USB Interrupt Mask
;;;507    
;;;508      return ARM_DRIVER_OK;
;;;509    }
00000a  4770              BX       lr
                  |L3.12|
00000c  2001              MOVS     r0,#1                 ;503
00000e  4907              LDR      r1,|L3.44|
000010  6008              STR      r0,[r1,#0]            ;503
000012  2000              MOVS     r0,#0                 ;504
000014  6008              STR      r0,[r1,#0]            ;504
000016  1d09              ADDS     r1,r1,#4              ;505
000018  6008              STR      r0,[r1,#0]            ;505
00001a  f44f50e0          MOV      r0,#0x1c00            ;506
00001e  1f09              SUBS     r1,r1,#4              ;506
000020  6008              STR      r0,[r1,#0]            ;506
000022  2000              MOVS     r0,#0                 ;508
000024  e7f1              B        |L3.10|
;;;510    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      hw_powered
                  |L3.44|
                          DCD      0x40005c40

                          AREA ||i.USBD_DeviceDisconnect||, CODE, READONLY, ALIGN=2

                  USBD_DeviceDisconnect PROC
;;;515    */
;;;516    static int32_t USBD_DeviceDisconnect (void) {
000000  4805              LDR      r0,|L4.24|
;;;517    
;;;518      if (hw_powered == false) { return ARM_DRIVER_ERROR; }
000002  7800              LDRB     r0,[r0,#0]  ; hw_powered
000004  b910              CBNZ     r0,|L4.12|
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L4.10|
;;;519    
;;;520      CNTR = CNTR_FRES | CNTR_PDWN;                 // Switch Off USB Device
;;;521    
;;;522      // Soft disconnect
;;;523    #if (RTE_USB_DEVICE_CON_PIN)
;;;524      GPIO_PinWrite (RTE_USB_DEVICE_CON_PORT, RTE_USB_DEVICE_CON_BIT, !RTE_USB_DEVICE_CON_ACTIVE);
;;;525    #endif
;;;526    
;;;527      return ARM_DRIVER_OK;
;;;528    }
00000a  4770              BX       lr
                  |L4.12|
00000c  2003              MOVS     r0,#3                 ;520
00000e  4903              LDR      r1,|L4.28|
000010  6008              STR      r0,[r1,#0]            ;520
000012  2000              MOVS     r0,#0                 ;527
000014  e7f9              B        |L4.10|
;;;529    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      hw_powered
                  |L4.28|
                          DCD      0x40005c40

                          AREA ||i.USBD_DeviceGetState||, CODE, READONLY, ALIGN=2

                  USBD_DeviceGetState PROC
;;;534    */
;;;535    static ARM_USBD_STATE USBD_DeviceGetState (void) {
000000  b508              PUSH     {r3,lr}
;;;536      return usbd_state;
000002  480e              LDR      r0,|L5.60|
000004  6800              LDR      r0,[r0,#0]  ; usbd_state
000006  9900              LDR      r1,[sp,#0]
000008  f3600100          BFI      r1,r0,#0,#1
00000c  9100              STR      r1,[sp,#0]
00000e  480b              LDR      r0,|L5.60|
000010  6800              LDR      r0,[r0,#0]  ; usbd_state
000012  0841              LSRS     r1,r0,#1
000014  9800              LDR      r0,[sp,#0]
000016  f3610042          BFI      r0,r1,#1,#2
00001a  9000              STR      r0,[sp,#0]
00001c  4807              LDR      r0,|L5.60|
00001e  6800              LDR      r0,[r0,#0]  ; usbd_state
000020  08c1              LSRS     r1,r0,#3
000022  9800              LDR      r0,[sp,#0]
000024  f36100c3          BFI      r0,r1,#3,#1
000028  9000              STR      r0,[sp,#0]
00002a  4804              LDR      r0,|L5.60|
00002c  6800              LDR      r0,[r0,#0]  ; usbd_state
00002e  0901              LSRS     r1,r0,#4
000030  9800              LDR      r0,[sp,#0]
000032  f361101f          BFI      r0,r1,#4,#28
000036  9000              STR      r0,[sp,#0]
000038  9800              LDR      r0,[sp,#0]
;;;537    }
00003a  bd08              POP      {r3,pc}
;;;538    
                          ENDP

                  |L5.60|
                          DCD      usbd_state

                          AREA ||i.USBD_DeviceRemoteWakeup||, CODE, READONLY, ALIGN=2

                  USBD_DeviceRemoteWakeup PROC
;;;543    */
;;;544    static int32_t USBD_DeviceRemoteWakeup (void) {
000000  b510              PUSH     {r4,lr}
;;;545    
;;;546      if (hw_powered == false) { return ARM_DRIVER_ERROR; }
000002  480c              LDR      r0,|L6.52|
000004  7800              LDRB     r0,[r0,#0]  ; hw_powered
000006  b910              CBNZ     r0,|L6.14|
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L6.12|
;;;547    
;;;548      CNTR |=   CNTR;       // Remote wakeup signaling
;;;549      osDelay(2U);
;;;550      CNTR &=  ~CNTR;
;;;551    
;;;552      return ARM_DRIVER_OK;
;;;553    }
00000c  bd10              POP      {r4,pc}
                  |L6.14|
00000e  480a              LDR      r0,|L6.56|
000010  6800              LDR      r0,[r0,#0]            ;548
000012  4909              LDR      r1,|L6.56|
000014  6809              LDR      r1,[r1,#0]            ;548
000016  4308              ORRS     r0,r0,r1              ;548
000018  4907              LDR      r1,|L6.56|
00001a  6008              STR      r0,[r1,#0]            ;548
00001c  2002              MOVS     r0,#2                 ;549
00001e  f7fffffe          BL       osDelay
000022  4805              LDR      r0,|L6.56|
000024  6800              LDR      r0,[r0,#0]            ;550
000026  4904              LDR      r1,|L6.56|
000028  6809              LDR      r1,[r1,#0]            ;550
00002a  4388              BICS     r0,r0,r1              ;550
00002c  4902              LDR      r1,|L6.56|
00002e  6008              STR      r0,[r1,#0]            ;550
000030  2000              MOVS     r0,#0                 ;552
000032  e7eb              B        |L6.12|
;;;554    
                          ENDP

                  |L6.52|
                          DCD      hw_powered
                  |L6.56|
                          DCD      0x40005c40

                          AREA ||i.USBD_DeviceSetAddress||, CODE, READONLY, ALIGN=2

                  USBD_DeviceSetAddress PROC
;;;560    */
;;;561    static int32_t USBD_DeviceSetAddress (uint8_t dev_addr) {
000000  4601              MOV      r1,r0
;;;562    
;;;563      if (hw_powered == false) { return ARM_DRIVER_ERROR; }
000002  4806              LDR      r0,|L7.28|
000004  7800              LDRB     r0,[r0,#0]  ; hw_powered
000006  b910              CBNZ     r0,|L7.14|
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L7.12|
;;;564    
;;;565      DADDR = DADDR_EF | dev_addr;
;;;566    
;;;567      return ARM_DRIVER_OK;
;;;568    }
00000c  4770              BX       lr
                  |L7.14|
00000e  f0410080          ORR      r0,r1,#0x80           ;565
000012  4a03              LDR      r2,|L7.32|
000014  6010              STR      r0,[r2,#0]            ;565
000016  2000              MOVS     r0,#0                 ;567
000018  e7f8              B        |L7.12|
;;;569    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      hw_powered
                  |L7.32|
                          DCD      0x40005c4c

                          AREA ||i.USBD_EP_HW_Read||, CODE, READONLY, ALIGN=2

                  USBD_EP_HW_Read PROC
;;;260    */
;;;261    static void USBD_EP_HW_Read (uint8_t ep_addr) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4603              MOV      r3,r0
;;;262      volatile ENDPOINT_t *ptr_ep;
;;;263      uint32_t             cnt, i;
;;;264      __packed uint8_t    *ptr_dest_8;
;;;265      __packed uint16_t   *ptr_dest;
;;;266      volatile uint32_t   *ptr_src;
;;;267      uint8_t              ep_num;
;;;268      uint8_t              tmp_buf[4];
;;;269    
;;;270      ptr_ep = &ep[EP_ID(ep_addr)];
000006  ea4f7c03          LSL      r12,r3,#28
00000a  ea4f6cdc          LSR      r12,r12,#27
00000e  eb0c1cd3          ADD      r12,r12,r3,LSR #7
000012  eb0c0c8c          ADD      r12,r12,r12,LSL #2
000016  f8df80b8          LDR      r8,|L8.208|
00001a  eb08008c          ADD      r0,r8,r12,LSL #2
;;;271      ep_num = EP_NUM(ep_addr);
00001e  f003060f          AND      r6,r3,#0xf
;;;272    
;;;273      cnt = (pBUF_DSCR + ep_num)->COUNT_RX & EP_COUNT_MASK;
000022  f8dfc0b0          LDR      r12,|L8.212|
000026  f8dcc000          LDR      r12,[r12,#0]  ; pBUF_DSCR
00002a  eb0c1c06          ADD      r12,r12,r6,LSL #4
00002e  f8bcc00c          LDRH     r12,[r12,#0xc]
000032  f3cc0109          UBFX     r1,r12,#0,#10
;;;274    
;;;275      // Check for ZLP
;;;276      if (cnt          == 0U) { return; }
000036  b909              CBNZ     r1,|L8.60|
                  |L8.56|
;;;277    
;;;278      // Check if buffer available
;;;279      if (ptr_ep->data == 0U) { return; }
;;;280    
;;;281      // Copy data from FIFO
;;;282      ptr_src  = (uint32_t *)(USB_PMA_ADDR + 2*((pBUF_DSCR + ep_num)->ADDR_RX));
;;;283      ptr_dest = (__packed uint16_t *)(ptr_ep->data + ptr_ep->num_transferred_total);
;;;284    
;;;285      i = cnt / 2U;
;;;286      while (i != 0U) {
;;;287        *ptr_dest++ = *ptr_src++;
;;;288        i--;
;;;289      }
;;;290      ptr_ep->num_transferred_total += cnt;
;;;291    
;;;292      // If data size is not equal n*2
;;;293      if ((cnt & 1U) != 0U) {
;;;294        ptr_dest_8 = (uint8_t *)(ptr_dest);
;;;295        *((__packed uint16_t *)tmp_buf) = *ptr_src;
;;;296        *ptr_dest_8 = tmp_buf[0];
;;;297      }
;;;298    
;;;299      if (cnt != ptr_ep->max_packet_size) { ptr_ep->num  = 0U;  }
;;;300      else                                { ptr_ep->num -= cnt; }
;;;301    }
000038  e8bd83f8          POP      {r3-r9,pc}
                  |L8.60|
00003c  f8d0c000          LDR      r12,[r0,#0]           ;279
000040  f1bc0f00          CMP      r12,#0                ;279
000044  d100              BNE      |L8.72|
000046  e7f7              B        |L8.56|
                  |L8.72|
000048  f8dfc088          LDR      r12,|L8.212|
00004c  f8dcc000          LDR      r12,[r12,#0]          ;282  ; pBUF_DSCR
000050  eb0c1c06          ADD      r12,r12,r6,LSL #4     ;282
000054  f8dcc008          LDR      r12,[r12,#8]          ;282
000058  f8df807c          LDR      r8,|L8.216|
00005c  f04f0902          MOV      r9,#2                 ;282
000060  fb09840c          MLA      r4,r9,r12,r8          ;282
000064  f8d0c000          LDR      r12,[r0,#0]           ;283
000068  f8d08008          LDR      r8,[r0,#8]            ;283
00006c  eb0c0208          ADD      r2,r12,r8             ;283
000070  084d              LSRS     r5,r1,#1              ;285
000072  e004              B        |L8.126|
                  |L8.116|
000074  f8548b04          LDR      r8,[r4],#4            ;287
000078  f8228b02          STRH     r8,[r2],#2            ;287
00007c  1e6d              SUBS     r5,r5,#1              ;288
                  |L8.126|
00007e  2d00              CMP      r5,#0                 ;286
000080  d1f8              BNE      |L8.116|
000082  f8d0c008          LDR      r12,[r0,#8]           ;290
000086  448c              ADD      r12,r12,r1            ;290
000088  f8c0c008          STR      r12,[r0,#8]           ;290
00008c  f0010c01          AND      r12,r1,#1             ;293
000090  f1bc0f00          CMP      r12,#0                ;293
000094  d00a              BEQ      |L8.172|
000096  4617              MOV      r7,r2                 ;294
000098  f8d4c000          LDR      r12,[r4,#0]           ;295
00009c  fa1ffc8c          UXTH     r12,r12               ;295
0000a0  f8adc000          STRH     r12,[sp,#0]           ;295
0000a4  f89dc000          LDRB     r12,[sp,#0]           ;296
0000a8  f887c000          STRB     r12,[r7,#0]           ;296
                  |L8.172|
0000ac  f8b0c00e          LDRH     r12,[r0,#0xe]         ;299
0000b0  458c              CMP      r12,r1                ;299
0000b2  d004              BEQ      |L8.190|
0000b4  f04f0c00          MOV      r12,#0                ;299
0000b8  f8c0c004          STR      r12,[r0,#4]           ;299
0000bc  e005              B        |L8.202|
                  |L8.190|
0000be  f8d0c004          LDR      r12,[r0,#4]           ;300
0000c2  ebac0c01          SUB      r12,r12,r1            ;300
0000c6  f8c0c004          STR      r12,[r0,#4]           ;300
                  |L8.202|
0000ca  bf00              NOP      
0000cc  e7b4              B        |L8.56|
;;;302    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L8.208|
                          DCD      ||ep||
                  |L8.212|
                          DCD      pBUF_DSCR
                  |L8.216|
                          DCD      0x40006000

                          AREA ||i.USBD_EP_HW_Write||, CODE, READONLY, ALIGN=2

                  USBD_EP_HW_Write PROC
;;;309    */
;;;310    static void USBD_EP_HW_Write (uint8_t ep_addr) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
;;;311      volatile ENDPOINT_t *ptr_ep;
;;;312      uint8_t              ep_num;
;;;313      uint16_t             num, i;
;;;314      volatile uint32_t   *ptr_dest;
;;;315      __packed uint16_t   *ptr_src;
;;;316    
;;;317      ptr_ep = &ep[EP_ID(ep_addr)];
000006  0730              LSLS     r0,r6,#28
000008  0ec0              LSRS     r0,r0,#27
00000a  eb0010d6          ADD      r0,r0,r6,LSR #7
00000e  eb000080          ADD      r0,r0,r0,LSL #2
000012  4920              LDR      r1,|L9.148|
000014  eb010480          ADD      r4,r1,r0,LSL #2
;;;318      ep_num = EP_NUM(ep_addr);
000018  f006070f          AND      r7,r6,#0xf
;;;319    
;;;320      if (ptr_ep->num > ptr_ep->max_packet_size) { num = ptr_ep->max_packet_size; }
00001c  6860              LDR      r0,[r4,#4]
00001e  89e1              LDRH     r1,[r4,#0xe]
000020  4288              CMP      r0,r1
000022  d901              BLS      |L9.40|
000024  89e5              LDRH     r5,[r4,#0xe]
000026  e001              B        |L9.44|
                  |L9.40|
;;;321      else                                       { num = ptr_ep->num;             }
000028  6860              LDR      r0,[r4,#4]
00002a  b285              UXTH     r5,r0
                  |L9.44|
;;;322    
;;;323      ptr_src  = (__packed uint16_t *)(ptr_ep->data + ptr_ep->num_transferred_total);
00002c  6820              LDR      r0,[r4,#0]
00002e  68a1              LDR      r1,[r4,#8]
000030  eb000a01          ADD      r10,r0,r1
;;;324      ptr_dest = (uint32_t *)(USB_PMA_ADDR + 2*((pBUF_DSCR + ep_num)->ADDR_TX));
000034  4818              LDR      r0,|L9.152|
000036  6800              LDR      r0,[r0,#0]  ; pBUF_DSCR
000038  eb001007          ADD      r0,r0,r7,LSL #4
00003c  6800              LDR      r0,[r0,#0]
00003e  4917              LDR      r1,|L9.156|
000040  2202              MOVS     r2,#2
000042  fb021900          MLA      r9,r2,r0,r1
;;;325    
;;;326      ptr_ep->num_transferring  = num;
000046  81a5              STRH     r5,[r4,#0xc]
;;;327      ptr_ep->num              -= num;
000048  6860              LDR      r0,[r4,#4]
00004a  1b40              SUBS     r0,r0,r5
00004c  6060              STR      r0,[r4,#4]
;;;328    
;;;329      // Copy data to EP Buffer
;;;330      i = (num + 1U) >> 1;
00004e  1c68              ADDS     r0,r5,#1
000050  ea4f0850          LSR      r8,r0,#1
;;;331      while (i != 0U) {
000054  e007              B        |L9.102|
                  |L9.86|
;;;332        *ptr_dest++ = *ptr_src++;
000056  f83a0b02          LDRH     r0,[r10],#2
00005a  f8490b04          STR      r0,[r9],#4
;;;333        i--;
00005e  f1a80001          SUB      r0,r8,#1
000062  fa1ff880          UXTH     r8,r0
                  |L9.102|
000066  f1b80f00          CMP      r8,#0                 ;331
00006a  d1f4              BNE      |L9.86|
;;;334      }
;;;335    
;;;336      (pBUF_DSCR + ep_num)->COUNT_TX = num;
00006c  480a              LDR      r0,|L9.152|
00006e  6800              LDR      r0,[r0,#0]  ; pBUF_DSCR
000070  eb001007          ADD      r0,r0,r7,LSL #4
000074  6045              STR      r5,[r0,#4]
;;;337    
;;;338      if ((EPxREG(ep_num) & EP_STAT_TX) != EP_TX_STALL) {
000076  490a              LDR      r1,|L9.160|
000078  eb010087          ADD      r0,r1,r7,LSL #2
00007c  f8d00c00          LDR      r0,[r0,#0xc00]
000080  f0000030          AND      r0,r0,#0x30
000084  2810              CMP      r0,#0x10
000086  d003              BEQ      |L9.144|
;;;339        IN_EP_Status(ep_addr, EP_TX_VALID);     // do not make EP valid if stalled
000088  2130              MOVS     r1,#0x30
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       IN_EP_Status
                  |L9.144|
;;;340      }
;;;341    }
000090  e8bd87f0          POP      {r4-r10,pc}
;;;342    
                          ENDP

                  |L9.148|
                          DCD      ||ep||
                  |L9.152|
                          DCD      pBUF_DSCR
                  |L9.156|
                          DCD      0x40006000
                  |L9.160|
                          DCD      0x40005000

                          AREA ||i.USBD_EndpointConfigure||, CODE, READONLY, ALIGN=2

                  USBD_EndpointConfigure PROC
;;;602    */
;;;603    static int32_t USBD_EndpointConfigure (uint8_t  ep_addr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;604                                           uint8_t  ep_type,
;;;605                                           uint16_t ep_max_packet_size) {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
;;;606      volatile ENDPOINT_t *ptr_ep;
;;;607      uint8_t              ep_num;
;;;608      uint16_t             ep_mps;
;;;609      bool                 ep_dir;
;;;610      uint32_t             ep_reg;
;;;611    
;;;612      ep_num = EP_NUM(ep_addr);
00000a  f004050f          AND      r5,r4,#0xf
;;;613      if (ep_num > USBD_MAX_ENDPOINT_NUM) { return ARM_DRIVER_ERROR; }
00000e  2d08              CMP      r5,#8
000010  d903              BLS      |L10.26|
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L10.22|
;;;614      if (hw_powered == false)            { return ARM_DRIVER_ERROR; }
;;;615    
;;;616      ptr_ep = &ep[EP_ID(ep_addr)];
;;;617      if (ptr_ep->active != 0U)           { return ARM_DRIVER_ERROR_BUSY; }
;;;618    
;;;619      ep_mps =  ep_max_packet_size & ARM_USB_ENDPOINT_MAX_PACKET_SIZE_MASK;
;;;620      ep_dir = (ep_addr & ARM_USB_ENDPOINT_DIRECTION_MASK) == ARM_USB_ENDPOINT_DIRECTION_MASK;
;;;621    
;;;622      // Check Endpoint buffer size configuration
;;;623      if ((ep_mps + EP_buff_offset[EP_ID(ep_addr)]) > EP_buff_offset[EP_ID(ep_addr) + 1]) {
;;;624        // Configured Endpoint buffer is too small
;;;625        return ARM_DRIVER_ERROR;
;;;626      }
;;;627    
;;;628      // Clear Endpoint transfer and configuration information
;;;629      memset((void *)(ptr_ep), 0, sizeof (ENDPOINT_t));
;;;630    
;;;631      // Set maximum packet size to requested
;;;632      ptr_ep->max_packet_size = ep_mps;
;;;633    
;;;634      if (ep_dir != 0U) {                                   // IN Endpoint
;;;635        (pBUF_DSCR + ep_num)->ADDR_TX = EP_buff_offset[EP_ID(ep_addr)];
;;;636      } else {                                              // OUT Endpoint
;;;637        (pBUF_DSCR + ep_num)->ADDR_RX = EP_buff_offset[EP_ID(ep_addr)];
;;;638        if (ep_mps > 62) {
;;;639          ep_mps = (ep_mps + 31) & ~31;
;;;640          (pBUF_DSCR + ep_num)->COUNT_RX = ((ep_mps << 5) - 1) | 0x8000;
;;;641        } else {
;;;642          ep_mps = (ep_mps + 1)  & ~1;
;;;643          (pBUF_DSCR + ep_num)->COUNT_RX =   ep_mps << 9;
;;;644        }
;;;645      }
;;;646    
;;;647      switch (ep_type) {
;;;648        case ARM_USB_ENDPOINT_CONTROL:
;;;649          ep_reg = EP_CONTROL;
;;;650          break;
;;;651        case ARM_USB_ENDPOINT_ISOCHRONOUS:
;;;652          ep_reg = EP_ISOCHRONOUS;
;;;653          break;
;;;654        case ARM_USB_ENDPOINT_BULK:
;;;655          ep_reg = EP_BULK;
;;;656          break;
;;;657        case ARM_USB_ENDPOINT_INTERRUPT:
;;;658          ep_reg = EP_INTERRUPT;
;;;659          break;
;;;660      }
;;;661    
;;;662      if (ep_addr == 0U) {
;;;663        // Enable Endpoint 0 to receive Setup and OUT packets
;;;664        EPxREG(0) = EP_CONTROL | EP_RX_VALID;
;;;665      } else if (ep_addr != 0x80U){
;;;666        ep_reg |= ep_num;
;;;667        EPxREG(ep_num) = ep_reg;
;;;668    
;;;669        if (ep_dir != 0U) {                                   // IN Endpoint
;;;670          IN_EP_RESET(ep_num);
;;;671          IN_EP_Status(ep_num, EP_TX_NAK);
;;;672        } else {                                              // OUT Endpoint
;;;673          OUT_EP_RESET(ep_num);
;;;674          OUT_EP_Status(ep_num, EP_RX_NAK);
;;;675        }
;;;676      }
;;;677    
;;;678      return ARM_DRIVER_OK;
;;;679    }
000016  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.26|
00001a  4863              LDR      r0,|L10.424|
00001c  7800              LDRB     r0,[r0,#0]            ;614  ; hw_powered
00001e  b910              CBNZ     r0,|L10.38|
000020  f04f30ff          MOV      r0,#0xffffffff        ;614
000024  e7f7              B        |L10.22|
                  |L10.38|
000026  0720              LSLS     r0,r4,#28             ;616
000028  0ec0              LSRS     r0,r0,#27             ;616
00002a  eb0010d4          ADD      r0,r0,r4,LSR #7       ;616
00002e  eb000080          ADD      r0,r0,r0,LSL #2       ;616
000032  495e              LDR      r1,|L10.428|
000034  eb010880          ADD      r8,r1,r0,LSL #2       ;616
000038  f8980010          LDRB     r0,[r8,#0x10]         ;617
00003c  b110              CBZ      r0,|L10.68|
00003e  f06f0001          MVN      r0,#1                 ;617
000042  e7e8              B        |L10.22|
                  |L10.68|
000044  f3cb060a          UBFX     r6,r11,#0,#11         ;619
000048  f3c419c0          UBFX     r9,r4,#7,#1           ;620
00004c  0720              LSLS     r0,r4,#28             ;623
00004e  0ec0              LSRS     r0,r0,#27             ;623
000050  eb0010d4          ADD      r0,r0,r4,LSR #7       ;623
000054  4956              LDR      r1,|L10.432|
000056  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;623
00005a  1981              ADDS     r1,r0,r6              ;623
00005c  0720              LSLS     r0,r4,#28             ;623
00005e  0ec0              LSRS     r0,r0,#27             ;623
000060  eb0010d4          ADD      r0,r0,r4,LSR #7       ;623
000064  1c40              ADDS     r0,r0,#1              ;623
000066  4a52              LDR      r2,|L10.432|
000068  f8320010          LDRH     r0,[r2,r0,LSL #1]     ;623
00006c  4281              CMP      r1,r0                 ;623
00006e  dd02              BLE      |L10.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;625
000074  e7cf              B        |L10.22|
                  |L10.118|
000076  2114              MOVS     r1,#0x14              ;629
000078  4640              MOV      r0,r8                 ;629
00007a  f7fffffe          BL       __aeabi_memclr4
00007e  f8a8600e          STRH     r6,[r8,#0xe]          ;632
000082  f1b90f00          CMP      r9,#0                 ;634
000086  d00c              BEQ      |L10.162|
000088  0720              LSLS     r0,r4,#28             ;635
00008a  0ec0              LSRS     r0,r0,#27             ;635
00008c  eb0010d4          ADD      r0,r0,r4,LSR #7       ;635
000090  4947              LDR      r1,|L10.432|
000092  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;635
000096  4947              LDR      r1,|L10.436|
000098  6809              LDR      r1,[r1,#0]            ;635  ; pBUF_DSCR
00009a  eb011105          ADD      r1,r1,r5,LSL #4       ;635
00009e  6008              STR      r0,[r1,#0]            ;635
0000a0  e027              B        |L10.242|
                  |L10.162|
0000a2  0720              LSLS     r0,r4,#28             ;637
0000a4  0ec0              LSRS     r0,r0,#27             ;637
0000a6  eb0010d4          ADD      r0,r0,r4,LSR #7       ;637
0000aa  4941              LDR      r1,|L10.432|
0000ac  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;637
0000b0  4940              LDR      r1,|L10.436|
0000b2  6809              LDR      r1,[r1,#0]            ;637  ; pBUF_DSCR
0000b4  eb011105          ADD      r1,r1,r5,LSL #4       ;637
0000b8  6088              STR      r0,[r1,#8]            ;637
0000ba  2e3e              CMP      r6,#0x3e              ;638
0000bc  dd0f              BLE      |L10.222|
0000be  f106001f          ADD      r0,r6,#0x1f           ;639
0000c2  f020001f          BIC      r0,r0,#0x1f           ;639
0000c6  b286              UXTH     r6,r0                 ;639
0000c8  2001              MOVS     r0,#1                 ;640
0000ca  ebc01046          RSB      r0,r0,r6,LSL #5       ;640
0000ce  f4404000          ORR      r0,r0,#0x8000         ;640
0000d2  4938              LDR      r1,|L10.436|
0000d4  6809              LDR      r1,[r1,#0]            ;640  ; pBUF_DSCR
0000d6  eb011105          ADD      r1,r1,r5,LSL #4       ;640
0000da  60c8              STR      r0,[r1,#0xc]          ;640
0000dc  e009              B        |L10.242|
                  |L10.222|
0000de  1c70              ADDS     r0,r6,#1              ;642
0000e0  f0200001          BIC      r0,r0,#1              ;642
0000e4  b286              UXTH     r6,r0                 ;642
0000e6  0270              LSLS     r0,r6,#9              ;643
0000e8  4932              LDR      r1,|L10.436|
0000ea  6809              LDR      r1,[r1,#0]            ;643  ; pBUF_DSCR
0000ec  eb011105          ADD      r1,r1,r5,LSL #4       ;643
0000f0  60c8              STR      r0,[r1,#0xc]          ;643
                  |L10.242|
0000f2  f1ba0f00          CMP      r10,#0                ;647
0000f6  d009              BEQ      |L10.268|
0000f8  f1ba0f01          CMP      r10,#1                ;647
0000fc  d009              BEQ      |L10.274|
0000fe  f1ba0f02          CMP      r10,#2                ;647
000102  d009              BEQ      |L10.280|
000104  f1ba0f03          CMP      r10,#3                ;647
000108  d10b              BNE      |L10.290|
00010a  e007              B        |L10.284|
                  |L10.268|
00010c  f44f7700          MOV      r7,#0x200             ;649
000110  e007              B        |L10.290|
                  |L10.274|
000112  f44f6780          MOV      r7,#0x400             ;652
000116  e004              B        |L10.290|
                  |L10.280|
000118  2700              MOVS     r7,#0                 ;655
00011a  e002              B        |L10.290|
                  |L10.284|
00011c  f44f67c0          MOV      r7,#0x600             ;658
000120  bf00              NOP                            ;659
                  |L10.290|
000122  bf00              NOP                            ;650
000124  b924              CBNZ     r4,|L10.304|
000126  f44f5048          MOV      r0,#0x3200            ;664
00012a  4923              LDR      r1,|L10.440|
00012c  6008              STR      r0,[r1,#0]            ;664
00012e  e038              B        |L10.418|
                  |L10.304|
000130  2c80              CMP      r4,#0x80              ;665
000132  d036              BEQ      |L10.418|
000134  432f              ORRS     r7,r7,r5              ;666
000136  4921              LDR      r1,|L10.444|
000138  eb010085          ADD      r0,r1,r5,LSL #2       ;667
00013c  f8c07c00          STR      r7,[r0,#0xc00]        ;667
000140  f1b90f00          CMP      r9,#0                 ;669
000144  d016              BEQ      |L10.372|
000146  0728              LSLS     r0,r5,#28             ;670
000148  eb016090          ADD      r0,r1,r0,LSR #26      ;670
00014c  f8d00c00          LDR      r0,[r0,#0xc00]        ;670
000150  f64871ff          MOV      r1,#0x8fff            ;670
000154  4008              ANDS     r0,r0,r1              ;670
000156  f0400080          ORR      r0,r0,#0x80           ;670
00015a  f4404000          ORR      r0,r0,#0x8000         ;670
00015e  0729              LSLS     r1,r5,#28             ;670
000160  4a16              LDR      r2,|L10.444|
000162  eb026191          ADD      r1,r2,r1,LSR #26      ;670
000166  f8c10c00          STR      r0,[r1,#0xc00]        ;670
00016a  2120              MOVS     r1,#0x20              ;671
00016c  4628              MOV      r0,r5                 ;671
00016e  f7fffffe          BL       IN_EP_Status
000172  e016              B        |L10.418|
                  |L10.372|
000174  0728              LSLS     r0,r5,#28             ;673
000176  4911              LDR      r1,|L10.444|
000178  eb016090          ADD      r0,r1,r0,LSR #26      ;673
00017c  f8d00c00          LDR      r0,[r0,#0xc00]        ;673
000180  f64f718f          MOV      r1,#0xff8f            ;673
000184  4008              ANDS     r0,r0,r1              ;673
000186  f0400080          ORR      r0,r0,#0x80           ;673
00018a  f4404000          ORR      r0,r0,#0x8000         ;673
00018e  0729              LSLS     r1,r5,#28             ;673
000190  4a0a              LDR      r2,|L10.444|
000192  eb026191          ADD      r1,r2,r1,LSR #26      ;673
000196  f8c10c00          STR      r0,[r1,#0xc00]        ;673
00019a  1451              ASRS     r1,r2,#17             ;674
00019c  4628              MOV      r0,r5                 ;674
00019e  f7fffffe          BL       OUT_EP_Status
                  |L10.418|
0001a2  2000              MOVS     r0,#0                 ;678
0001a4  e737              B        |L10.22|
;;;680    
                          ENDP

0001a6  0000              DCW      0x0000
                  |L10.424|
                          DCD      hw_powered
                  |L10.428|
                          DCD      ||ep||
                  |L10.432|
                          DCD      EP_buff_offset
                  |L10.436|
                          DCD      pBUF_DSCR
                  |L10.440|
                          DCD      0x40005c00
                  |L10.444|
                          DCD      0x40005000

                          AREA ||i.USBD_EndpointStall||, CODE, READONLY, ALIGN=2

                  USBD_EndpointStall PROC
;;;727    */
;;;728    static int32_t USBD_EndpointStall (uint8_t ep_addr, bool stall) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;729      volatile ENDPOINT_t *ptr_ep;
;;;730      uint8_t              ep_num;
;;;731      bool                 ep_dir;
;;;732    
;;;733      ep_num = EP_NUM(ep_addr);
000008  f005040f          AND      r4,r5,#0xf
;;;734      if (ep_num > USBD_MAX_ENDPOINT_NUM) { return ARM_DRIVER_ERROR; }
00000c  2c08              CMP      r4,#8
00000e  d903              BLS      |L11.24|
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L11.20|
;;;735      if (hw_powered == false)            { return ARM_DRIVER_ERROR; }
;;;736    
;;;737      ptr_ep = &ep[EP_ID(ep_addr)];
;;;738      if (ptr_ep->active != 0U)           { return ARM_DRIVER_ERROR_BUSY; }
;;;739    
;;;740      ep_dir = (ep_addr & ARM_USB_ENDPOINT_DIRECTION_MASK) == ARM_USB_ENDPOINT_DIRECTION_MASK;
;;;741    
;;;742      if (stall == true) {
;;;743        if (ep_dir != 0U) {                                   // IN Endpoint
;;;744          IN_EP_Status(ep_num, EP_TX_STALL);                  // Stall IN Endpoint
;;;745        } else {                                              // OUT Endpoint
;;;746          OUT_EP_Status(ep_num, EP_RX_STALL);                 // Stall OUT Endpoint
;;;747        }
;;;748      } else {
;;;749        if (ep_dir != 0U) {                                   // IN Endpoint
;;;750          IN_EP_RESET(ep_num);                                // Reset DTog Bits
;;;751          IN_EP_Status(ep_num, EP_TX_NAK);                    // Clear STALL
;;;752        } else {                                              // OUT Endpoint
;;;753          OUT_EP_RESET(ep_num);                               // Reset DTog Bits
;;;754          OUT_EP_Status(ep_num, EP_RX_NAK);                   // Clear Stall
;;;755        }
;;;756      }
;;;757    
;;;758      return ARM_DRIVER_OK;
;;;759    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L11.24|
000018  482b              LDR      r0,|L11.200|
00001a  7800              LDRB     r0,[r0,#0]            ;735  ; hw_powered
00001c  b910              CBNZ     r0,|L11.36|
00001e  f04f30ff          MOV      r0,#0xffffffff        ;735
000022  e7f7              B        |L11.20|
                  |L11.36|
000024  0728              LSLS     r0,r5,#28             ;737
000026  0ec0              LSRS     r0,r0,#27             ;737
000028  eb0010d5          ADD      r0,r0,r5,LSR #7       ;737
00002c  eb000080          ADD      r0,r0,r0,LSL #2       ;737
000030  4926              LDR      r1,|L11.204|
000032  eb010880          ADD      r8,r1,r0,LSL #2       ;737
000036  f8980010          LDRB     r0,[r8,#0x10]         ;738
00003a  b110              CBZ      r0,|L11.66|
00003c  f06f0001          MVN      r0,#1                 ;738
000040  e7e8              B        |L11.20|
                  |L11.66|
000042  f3c516c0          UBFX     r6,r5,#7,#1           ;740
000046  2f01              CMP      r7,#1                 ;742
000048  d10b              BNE      |L11.98|
00004a  b126              CBZ      r6,|L11.86|
00004c  2110              MOVS     r1,#0x10              ;744
00004e  4620              MOV      r0,r4                 ;744
000050  f7fffffe          BL       IN_EP_Status
000054  e035              B        |L11.194|
                  |L11.86|
000056  f44f5180          MOV      r1,#0x1000            ;746
00005a  4620              MOV      r0,r4                 ;746
00005c  f7fffffe          BL       OUT_EP_Status
000060  e02f              B        |L11.194|
                  |L11.98|
000062  b1be              CBZ      r6,|L11.148|
000064  0720              LSLS     r0,r4,#28             ;750
000066  491a              LDR      r1,|L11.208|
000068  eb016090          ADD      r0,r1,r0,LSR #26      ;750
00006c  f8d00c00          LDR      r0,[r0,#0xc00]        ;750
000070  f64871ff          MOV      r1,#0x8fff            ;750
000074  4008              ANDS     r0,r0,r1              ;750
000076  f0400080          ORR      r0,r0,#0x80           ;750
00007a  f4404000          ORR      r0,r0,#0x8000         ;750
00007e  0721              LSLS     r1,r4,#28             ;750
000080  4a13              LDR      r2,|L11.208|
000082  eb026191          ADD      r1,r2,r1,LSR #26      ;750
000086  f8c10c00          STR      r0,[r1,#0xc00]        ;750
00008a  2120              MOVS     r1,#0x20              ;751
00008c  4620              MOV      r0,r4                 ;751
00008e  f7fffffe          BL       IN_EP_Status
000092  e016              B        |L11.194|
                  |L11.148|
000094  0720              LSLS     r0,r4,#28             ;753
000096  490e              LDR      r1,|L11.208|
000098  eb016090          ADD      r0,r1,r0,LSR #26      ;753
00009c  f8d00c00          LDR      r0,[r0,#0xc00]        ;753
0000a0  f64f718f          MOV      r1,#0xff8f            ;753
0000a4  4008              ANDS     r0,r0,r1              ;753
0000a6  f0400080          ORR      r0,r0,#0x80           ;753
0000aa  f4404000          ORR      r0,r0,#0x8000         ;753
0000ae  0721              LSLS     r1,r4,#28             ;753
0000b0  4a07              LDR      r2,|L11.208|
0000b2  eb026191          ADD      r1,r2,r1,LSR #26      ;753
0000b6  f8c10c00          STR      r0,[r1,#0xc00]        ;753
0000ba  1451              ASRS     r1,r2,#17             ;754
0000bc  4620              MOV      r0,r4                 ;754
0000be  f7fffffe          BL       OUT_EP_Status
                  |L11.194|
0000c2  2000              MOVS     r0,#0                 ;758
0000c4  e7a6              B        |L11.20|
;;;760    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L11.200|
                          DCD      hw_powered
                  |L11.204|
                          DCD      ||ep||
                  |L11.208|
                          DCD      0x40005000

                          AREA ||i.USBD_EndpointTransfer||, CODE, READONLY, ALIGN=2

                  USBD_EndpointTransfer PROC
;;;770    */
;;;771    static int32_t USBD_EndpointTransfer (uint8_t ep_addr, uint8_t *data, uint32_t num) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;772      volatile ENDPOINT_t *ptr_ep;
;;;773      uint8_t              ep_num;
;;;774      bool                 ep_dir;
;;;775    
;;;776      ep_num = EP_NUM(ep_addr);
00000a  f005080f          AND      r8,r5,#0xf
;;;777      if (ep_num > USBD_MAX_ENDPOINT_NUM) { return ARM_DRIVER_ERROR; }
00000e  f1b80f08          CMP      r8,#8
000012  d903              BLS      |L12.28|
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L12.24|
;;;778      if (hw_powered == false)            { return ARM_DRIVER_ERROR; }
;;;779    
;;;780      ptr_ep = &ep[EP_ID(ep_addr)];
;;;781      if (ptr_ep->active != 0U)           { return ARM_DRIVER_ERROR_BUSY; }
;;;782    
;;;783      ep_dir = (ep_addr & ARM_USB_ENDPOINT_DIRECTION_MASK) == ARM_USB_ENDPOINT_DIRECTION_MASK;
;;;784    
;;;785      ptr_ep->active = 1U;
;;;786    
;;;787      ptr_ep->data                  = data;
;;;788      ptr_ep->num                   = num;
;;;789      ptr_ep->num_transferred_total = 0U;
;;;790      ptr_ep->num_transferring      = 0U;
;;;791    
;;;792      if (ep_dir != 0U) {                                   // IN Endpoint
;;;793        USBD_EP_HW_Write (ep_addr);                         // Write data to Endpoint buffer
;;;794      } else {                                              // OUT Endpoint
;;;795        OUT_EP_Status(ep_num, EP_RX_VALID);                 // OUT EP able to receive data
;;;796      }
;;;797    
;;;798      return ARM_DRIVER_OK;
;;;799    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L12.28|
00001c  4815              LDR      r0,|L12.116|
00001e  7800              LDRB     r0,[r0,#0]            ;778  ; hw_powered
000020  b910              CBNZ     r0,|L12.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;778
000026  e7f7              B        |L12.24|
                  |L12.40|
000028  0728              LSLS     r0,r5,#28             ;780
00002a  0ec0              LSRS     r0,r0,#27             ;780
00002c  eb0010d5          ADD      r0,r0,r5,LSR #7       ;780
000030  eb000080          ADD      r0,r0,r0,LSL #2       ;780
000034  4910              LDR      r1,|L12.120|
000036  eb010480          ADD      r4,r1,r0,LSL #2       ;780
00003a  7c20              LDRB     r0,[r4,#0x10]         ;781
00003c  b110              CBZ      r0,|L12.68|
00003e  f06f0001          MVN      r0,#1                 ;781
000042  e7e9              B        |L12.24|
                  |L12.68|
000044  f3c519c0          UBFX     r9,r5,#7,#1           ;783
000048  2001              MOVS     r0,#1                 ;785
00004a  7420              STRB     r0,[r4,#0x10]         ;785
00004c  6026              STR      r6,[r4,#0]            ;787
00004e  6067              STR      r7,[r4,#4]            ;788
000050  2000              MOVS     r0,#0                 ;789
000052  60a0              STR      r0,[r4,#8]            ;789
000054  81a0              STRH     r0,[r4,#0xc]          ;790
000056  f1b90f00          CMP      r9,#0                 ;792
00005a  d003              BEQ      |L12.100|
00005c  4628              MOV      r0,r5                 ;793
00005e  f7fffffe          BL       USBD_EP_HW_Write
000062  e004              B        |L12.110|
                  |L12.100|
000064  f44f5140          MOV      r1,#0x3000            ;795
000068  4640              MOV      r0,r8                 ;795
00006a  f7fffffe          BL       OUT_EP_Status
                  |L12.110|
00006e  2000              MOVS     r0,#0                 ;798
000070  e7d2              B        |L12.24|
;;;800    
                          ENDP

000072  0000              DCW      0x0000
                  |L12.116|
                          DCD      hw_powered
                  |L12.120|
                          DCD      ||ep||

                          AREA ||i.USBD_EndpointTransferAbort||, CODE, READONLY, ALIGN=2

                  USBD_EndpointTransferAbort PROC
;;;823    */
;;;824    static int32_t USBD_EndpointTransferAbort (uint8_t ep_addr) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4604              MOV      r4,r0
;;;825      volatile ENDPOINT_t *ptr_ep;
;;;826      uint8_t              ep_num;
;;;827      bool                 ep_dir;
;;;828    
;;;829      ep_num = EP_NUM(ep_addr);
000004  f004060f          AND      r6,r4,#0xf
;;;830      if (ep_num > USBD_MAX_ENDPOINT_NUM) { return ARM_DRIVER_ERROR; }
000008  2e08              CMP      r6,#8
00000a  d902              BLS      |L13.18|
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L13.16|
;;;831      if (hw_powered == false)            { return ARM_DRIVER_ERROR; }
;;;832    
;;;833      ep_dir = (ep_addr & ARM_USB_ENDPOINT_DIRECTION_MASK) == ARM_USB_ENDPOINT_DIRECTION_MASK;
;;;834      ptr_ep = &ep[EP_ID(ep_addr)];
;;;835    
;;;836      ptr_ep->num    = 0U;
;;;837    
;;;838      if (ep_dir != 0U) {                                   // IN Endpoint
;;;839        IN_EP_Status(ep_num, EP_TX_NAK);                    // Set NAK
;;;840      } else {                                              // OUT Endpoint
;;;841        OUT_EP_Status(ep_num, EP_RX_NAK);                   // Set NAK
;;;842      }
;;;843    
;;;844      ptr_ep->active = 0U;
;;;845    
;;;846      return ARM_DRIVER_OK;
;;;847    }
000010  bdf0              POP      {r4-r7,pc}
                  |L13.18|
000012  4811              LDR      r0,|L13.88|
000014  7800              LDRB     r0,[r0,#0]            ;831  ; hw_powered
000016  b910              CBNZ     r0,|L13.30|
000018  f04f30ff          MOV      r0,#0xffffffff        ;831
00001c  e7f8              B        |L13.16|
                  |L13.30|
00001e  f3c417c0          UBFX     r7,r4,#7,#1           ;833
000022  0720              LSLS     r0,r4,#28             ;834
000024  0ec0              LSRS     r0,r0,#27             ;834
000026  eb0010d4          ADD      r0,r0,r4,LSR #7       ;834
00002a  eb000080          ADD      r0,r0,r0,LSL #2       ;834
00002e  490b              LDR      r1,|L13.92|
000030  eb010580          ADD      r5,r1,r0,LSL #2       ;834
000034  2000              MOVS     r0,#0                 ;836
000036  6068              STR      r0,[r5,#4]            ;836
000038  b127              CBZ      r7,|L13.68|
00003a  2120              MOVS     r1,#0x20              ;839
00003c  4630              MOV      r0,r6                 ;839
00003e  f7fffffe          BL       IN_EP_Status
000042  e004              B        |L13.78|
                  |L13.68|
000044  f44f5100          MOV      r1,#0x2000            ;841
000048  4630              MOV      r0,r6                 ;841
00004a  f7fffffe          BL       OUT_EP_Status
                  |L13.78|
00004e  2000              MOVS     r0,#0                 ;844
000050  7428              STRB     r0,[r5,#0x10]         ;844
000052  bf00              NOP                            ;846
000054  e7dc              B        |L13.16|
;;;848    
                          ENDP

000056  0000              DCW      0x0000
                  |L13.88|
                          DCD      hw_powered
                  |L13.92|
                          DCD      ||ep||

                          AREA ||i.USBD_EndpointTransferGetResult||, CODE, READONLY, ALIGN=2

                  USBD_EndpointTransferGetResult PROC
;;;808    */
;;;809    static uint32_t USBD_EndpointTransferGetResult (uint8_t ep_addr) {
000000  4601              MOV      r1,r0
;;;810    
;;;811      if (EP_NUM(ep_addr) > USBD_MAX_ENDPOINT_NUM) { return 0U; }
000002  f001000f          AND      r0,r1,#0xf
000006  2808              CMP      r0,#8
000008  d901              BLS      |L14.14|
00000a  2000              MOVS     r0,#0
                  |L14.12|
;;;812    
;;;813      return (ep[EP_ID(ep_addr)].num_transferred_total);
;;;814    }
00000c  4770              BX       lr
                  |L14.14|
00000e  0708              LSLS     r0,r1,#28             ;813
000010  0ec0              LSRS     r0,r0,#27             ;813
000012  eb0010d1          ADD      r0,r0,r1,LSR #7       ;813
000016  eb000080          ADD      r0,r0,r0,LSL #2       ;813
00001a  4a02              LDR      r2,|L14.36|
00001c  eb020080          ADD      r0,r2,r0,LSL #2       ;813
000020  6880              LDR      r0,[r0,#8]            ;813
000022  e7f3              B        |L14.12|
;;;815    
                          ENDP

                  |L14.36|
                          DCD      ||ep||

                          AREA ||i.USBD_EndpointUnconfigure||, CODE, READONLY, ALIGN=2

                  USBD_EndpointUnconfigure PROC
;;;688    */
;;;689    static int32_t USBD_EndpointUnconfigure (uint8_t ep_addr) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
;;;690      volatile ENDPOINT_t *ptr_ep;
;;;691      uint8_t              ep_num;
;;;692      bool                 ep_dir;
;;;693    
;;;694      ep_num = EP_NUM(ep_addr);
000006  f005040f          AND      r4,r5,#0xf
;;;695      if (ep_num > USBD_MAX_ENDPOINT_NUM) { return ARM_DRIVER_ERROR; }
00000a  2c08              CMP      r4,#8
00000c  d903              BLS      |L15.22|
00000e  f04f30ff          MOV      r0,#0xffffffff
                  |L15.18|
;;;696      if (hw_powered == false)            { return ARM_DRIVER_ERROR; }
;;;697    
;;;698      ptr_ep = &ep[EP_ID(ep_addr)];
;;;699      if (ptr_ep->active != 0U)           { return ARM_DRIVER_ERROR_BUSY; }
;;;700    
;;;701      ep_dir = (ep_addr & ARM_USB_ENDPOINT_DIRECTION_MASK) == ARM_USB_ENDPOINT_DIRECTION_MASK;
;;;702    
;;;703      if (ep_dir != 0U) {                                   // IN Endpoint
;;;704        IN_EP_RESET(ep_num);
;;;705        IN_EP_Status(ep_num, EP_TX_DIS);
;;;706      } else {                                              // OUT Endpoint
;;;707        OUT_EP_RESET(ep_num);
;;;708        OUT_EP_Status(ep_num, EP_RX_DIS);
;;;709      }
;;;710    
;;;711      // Clear Endpoint transfer and configuration information
;;;712      memset((void *)(ptr_ep), 0, sizeof (ENDPOINT_t));
;;;713    
;;;714      return ARM_DRIVER_OK;
;;;715    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L15.22|
000016  4826              LDR      r0,|L15.176|
000018  7800              LDRB     r0,[r0,#0]            ;696  ; hw_powered
00001a  b910              CBNZ     r0,|L15.34|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;696
000020  e7f7              B        |L15.18|
                  |L15.34|
000022  0728              LSLS     r0,r5,#28             ;698
000024  0ec0              LSRS     r0,r0,#27             ;698
000026  eb0010d5          ADD      r0,r0,r5,LSR #7       ;698
00002a  eb000080          ADD      r0,r0,r0,LSL #2       ;698
00002e  4921              LDR      r1,|L15.180|
000030  eb010680          ADD      r6,r1,r0,LSL #2       ;698
000034  7c30              LDRB     r0,[r6,#0x10]         ;699
000036  b110              CBZ      r0,|L15.62|
000038  f06f0001          MVN      r0,#1                 ;699
00003c  e7e9              B        |L15.18|
                  |L15.62|
00003e  f3c517c0          UBFX     r7,r5,#7,#1           ;701
000042  b1bf              CBZ      r7,|L15.116|
000044  0720              LSLS     r0,r4,#28             ;704
000046  491c              LDR      r1,|L15.184|
000048  eb016090          ADD      r0,r1,r0,LSR #26      ;704
00004c  f8d00c00          LDR      r0,[r0,#0xc00]        ;704
000050  f64871ff          MOV      r1,#0x8fff            ;704
000054  4008              ANDS     r0,r0,r1              ;704
000056  f0400080          ORR      r0,r0,#0x80           ;704
00005a  f4404000          ORR      r0,r0,#0x8000         ;704
00005e  0721              LSLS     r1,r4,#28             ;704
000060  4a15              LDR      r2,|L15.184|
000062  eb026191          ADD      r1,r2,r1,LSR #26      ;704
000066  f8c10c00          STR      r0,[r1,#0xc00]        ;704
00006a  2100              MOVS     r1,#0                 ;705
00006c  4620              MOV      r0,r4                 ;705
00006e  f7fffffe          BL       IN_EP_Status
000072  e016              B        |L15.162|
                  |L15.116|
000074  0720              LSLS     r0,r4,#28             ;707
000076  4910              LDR      r1,|L15.184|
000078  eb016090          ADD      r0,r1,r0,LSR #26      ;707
00007c  f8d00c00          LDR      r0,[r0,#0xc00]        ;707
000080  f64f718f          MOV      r1,#0xff8f            ;707
000084  4008              ANDS     r0,r0,r1              ;707
000086  f0400080          ORR      r0,r0,#0x80           ;707
00008a  f4404000          ORR      r0,r0,#0x8000         ;707
00008e  0721              LSLS     r1,r4,#28             ;707
000090  4a09              LDR      r2,|L15.184|
000092  eb026191          ADD      r1,r2,r1,LSR #26      ;707
000096  f8c10c00          STR      r0,[r1,#0xc00]        ;707
00009a  2100              MOVS     r1,#0                 ;708
00009c  4620              MOV      r0,r4                 ;708
00009e  f7fffffe          BL       OUT_EP_Status
                  |L15.162|
0000a2  2114              MOVS     r1,#0x14              ;712
0000a4  4630              MOV      r0,r6                 ;712
0000a6  f7fffffe          BL       __aeabi_memclr4
0000aa  2000              MOVS     r0,#0                 ;714
0000ac  e7b1              B        |L15.18|
;;;716    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L15.176|
                          DCD      hw_powered
                  |L15.180|
                          DCD      ||ep||
                  |L15.184|
                          DCD      0x40005000

                          AREA ||i.USBD_GetCapabilities||, CODE, READONLY, ALIGN=2

                  USBD_GetCapabilities PROC
;;;380    */
;;;381    static ARM_USBD_CAPABILITIES USBD_GetCapabilities (void) { return usbd_driver_capabilities; }
000000  4801              LDR      r0,|L16.8|
000002  6800              LDR      r0,[r0,#0]  ; usbd_driver_capabilities
000004  4770              BX       lr
;;;382    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      usbd_driver_capabilities

                          AREA ||i.USBD_GetFrameNumber||, CODE, READONLY, ALIGN=2

                  USBD_GetFrameNumber PROC
;;;853    */
;;;854    static uint16_t USBD_GetFrameNumber (void) {
000000  4804              LDR      r0,|L17.20|
;;;855    
;;;856      if (hw_powered == false) { return 0U; }
000002  7800              LDRB     r0,[r0,#0]  ; hw_powered
000004  b908              CBNZ     r0,|L17.10|
000006  2000              MOVS     r0,#0
                  |L17.8|
;;;857    
;;;858      return (FNR & FNR_FN);
;;;859    }
000008  4770              BX       lr
                  |L17.10|
00000a  4803              LDR      r0,|L17.24|
00000c  6800              LDR      r0,[r0,#0]            ;858
00000e  f3c0000a          UBFX     r0,r0,#0,#11          ;858
000012  e7f9              B        |L17.8|
;;;860    
                          ENDP

                  |L17.20|
                          DCD      hw_powered
                  |L17.24|
                          DCD      0x40005c48

                          AREA ||i.USBD_GetVersion||, CODE, READONLY, ALIGN=2

                  USBD_GetVersion PROC
;;;373    */
;;;374    static ARM_DRIVER_VERSION USBD_GetVersion (void) { return usbd_driver_version; }
000000  b508              PUSH     {r3,lr}
000002  4802              LDR      r0,|L18.12|
000004  6800              LDR      r0,[r0,#0]  ; usbd_driver_version
000006  9000              STR      r0,[sp,#0]
000008  bd08              POP      {r3,pc}
;;;375    
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      usbd_driver_version

                          AREA ||i.USBD_Initialize||, CODE, READONLY, ALIGN=2

                  USBD_Initialize PROC
;;;390    */
;;;391    static int32_t USBD_Initialize (ARM_USBD_SignalDeviceEvent_t   cb_device_event,
000000  4602              MOV      r2,r0
;;;392                                    ARM_USBD_SignalEndpointEvent_t cb_endpoint_event) {
;;;393    
;;;394      if (hw_initialized == true) {
000002  4807              LDR      r0,|L19.32|
000004  7800              LDRB     r0,[r0,#0]  ; hw_initialized
000006  2801              CMP      r0,#1
000008  d101              BNE      |L19.14|
;;;395        return ARM_DRIVER_OK;
00000a  2000              MOVS     r0,#0
                  |L19.12|
;;;396      }
;;;397    
;;;398      SignalDeviceEvent   = cb_device_event;
;;;399      SignalEndpointEvent = cb_endpoint_event;
;;;400    
;;;401    #if (RTE_USB_DEVICE_CON_PIN)
;;;402      // Configure CON pin (controls pull-up on D+ line)
;;;403      GPIO_PortClock (RTE_USB_DEVICE_CON_PORT, true);
;;;404      GPIO_PinWrite (RTE_USB_DEVICE_CON_PORT, RTE_USB_DEVICE_CON_BIT, !RTE_USB_DEVICE_CON_ACTIVE);
;;;405      if (!GPIO_PinConfigure(RTE_USB_DEVICE_CON_PORT, RTE_USB_DEVICE_CON_BIT, GPIO_OUT_OPENDRAIN, GPIO_MODE_OUT10MHZ)) { return ARM_DRIVER_ERROR; }
;;;406    #endif
;;;407    
;;;408      hw_initialized = true;
;;;409    
;;;410      return ARM_DRIVER_OK;
;;;411    }
00000c  4770              BX       lr
                  |L19.14|
00000e  4805              LDR      r0,|L19.36|
000010  6002              STR      r2,[r0,#0]            ;398  ; SignalDeviceEvent
000012  4805              LDR      r0,|L19.40|
000014  6001              STR      r1,[r0,#0]            ;399  ; SignalEndpointEvent
000016  2001              MOVS     r0,#1                 ;408
000018  4b01              LDR      r3,|L19.32|
00001a  7018              STRB     r0,[r3,#0]            ;408
00001c  2000              MOVS     r0,#0                 ;410
00001e  e7f5              B        |L19.12|
;;;412    
                          ENDP

                  |L19.32|
                          DCD      hw_initialized
                  |L19.36|
                          DCD      SignalDeviceEvent
                  |L19.40|
                          DCD      SignalEndpointEvent

                          AREA ||i.USBD_PowerControl||, CODE, READONLY, ALIGN=2

                  USBD_PowerControl PROC
;;;437    */
;;;438    static int32_t USBD_PowerControl (ARM_POWER_STATE state) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;439    
;;;440      switch (state) {
000004  b114              CBZ      r4,|L20.12|
000006  2c02              CMP      r4,#2
000008  d17d              BNE      |L20.262|
00000a  e04b              B        |L20.164|
                  |L20.12|
;;;441        case ARM_POWER_OFF:
;;;442          RCC->APB1ENR  |=  RCC_APB1ENR_USBEN;              // Enable USB Device clock
00000c  4845              LDR      r0,|L20.292|
00000e  69c0              LDR      r0,[r0,#0x1c]
000010  f4400000          ORR      r0,r0,#0x800000
000014  4943              LDR      r1,|L20.292|
000016  61c8              STR      r0,[r1,#0x1c]
;;;443          NVIC_DisableIRQ      (USB_LP_CAN1_RX0_IRQn);      // Disable interrupt
000018  2014              MOVS     r0,#0x14
00001a  2800              CMP      r0,#0
00001c  db17              BLT      |L20.78|
00001e  f000021f          AND      r2,r0,#0x1f
000022  2101              MOVS     r1,#1
000024  4091              LSLS     r1,r1,r2
000026  4a40              LDR      r2,|L20.296|
000028  0943              LSRS     r3,r0,#5
00002a  f8421023          STR      r1,[r2,r3,LSL #2]
00002e  bf00              NOP      
000030  bf00              NOP      
000032  bf00              NOP      
000034  f3bf8f4f          DSB      
000038  bf00              NOP      
00003a  bf00              NOP      
00003c  bf00              NOP      
00003e  bf00              NOP      
000040  bf00              NOP      
000042  bf00              NOP      
000044  f3bf8f6f          ISB      
000048  bf00              NOP      
00004a  bf00              NOP      
00004c  bf00              NOP      
                  |L20.78|
00004e  bf00              NOP      
;;;444          NVIC_ClearPendingIRQ (USB_LP_CAN1_RX0_IRQn);      // Clear pending interrupt
000050  2014              MOVS     r0,#0x14
000052  2800              CMP      r0,#0
000054  db07              BLT      |L20.102|
000056  f000021f          AND      r2,r0,#0x1f
00005a  2101              MOVS     r1,#1
00005c  4091              LSLS     r1,r1,r2
00005e  4a33              LDR      r2,|L20.300|
000060  0943              LSRS     r3,r0,#5
000062  f8421023          STR      r1,[r2,r3,LSL #2]
                  |L20.102|
000066  bf00              NOP      
;;;445    
;;;446          hw_powered     = false;                           // Clear powered flag
000068  2000              MOVS     r0,#0
00006a  4931              LDR      r1,|L20.304|
00006c  7008              STRB     r0,[r1,#0]
;;;447          CNTR = CNTR_FRES | CNTR_PDWN;                     // Switch off USB Device
00006e  2003              MOVS     r0,#3
000070  4930              LDR      r1,|L20.308|
000072  6008              STR      r0,[r1,#0]
;;;448    #if (RTE_USB_DEVICE_CON_PIN)
;;;449          if (!GPIO_PinConfigure(RTE_USB_DEVICE_CON_PORT, RTE_USB_DEVICE_CON_BIT, GPIO_IN_FLOATING, GPIO_MODE_INPUT)) { return ARM_DRIVER_ERROR; }
;;;450    #endif
;;;451          RCC->APB1RSTR  |=  RCC_APB1RSTR_USBRST;           // Reset USB Device
000074  482b              LDR      r0,|L20.292|
000076  6900              LDR      r0,[r0,#0x10]
000078  f4400000          ORR      r0,r0,#0x800000
00007c  4929              LDR      r1,|L20.292|
00007e  6108              STR      r0,[r1,#0x10]
;;;452    
;;;453                                                            // Reset variables
;;;454          setup_received =  0U;
000080  2000              MOVS     r0,#0
000082  492d              LDR      r1,|L20.312|
000084  7008              STRB     r0,[r1,#0]
;;;455          memset((void *)&usbd_state, 0, sizeof(usbd_state));
000086  482d              LDR      r0,|L20.316|
000088  2100              MOVS     r1,#0
00008a  6001              STR      r1,[r0,#0]  ; usbd_state
;;;456          memset((void *)ep,          0, sizeof(ep));
00008c  f44f71b4          MOV      r1,#0x168
000090  482b              LDR      r0,|L20.320|
000092  f7fffffe          BL       __aeabi_memclr4
;;;457    
;;;458          RCC->APB1ENR   &= ~RCC_APB1ENR_USBEN;             // Disable USB Device clock
000096  4823              LDR      r0,|L20.292|
000098  69c0              LDR      r0,[r0,#0x1c]
00009a  f4200000          BIC      r0,r0,#0x800000
00009e  4921              LDR      r1,|L20.292|
0000a0  61c8              STR      r0,[r1,#0x1c]
;;;459    
;;;460          break;
0000a2  e03c              B        |L20.286|
                  |L20.164|
;;;461    
;;;462        case ARM_POWER_FULL:
;;;463          if (hw_initialized == false) {
0000a4  4827              LDR      r0,|L20.324|
0000a6  7800              LDRB     r0,[r0,#0]  ; hw_initialized
0000a8  b910              CBNZ     r0,|L20.176|
;;;464            return ARM_DRIVER_ERROR;
0000aa  f04f30ff          MOV      r0,#0xffffffff
                  |L20.174|
;;;465          }
;;;466          if (hw_powered     == true) {
;;;467            return ARM_DRIVER_OK;
;;;468          }
;;;469    
;;;470          RCC->APB1ENR   |=  RCC_APB1ENR_USBEN;             // Enable USB Device clock
;;;471          RCC->APB1RSTR  |=  RCC_APB1RSTR_USBRST;           // Reset USB Device
;;;472          osDelay(1);                                       // Wait 1 ms
;;;473          RCC->APB1RSTR  &= ~RCC_APB1RSTR_USBRST;           // Reset USB Device
;;;474    
;;;475          USBD_Reset ();                                    // Reset variables and endpoint settings
;;;476    
;;;477          hw_powered     = true;                            // Set powered flag
;;;478    
;;;479          NVIC_EnableIRQ   (USB_LP_CAN1_RX0_IRQn);          // Enable interrupt
;;;480          break;
;;;481    
;;;482        default:
;;;483          return ARM_DRIVER_ERROR_UNSUPPORTED;
;;;484      }
;;;485    
;;;486      return ARM_DRIVER_OK;
;;;487    }
0000ae  bd10              POP      {r4,pc}
                  |L20.176|
0000b0  481f              LDR      r0,|L20.304|
0000b2  7800              LDRB     r0,[r0,#0]            ;466  ; hw_powered
0000b4  2801              CMP      r0,#1                 ;466
0000b6  d101              BNE      |L20.188|
0000b8  2000              MOVS     r0,#0                 ;467
0000ba  e7f8              B        |L20.174|
                  |L20.188|
0000bc  4819              LDR      r0,|L20.292|
0000be  69c0              LDR      r0,[r0,#0x1c]         ;470
0000c0  f4400000          ORR      r0,r0,#0x800000       ;470
0000c4  4917              LDR      r1,|L20.292|
0000c6  61c8              STR      r0,[r1,#0x1c]         ;470
0000c8  4608              MOV      r0,r1                 ;471
0000ca  6900              LDR      r0,[r0,#0x10]         ;471
0000cc  f4400000          ORR      r0,r0,#0x800000       ;471
0000d0  6108              STR      r0,[r1,#0x10]         ;471
0000d2  2001              MOVS     r0,#1                 ;472
0000d4  f7fffffe          BL       osDelay
0000d8  4812              LDR      r0,|L20.292|
0000da  6900              LDR      r0,[r0,#0x10]         ;473
0000dc  f4200000          BIC      r0,r0,#0x800000       ;473
0000e0  4910              LDR      r1,|L20.292|
0000e2  6108              STR      r0,[r1,#0x10]         ;473
0000e4  f7fffffe          BL       USBD_Reset
0000e8  2001              MOVS     r0,#1                 ;477
0000ea  4911              LDR      r1,|L20.304|
0000ec  7008              STRB     r0,[r1,#0]            ;477
0000ee  2014              MOVS     r0,#0x14              ;479
0000f0  2800              CMP      r0,#0                 ;479
0000f2  db0f              BLT      |L20.276|
0000f4  bf00              NOP                            ;479
0000f6  bf00              NOP                            ;479
0000f8  f000021f          AND      r2,r0,#0x1f           ;479
0000fc  2101              MOVS     r1,#1                 ;479
0000fe  4091              LSLS     r1,r1,r2              ;479
000100  0942              LSRS     r2,r0,#5              ;479
000102  0092              LSLS     r2,r2,#2              ;479
000104  e000              B        |L20.264|
                  |L20.262|
000106  e007              B        |L20.280|
                  |L20.264|
000108  f10222e0          ADD      r2,r2,#0xe000e000     ;479
00010c  f8c21100          STR      r1,[r2,#0x100]        ;479
000110  bf00              NOP                            ;479
000112  bf00              NOP                            ;479
                  |L20.276|
000114  bf00              NOP                            ;479
000116  e002              B        |L20.286|
                  |L20.280|
000118  f06f0003          MVN      r0,#3                 ;483
00011c  e7c7              B        |L20.174|
                  |L20.286|
00011e  bf00              NOP                            ;460
000120  2000              MOVS     r0,#0                 ;486
000122  e7c4              B        |L20.174|
;;;488    
                          ENDP

                  |L20.292|
                          DCD      0x40021000
                  |L20.296|
                          DCD      0xe000e180
                  |L20.300|
                          DCD      0xe000e280
                  |L20.304|
                          DCD      hw_powered
                  |L20.308|
                          DCD      0x40005c40
                  |L20.312|
                          DCD      setup_received
                  |L20.316|
                          DCD      usbd_state
                  |L20.320|
                          DCD      ||ep||
                  |L20.324|
                          DCD      hw_initialized

                          AREA ||i.USBD_ReadSetupPacket||, CODE, READONLY, ALIGN=2

                  USBD_ReadSetupPacket PROC
;;;575    */
;;;576    static int32_t USBD_ReadSetupPacket (uint8_t *setup) {
000000  4601              MOV      r1,r0
;;;577    
;;;578      if (hw_powered == false)  { return ARM_DRIVER_ERROR; }
000002  480e              LDR      r0,|L21.60|
000004  7800              LDRB     r0,[r0,#0]  ; hw_powered
000006  b910              CBNZ     r0,|L21.14|
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L21.12|
;;;579      if (setup_received == 0U) { return ARM_DRIVER_ERROR; }
;;;580    
;;;581      setup_received = 0U;
;;;582      memcpy(setup, setup_packet, 8);
;;;583    
;;;584      if (setup_received != 0U) {           // If new setup packet was received while this was being read
;;;585        return ARM_DRIVER_ERROR;
;;;586      }
;;;587    
;;;588      return ARM_DRIVER_OK;
;;;589    }
00000c  4770              BX       lr
                  |L21.14|
00000e  480c              LDR      r0,|L21.64|
000010  7800              LDRB     r0,[r0,#0]            ;579  ; setup_received
000012  b910              CBNZ     r0,|L21.26|
000014  f04f30ff          MOV      r0,#0xffffffff        ;579
000018  e7f8              B        |L21.12|
                  |L21.26|
00001a  2000              MOVS     r0,#0                 ;581
00001c  4a08              LDR      r2,|L21.64|
00001e  7010              STRB     r0,[r2,#0]            ;581
000020  4808              LDR      r0,|L21.68|
000022  6802              LDR      r2,[r0,#0]            ;582  ; setup_packet
000024  600a              STR      r2,[r1,#0]            ;582
000026  6840              LDR      r0,[r0,#4]            ;582  ; setup_packet
000028  6048              STR      r0,[r1,#4]            ;582
00002a  4805              LDR      r0,|L21.64|
00002c  7800              LDRB     r0,[r0,#0]            ;584  ; setup_received
00002e  b110              CBZ      r0,|L21.54|
000030  f04f30ff          MOV      r0,#0xffffffff        ;585
000034  e7ea              B        |L21.12|
                  |L21.54|
000036  2000              MOVS     r0,#0                 ;588
000038  e7e8              B        |L21.12|
;;;590    
                          ENDP

00003a  0000              DCW      0x0000
                  |L21.60|
                          DCD      hw_powered
                  |L21.64|
                          DCD      setup_received
                  |L21.68|
                          DCD      setup_packet

                          AREA ||i.USBD_Reset||, CODE, READONLY, ALIGN=2

                  USBD_Reset PROC
;;;347    */
;;;348    static void USBD_Reset (void) {
000000  b510              PUSH     {r4,lr}
;;;349    
;;;350      ISTR = 0;                                 // Clear Interrupt Status
000002  2000              MOVS     r0,#0
000004  490e              LDR      r1,|L22.64|
000006  6008              STR      r0,[r1,#0]
;;;351    
;;;352      CNTR = CNTR_CTRM | CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM | CNTR_ERRM | CNTR_PMAOVRM;
000008  f44f407c          MOV      r0,#0xfc00
00000c  1f09              SUBS     r1,r1,#4
00000e  6008              STR      r0,[r1,#0]
;;;353    
;;;354    
;;;355      // Reset global variables
;;;356      setup_received  = 0U;
000010  2000              MOVS     r0,#0
000012  490c              LDR      r1,|L22.68|
000014  7008              STRB     r0,[r1,#0]
;;;357      memset((void *)USB_PMA_ADDR, 0, EP_BUF_ADDR);
000016  2180              MOVS     r1,#0x80
000018  480b              LDR      r0,|L22.72|
00001a  f7fffffe          BL       __aeabi_memclr4
;;;358      memset((void *)&usbd_state,  0, sizeof(usbd_state));
00001e  480b              LDR      r0,|L22.76|
000020  2100              MOVS     r1,#0
000022  6001              STR      r1,[r0,#0]  ; usbd_state
;;;359      memset((void *)ep,           0, sizeof(ep));
000024  f44f71b4          MOV      r1,#0x168
000028  4809              LDR      r0,|L22.80|
00002a  f7fffffe          BL       __aeabi_memclr4
;;;360    
;;;361      BTABLE = 0x00;                        // set BTABLE Address
00002e  2000              MOVS     r0,#0
000030  4903              LDR      r1,|L22.64|
000032  310c              ADDS     r1,r1,#0xc
000034  6008              STR      r0,[r1,#0]
;;;362    
;;;363      DADDR = DADDR_EF | 0;                 // Enable USB Default Address
000036  2080              MOVS     r0,#0x80
000038  1f09              SUBS     r1,r1,#4
00003a  6008              STR      r0,[r1,#0]
;;;364    }
00003c  bd10              POP      {r4,pc}
;;;365    
                          ENDP

00003e  0000              DCW      0x0000
                  |L22.64|
                          DCD      0x40005c44
                  |L22.68|
                          DCD      setup_received
                  |L22.72|
                          DCD      0x40006000
                  |L22.76|
                          DCD      usbd_state
                  |L22.80|
                          DCD      ||ep||

                          AREA ||i.USBD_Uninitialize||, CODE, READONLY, ALIGN=2

                  USBD_Uninitialize PROC
;;;417    */
;;;418    static int32_t USBD_Uninitialize (void) {
000000  2000              MOVS     r0,#0
;;;419    
;;;420    #if (RTE_USB_DEVICE_CON_PIN)
;;;421      // Unconfigure CON pin (controls pull-up on D+ line)
;;;422      GPIO_PortClock (RTE_USB_DEVICE_CON_PORT, true);
;;;423      GPIO_PinWrite (RTE_USB_DEVICE_CON_PORT, RTE_USB_DEVICE_CON_BIT, !RTE_USB_DEVICE_CON_ACTIVE);
;;;424      if (!GPIO_PinConfigure(RTE_USB_DEVICE_CON_PORT, RTE_USB_DEVICE_CON_BIT, GPIO_IN_FLOATING, GPIO_MODE_INPUT))  { return ARM_DRIVER_ERROR; }
;;;425    #endif
;;;426    
;;;427      hw_initialized = false;
000002  4901              LDR      r1,|L23.8|
000004  7008              STRB     r0,[r1,#0]
;;;428    
;;;429      return ARM_DRIVER_OK;
;;;430    }
000006  4770              BX       lr
;;;431    
                          ENDP

                  |L23.8|
                          DCD      hw_initialized

                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;864    */
;;;865    void USB_LP_CAN1_RX0_IRQHandler (void)  {
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;866      __packed uint16_t   *ptr_dest;
;;;867      volatile uint32_t   *ptr_src;
;;;868      volatile ENDPOINT_t *ptr_ep;
;;;869               uint32_t    istr, ep_num, val, i;
;;;870    
;;;871      istr = ISTR;
000004  486d              LDR      r0,|L24.444|
000006  6806              LDR      r6,[r0,#0]
;;;872    
;;;873    // Reset interrupt
;;;874      if (istr & ISTR_RESET) {
000008  f4066080          AND      r0,r6,#0x400
00000c  b148              CBZ      r0,|L24.34|
;;;875        USBD_Reset();
00000e  f7fffffe          BL       USBD_Reset
;;;876        SignalDeviceEvent(ARM_USBD_EVENT_RESET);
000012  2004              MOVS     r0,#4
000014  496a              LDR      r1,|L24.448|
000016  6809              LDR      r1,[r1,#0]  ; SignalDeviceEvent
000018  4788              BLX      r1
;;;877        ISTR = ~ISTR_RESET;
00001a  f46f6080          MVN      r0,#0x400
00001e  4967              LDR      r1,|L24.444|
000020  6008              STR      r0,[r1,#0]
                  |L24.34|
;;;878      }
;;;879    
;;;880    // Suspend interrupt
;;;881      if (istr & ISTR_SUSP) {
000022  f4066000          AND      r0,r6,#0x800
000026  b1a8              CBZ      r0,|L24.84|
;;;882        CNTR |= CNTR_SUSPM;
000028  4864              LDR      r0,|L24.444|
00002a  1f00              SUBS     r0,r0,#4
00002c  6800              LDR      r0,[r0,#0]
00002e  f4406000          ORR      r0,r0,#0x800
000032  4962              LDR      r1,|L24.444|
000034  1f09              SUBS     r1,r1,#4
000036  6008              STR      r0,[r1,#0]
;;;883        usbd_state.active = 0U;
000038  4862              LDR      r0,|L24.452|
00003a  6800              LDR      r0,[r0,#0]  ; usbd_state
00003c  f0200008          BIC      r0,r0,#8
000040  4960              LDR      r1,|L24.452|
000042  6008              STR      r0,[r1,#0]  ; usbd_state
;;;884        SignalDeviceEvent(ARM_USBD_EVENT_SUSPEND);
000044  2010              MOVS     r0,#0x10
000046  495e              LDR      r1,|L24.448|
000048  6809              LDR      r1,[r1,#0]  ; SignalDeviceEvent
00004a  4788              BLX      r1
;;;885        ISTR = ~ISTR_SUSP;
00004c  f46f6000          MVN      r0,#0x800
000050  495a              LDR      r1,|L24.444|
000052  6008              STR      r0,[r1,#0]
                  |L24.84|
;;;886      }
;;;887    
;;;888    // Resume interrupt
;;;889      if (istr & ISTR_WKUP) {
000054  f4065080          AND      r0,r6,#0x1000
000058  b1b0              CBZ      r0,|L24.136|
;;;890        usbd_state.active = 1U;
00005a  485a              LDR      r0,|L24.452|
00005c  6800              LDR      r0,[r0,#0]  ; usbd_state
00005e  f0200008          BIC      r0,r0,#8
000062  3008              ADDS     r0,r0,#8
000064  4957              LDR      r1,|L24.452|
000066  6008              STR      r0,[r1,#0]  ; usbd_state
;;;891        CNTR &= ~CNTR_SUSPM;
000068  4854              LDR      r0,|L24.444|
00006a  1f00              SUBS     r0,r0,#4
00006c  6800              LDR      r0,[r0,#0]
00006e  f4206000          BIC      r0,r0,#0x800
000072  4952              LDR      r1,|L24.444|
000074  1f09              SUBS     r1,r1,#4
000076  6008              STR      r0,[r1,#0]
;;;892        SignalDeviceEvent(ARM_USBD_EVENT_RESUME);
000078  2020              MOVS     r0,#0x20
00007a  4951              LDR      r1,|L24.448|
00007c  6809              LDR      r1,[r1,#0]  ; SignalDeviceEvent
00007e  4788              BLX      r1
;;;893        ISTR = ~ISTR_WKUP;
000080  f46f5080          MVN      r0,#0x1000
000084  494d              LDR      r1,|L24.444|
000086  6008              STR      r0,[r1,#0]
                  |L24.136|
;;;894      }
;;;895    
;;;896    // PMA Over/underrun
;;;897      if (istr & ISTR_PMAOVR) {
000088  f4064080          AND      r0,r6,#0x4000
00008c  b118              CBZ      r0,|L24.150|
;;;898        ISTR = ~ISTR_PMAOVR;
00008e  f46f4080          MVN      r0,#0x4000
000092  494a              LDR      r1,|L24.444|
000094  6008              STR      r0,[r1,#0]
                  |L24.150|
;;;899      }
;;;900    
;;;901    // Error: No Answer, CRC Error, Bit Stuff Error, Frame Format Error
;;;902      if (istr & ISTR_ERR) {
000096  f4065000          AND      r0,r6,#0x2000
00009a  b118              CBZ      r0,|L24.164|
;;;903        ISTR = ~ISTR_ERR;
00009c  f46f5000          MVN      r0,#0x2000
0000a0  4946              LDR      r1,|L24.444|
0000a2  6008              STR      r0,[r1,#0]
                  |L24.164|
;;;904      }
;;;905    
;;;906    // Endpoint interrupts
;;;907      if ((istr = ISTR) & ISTR_CTR) {
0000a4  4845              LDR      r0,|L24.444|
0000a6  6800              LDR      r0,[r0,#0]
0000a8  4606              MOV      r6,r0
0000aa  f4004000          AND      r0,r0,#0x8000
0000ae  2800              CMP      r0,#0
0000b0  d07c              BEQ      |L24.428|
;;;908    //    ISTR = ~ISTR_CTR;
;;;909    
;;;910        ep_num = istr & ISTR_EP_ID;
0000b2  f006040f          AND      r4,r6,#0xf
;;;911    
;;;912        val = EPxREG(ep_num);
0000b6  4944              LDR      r1,|L24.456|
0000b8  eb010084          ADD      r0,r1,r4,LSL #2
0000bc  f8d07c00          LDR      r7,[r0,#0xc00]
;;;913        if (val & EP_CTR_RX) {
0000c0  f4074000          AND      r0,r7,#0x8000
0000c4  2800              CMP      r0,#0
0000c6  d047              BEQ      |L24.344|
;;;914          ptr_ep = &ep[EP_ID(ep_num)];
0000c8  f004000f          AND      r0,r4,#0xf
0000cc  f3c411c0          UBFX     r1,r4,#7,#1
0000d0  eb010040          ADD      r0,r1,r0,LSL #1
0000d4  eb000080          ADD      r0,r0,r0,LSL #2
0000d8  493c              LDR      r1,|L24.460|
0000da  eb010580          ADD      r5,r1,r0,LSL #2
;;;915          EPxREG(ep_num) = val & ~EP_CTR_RX & EP_MASK;
0000de  f4274000          BIC      r0,r7,#0x8000
0000e2  f648718f          MOV      r1,#0x8f8f
0000e6  4008              ANDS     r0,r0,r1
0000e8  4a37              LDR      r2,|L24.456|
0000ea  eb020184          ADD      r1,r2,r4,LSL #2
0000ee  f8c10c00          STR      r0,[r1,#0xc00]
;;;916    
;;;917    // Setup Packet
;;;918          if (val & EP_SETUP) {
0000f2  f4076000          AND      r0,r7,#0x800
0000f6  b1e8              CBZ      r0,|L24.308|
;;;919            // Read Setup Packet
;;;920            ptr_src  = (uint32_t *)(USB_PMA_ADDR + 2*((pBUF_DSCR)->ADDR_RX));
0000f8  4835              LDR      r0,|L24.464|
0000fa  6800              LDR      r0,[r0,#0]  ; pBUF_DSCR
0000fc  6880              LDR      r0,[r0,#8]
0000fe  4935              LDR      r1,|L24.468|
000100  2202              MOVS     r2,#2
000102  fb021900          MLA      r9,r2,r0,r1
;;;921            ptr_dest = (__packed uint16_t *)(setup_packet);
000106  f8df80d0          LDR      r8,|L24.472|
;;;922            for (i = 0U; i < 4U; i++) {
00010a  f04f0a00          MOV      r10,#0
00010e  e005              B        |L24.284|
                  |L24.272|
;;;923              *ptr_dest++ = *ptr_src++;
000110  f8591b04          LDR      r1,[r9],#4
000114  f8281b02          STRH     r1,[r8],#2
000118  f10a0a01          ADD      r10,r10,#1            ;922
                  |L24.284|
00011c  f1ba0f04          CMP      r10,#4                ;922
000120  d3f6              BCC      |L24.272|
;;;924            }
;;;925            setup_received = 1U;
000122  2001              MOVS     r0,#1
000124  492d              LDR      r1,|L24.476|
000126  7008              STRB     r0,[r1,#0]
;;;926            SignalEndpointEvent(ep_num, ARM_USBD_EVENT_SETUP);
000128  b2e0              UXTB     r0,r4
00012a  2101              MOVS     r1,#1
00012c  4a2c              LDR      r2,|L24.480|
00012e  6812              LDR      r2,[r2,#0]  ; SignalEndpointEvent
000130  4790              BLX      r2
000132  e011              B        |L24.344|
                  |L24.308|
;;;927          } else {
;;;928    // OUT Packet
;;;929            USBD_EP_HW_Read(ep_num);
000134  b2e0              UXTB     r0,r4
000136  f7fffffe          BL       USBD_EP_HW_Read
;;;930            if (ptr_ep->num != 0U) {
00013a  6868              LDR      r0,[r5,#4]
00013c  b128              CBZ      r0,|L24.330|
;;;931              OUT_EP_Status(ep_num, EP_RX_VALID);
00013e  b2e0              UXTB     r0,r4
000140  f44f5140          MOV      r1,#0x3000
000144  f7fffffe          BL       OUT_EP_Status
000148  e006              B        |L24.344|
                  |L24.330|
;;;932            } else {
;;;933              ptr_ep->active = 0U;
00014a  2000              MOVS     r0,#0
00014c  7428              STRB     r0,[r5,#0x10]
;;;934              SignalEndpointEvent(ep_num, ARM_USBD_EVENT_OUT);
00014e  b2e0              UXTB     r0,r4
000150  2102              MOVS     r1,#2
000152  4a23              LDR      r2,|L24.480|
000154  6812              LDR      r2,[r2,#0]  ; SignalEndpointEvent
000156  4790              BLX      r2
                  |L24.344|
;;;935            }
;;;936          }
;;;937        }
;;;938    
;;;939    // IN Packet
;;;940        if (val & EP_CTR_TX) {
000158  f0070080          AND      r0,r7,#0x80
00015c  b330              CBZ      r0,|L24.428|
;;;941          ptr_ep = &ep[EP_ID(ep_num | ARM_USB_ENDPOINT_DIRECTION_MASK)];
00015e  f0440080          ORR      r0,r4,#0x80
000162  f3c011c0          UBFX     r1,r0,#7,#1
000166  f004000f          AND      r0,r4,#0xf
00016a  eb010040          ADD      r0,r1,r0,LSL #1
00016e  eb000080          ADD      r0,r0,r0,LSL #2
000172  4916              LDR      r1,|L24.460|
000174  eb010580          ADD      r5,r1,r0,LSL #2
;;;942          EPxREG(ep_num) = val & ~EP_CTR_TX & EP_MASK;
000178  f0270080          BIC      r0,r7,#0x80
00017c  f648718f          MOV      r1,#0x8f8f
000180  4008              ANDS     r0,r0,r1
000182  4a11              LDR      r2,|L24.456|
000184  eb020184          ADD      r1,r2,r4,LSL #2
000188  f8c10c00          STR      r0,[r1,#0xc00]
;;;943          ptr_ep->num_transferred_total += ptr_ep->num_transferring;
00018c  68a8              LDR      r0,[r5,#8]
00018e  89a9              LDRH     r1,[r5,#0xc]
000190  4408              ADD      r0,r0,r1
000192  60a8              STR      r0,[r5,#8]
;;;944          if (ptr_ep->num == 0U) {
000194  6868              LDR      r0,[r5,#4]
000196  b950              CBNZ     r0,|L24.430|
;;;945            ptr_ep->data   = NULL;
000198  2000              MOVS     r0,#0
00019a  6028              STR      r0,[r5,#0]
;;;946            ptr_ep->active = 0U;
00019c  7428              STRB     r0,[r5,#0x10]
;;;947            SignalEndpointEvent(ep_num | ARM_USB_ENDPOINT_DIRECTION_MASK, ARM_USBD_EVENT_IN);
00019e  b2e1              UXTB     r1,r4
0001a0  f0410080          ORR      r0,r1,#0x80
0001a4  2104              MOVS     r1,#4
0001a6  4a0e              LDR      r2,|L24.480|
0001a8  6812              LDR      r2,[r2,#0]  ; SignalEndpointEvent
0001aa  4790              BLX      r2
                  |L24.428|
0001ac  e004              B        |L24.440|
                  |L24.430|
;;;948          } else {
;;;949            USBD_EP_HW_Write(ep_num | ARM_USB_ENDPOINT_DIRECTION_MASK);
0001ae  b2e1              UXTB     r1,r4
0001b0  f0410080          ORR      r0,r1,#0x80
0001b4  f7fffffe          BL       USBD_EP_HW_Write
                  |L24.440|
;;;950          }
;;;951        }
;;;952      }
;;;953    }
0001b8  e8bd87f0          POP      {r4-r10,pc}
;;;954    
                          ENDP

                  |L24.444|
                          DCD      0x40005c44
                  |L24.448|
                          DCD      SignalDeviceEvent
                  |L24.452|
                          DCD      usbd_state
                  |L24.456|
                          DCD      0x40005000
                  |L24.460|
                          DCD      ||ep||
                  |L24.464|
                          DCD      pBUF_DSCR
                  |L24.468|
                          DCD      0x40006000
                  |L24.472|
                          DCD      setup_packet
                  |L24.476|
                          DCD      setup_received
                  |L24.480|
                          DCD      SignalEndpointEvent

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||ep||
                          %        360

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  usbd_driver_version
000000  02020201          DCW      0x0202,0x0201
                  usbd_driver_capabilities
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  EP_buff_offset
000008  00800088          DCW      0x0080,0x0088
00000c  009000d0          DCW      0x0090,0x00d0
000010  01100150          DCW      0x0110,0x0150
000014  01900198          DCW      0x0190,0x0198
000018  01a001a8          DCW      0x01a0,0x01a8
00001c  01b001b8          DCW      0x01b0,0x01b8
000020  01c001c8          DCW      0x01c0,0x01c8
000024  01d001d8          DCW      0x01d0,0x01d8
                  Driver_USBD0
                          DCD      USBD_GetVersion
                          DCD      USBD_GetCapabilities
                          DCD      USBD_Initialize
                          DCD      USBD_Uninitialize
                          DCD      USBD_PowerControl
                          DCD      USBD_DeviceConnect
                          DCD      USBD_DeviceDisconnect
                          DCD      USBD_DeviceGetState
                          DCD      USBD_DeviceRemoteWakeup
                          DCD      USBD_DeviceSetAddress
                          DCD      USBD_ReadSetupPacket
                          DCD      USBD_EndpointConfigure
                          DCD      USBD_EndpointUnconfigure
                          DCD      USBD_EndpointStall
                          DCD      USBD_EndpointTransfer
                          DCD      USBD_EndpointTransferGetResult
                          DCD      USBD_EndpointTransferAbort
                          DCD      USBD_GetFrameNumber

                          AREA ||.data||, DATA, ALIGN=2

                  SignalDeviceEvent
                          DCD      0x00000000
                  SignalEndpointEvent
                          DCD      0x00000000
                  hw_powered
000008  00                DCB      0x00
                  hw_initialized
000009  000000            DCB      0x00,0x00,0x00
                  usbd_state
                          DCD      0x00000000
                  setup_packet
                          %        8
                  setup_received
000018  00000000          DCB      0x00,0x00,0x00,0x00
                  pBUF_DSCR
                          DCD      0x40006000

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\STM32F1xx_DFP\\2.3.0\\RTE_Driver\\USBD_STM32F10x.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_USBD_STM32F10x_c_c3ee497b____REV16|
#line 492 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___16_USBD_STM32F10x_c_c3ee497b____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_USBD_STM32F10x_c_c3ee497b____REVSH|
#line 507
|__asm___16_USBD_STM32F10x_c_c3ee497b____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_USBD_STM32F10x_c_c3ee497b____RRX|
#line 694
|__asm___16_USBD_STM32F10x_c_c3ee497b____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
