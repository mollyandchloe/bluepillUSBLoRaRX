; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\rtx_conf_cm.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_conf_cm.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTE\Device\STM32F103C8 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Driver\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\RTOS\RTX\INC -IC:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\StdPeriph_Driver\inc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\RTE_Driver -D__RTX -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\objects\rtx_conf_cm.crf RTE\CMSIS\RTX_Conf_CM.c]
                          THUMB

                          AREA ||i.__user_perthread_libspace||, CODE, READONLY, ALIGN=2

                  __user_perthread_libspace PROC
;;;281    void *__user_perthread_libspace (void);
;;;282    void *__user_perthread_libspace (void) {
000000  4807              LDR      r0,|L1.32|
000002  b510              PUSH     {r4,lr}
;;;283      /* Provide a separate libspace for each task. */
;;;284      uint32_t idx;
;;;285    
;;;286      idx = (os_running != 0U) ? runtask_id () : 0U;
000004  7800              LDRB     r0,[r0,#0]  ; os_running
000006  b148              CBZ      r0,|L1.28|
000008  f7fffffe          BL       rt_tsk_self
00000c  b130              CBZ      r0,|L1.28|
;;;287      if (idx == 0U) {
;;;288        /* RTX not running yet. */
;;;289        return (&__libspace_start);
;;;290      }
;;;291      return ((void *)&std_libspace[idx-1]);
00000e  4905              LDR      r1,|L1.36|
000010  eb000040          ADD      r0,r0,r0,LSL #1
000014  eb011040          ADD      r0,r1,r0,LSL #5
000018  3860              SUBS     r0,r0,#0x60
;;;292    }
00001a  bd10              POP      {r4,pc}
                  |L1.28|
00001c  4802              LDR      r0,|L1.40|
00001e  bd10              POP      {r4,pc}
;;;293    
                          ENDP

                  |L1.32|
                          DCD      os_running
                  |L1.36|
                          DCD      ||.bss||+0x2328
                  |L1.40|
                          DCD      __libspace_start

                          AREA ||i._mutex_acquire||, CODE, READONLY, ALIGN=2

                  _mutex_acquire PROC
                  ||__tagsym$$used||
;;;313    void _mutex_acquire (OS_ID *mutex);
;;;314    void _mutex_acquire (OS_ID *mutex) {
000000  4905              LDR      r1,|L2.24|
;;;315      /* Acquire a system mutex, lock stdlib resources. */
;;;316      if (os_running) {
000002  7809              LDRB     r1,[r1,#0]  ; os_running
000004  2900              CMP      r1,#0                 ;314
000006  d005              BEQ      |L2.20|
;;;317        /* RTX running, acquire a mutex. */
;;;318        mutex_wait (*mutex);
000008  6800              LDR      r0,[r0,#0]
00000a  f64f71ff          MOV      r1,#0xffff
00000e  f8dfc00c          LDR      r12,|L2.28|
000012  df00              SVC      #0x0
                  |L2.20|
;;;319      }
;;;320    }
000014  4770              BX       lr
;;;321    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      os_running
                  |L2.28|
                          DCD      rt_mut_wait

                          AREA ||i._mutex_initialize||, CODE, READONLY, ALIGN=2

                  _mutex_initialize PROC
;;;296    int _mutex_initialize (OS_ID *mutex);
;;;297    int _mutex_initialize (OS_ID *mutex) {
000000  4a08              LDR      r2,|L3.36|
000002  b510              PUSH     {r4,lr}
;;;298      /* Allocate and initialize a system mutex. */
;;;299    
;;;300      if (nr_mutex >= OS_MUTEXCNT) {
000004  6911              LDR      r1,[r2,#0x10]  ; nr_mutex
000006  4603              MOV      r3,r0                 ;297
000008  2908              CMP      r1,#8
00000a  d300              BCC      |L3.14|
                  |L3.12|
;;;301        /* If you are here, you need to increase the number OS_MUTEXCNT. */
;;;302        for (;;);
00000c  e7fe              B        |L3.12|
                  |L3.14|
;;;303      }
;;;304      *mutex = &std_libmutex[nr_mutex++];
00000e  4806              LDR      r0,|L3.40|
000010  eb001001          ADD      r0,r0,r1,LSL #4
000014  1c49              ADDS     r1,r1,#1
000016  6018              STR      r0,[r3,#0]
;;;305      mutex_init (*mutex);
000018  6111              STR      r1,[r2,#0x10]  ; nr_mutex
00001a  f7fffffe          BL       rt_mut_init
;;;306      return (1);
00001e  2001              MOVS     r0,#1
;;;307    }
000020  bd10              POP      {r4,pc}
;;;308    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      ||.data||
                  |L3.40|
                          DCD      ||.bss||+0x2688

                          AREA ||i._mutex_release||, CODE, READONLY, ALIGN=2

                  _mutex_release PROC
                  |symbol_number.65|
;;;326    void _mutex_release (OS_ID *mutex);
;;;327    void _mutex_release (OS_ID *mutex) {
000000  4904              LDR      r1,|L4.20|
;;;328      /* Release a system mutex, unlock stdlib resources. */
;;;329      if (os_running) {
000002  7809              LDRB     r1,[r1,#0]  ; os_running
000004  2900              CMP      r1,#0                 ;327
000006  d003              BEQ      |L4.16|
;;;330        /* RTX running, release a mutex. */
;;;331        mutex_rel (*mutex);
000008  6800              LDR      r0,[r0,#0]
00000a  f8dfc00c          LDR      r12,|L4.24|
00000e  df00              SVC      #0x0
                  |L4.16|
;;;332      }
;;;333    }
000010  4770              BX       lr
;;;334    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      os_running
                  |L4.24|
                          DCD      rt_mut_release

                          AREA ||i.os_error||, CODE, READONLY, ALIGN=1

                  os_error PROC
;;;271    /// \param[in]   error_code   actual error code that has been detected
;;;272    void os_error (uint32_t error_code) {
000000  2801              CMP      r0,#1
;;;273     
;;;274      /* HERE: include optional code to be executed on runtime error. */
;;;275      switch (error_code) {
000002  d006              BEQ      |L5.18|
000004  2802              CMP      r0,#2
000006  d005              BEQ      |L5.20|
000008  2803              CMP      r0,#3
00000a  d004              BEQ      |L5.22|
00000c  2804              CMP      r0,#4
00000e  d104              BNE      |L5.26|
000010  e002              B        |L5.24|
                  |L5.18|
;;;276        case OS_ERROR_STACK_OVF:
;;;277          /* Stack overflow detected for the currently running task. */
;;;278          /* Thread can be identified by calling svcThreadGetId().   */
;;;279          break;
000012  e003              B        |L5.28|
                  |L5.20|
;;;280        case OS_ERROR_FIFO_OVF:
;;;281          /* ISR FIFO Queue buffer overflow detected. */
;;;282          break;
000014  e002              B        |L5.28|
                  |L5.22|
;;;283        case OS_ERROR_MBX_OVF:
;;;284          /* Mailbox overflow detected. */
;;;285          break;
000016  e001              B        |L5.28|
                  |L5.24|
;;;286        case OS_ERROR_TIMER_OVF:
;;;287          /* User Timer Callback Queue overflow detected. */
;;;288          break;
000018  e000              B        |L5.28|
                  |L5.26|
;;;289        default:
;;;290          break;
00001a  bf00              NOP      
                  |L5.28|
00001c  bf00              NOP                            ;279
;;;291      }
;;;292      for (;;);
00001e  bf00              NOP      
                  |L5.32|
000020  e7fe              B        |L5.32|
;;;293    }
;;;294     
                          ENDP


                          AREA ||i.os_idle_demon||, CODE, READONLY, ALIGN=1

                  os_idle_demon PROC
;;;215    /// \brief The idle demon is running when no other thread is ready to run
;;;216    void os_idle_demon (void) {
000000  bf00              NOP      
                  |L6.2|
;;;217     
;;;218      for (;;) {
000002  e7fe              B        |L6.2|
;;;219        /* HERE: include optional user code to be executed when no thread runs.*/
;;;220      }
;;;221    }
;;;222     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  mp_tcb
                          %        480
                  mp_stk
                          %        5016
                  os_stack_mem
                          %        3304
                  os_fifo
                          %        132
                  os_active_TCB
                          %        36
                  os_messageQ_q_osTimerMessageQ
                          %        32
                  std_libspace
                          %        864
                  std_libmutex
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  os_maxtaskrun
000000  0009              DCW      0x0009
000002  0000              DCB      0x00,0x00
                  os_stackinfo
                          DCD      0x010503e8
                  os_rrobin
                          DCD      0x00010014
                  os_tickfreq
                          DCD      0x044aa200
                  os_tickus_i
000010  0048              DCW      0x0048
                  os_tickus_f
000012  0000              DCW      0x0000
                  os_trv
                          DCD      0x0001193f
                  os_flags
000018  01000000          DCB      0x01,0x00,0x00,0x00
                  CMSIS_RTOS_API_Version
                  |symbol_number.24|
                          DCD      0x00010002
                  CMSIS_RTOS_RTX_Version
                  |symbol_number.25|
                          DCD      0x00040052
                  os_clockrate
                  |symbol_number.26|
                          DCD      0x000003e8
                  os_timernum
                  |symbol_number.27|
                          DCD      0x00000000
                  mp_tcb_size
00002c  01e0              DCW      0x01e0
00002e  0000              DCB      0x00,0x00
                  mp_stk_size
                          DCD      0x00001398
                  os_stack_sz
                          DCD      0x00000ce8
                  os_fifo_size
000038  10000000          DCB      0x10,0x00,0x00,0x00
                  os_thread_def_osTimerThread
                          DCD      osTimerThread
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x000000c8
                  os_messageQ_def_osTimerMessageQ
                          DCD      0x00000004
                          DCD      os_messageQ_q_osTimerMessageQ
                  mp_tmr_size
000054  0000              DCW      0x0000
000056  0000              DCB      0x00,0x00
                  os_thread_def_main
                          DCD      main
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x000003e8

                          AREA ||.data||, DATA, ALIGN=2

                  osThreadId_osTimerThread
                          DCD      0x00000000
                  osMessageQId_osTimerMessageQ
                          DCD      0x00000000
                  os_tmr
                          DCD      0x00000000
                  m_tmr
                          DCD      0x00000000
                  nr_mutex
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "RTE\\CMSIS\\RTX_Conf_CM.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |_platform_post_lib_init|
#line 419 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.6.0\\CMSIS\\RTOS\\RTX\\INC\\RTX_CM_lib.h"
|_platform_post_lib_init| PROC
#line 419


 IMPORT os_thread_def_main
 IMPORT osKernelInitialize
 IMPORT osKernelStart
 IMPORT osThreadCreate
 IMPORT exit

 ADD SP,#0x10
 BL osKernelInitialize
 LDR R0,=os_thread_def_main
 MOVS R1,#0
 BL osThreadCreate
 BL osKernelStart
 BL exit

 ALIGN
	ENDP

;*** End   embedded assembler ***
