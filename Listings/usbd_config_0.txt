; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\usbd_config_0.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usbd_config_0.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTE\Device\STM32F103C8 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\Driver\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.6.0\CMSIS\RTOS\RTX\INC -IC:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\7.9.0\USB\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\StdPeriph_Driver\inc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\RTE_Driver -D__RTX -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_MD --omf_browse=.\objects\usbd_config_0.crf RTE\USB\USBD_Config_0.c]
                          THUMB

                          AREA ||i.USBD0_SignalDeviceEvent||, CODE, READONLY, ALIGN=1

                  USBD0_SignalDeviceEvent PROC
;;;3139           void    USBD0_SignalDeviceEvent  (uint32_t event);
;;;3140           void    USBD0_SignalDeviceEvent  (uint32_t event)                    { USBD_SignalDeviceEvent  (0, event);            }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       USBD_SignalDeviceEvent
00000c  bd10              POP      {r4,pc}
;;;3141           void    USBD0_SignalEndpointEvent(uint8_t  ep_addr, uint32_t event);
                          ENDP


                          AREA ||i.USBD0_SignalEndpointEvent||, CODE, READONLY, ALIGN=1

                  USBD0_SignalEndpointEvent PROC
;;;3141           void    USBD0_SignalEndpointEvent(uint8_t  ep_addr, uint32_t event);
;;;3142           void    USBD0_SignalEndpointEvent(uint8_t  ep_addr, uint32_t event)  { USBD_SignalEndpointEvent(0, ep_addr, event);   }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       USBD_SignalEndpointEvent
000010  bd70              POP      {r4-r6,pc}
;;;3143   #endif
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_DataReceived||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_DataReceived PROC
;;;3830   __WEAK  bool      USBD_CDC0_ACM_SetControlLineState(uint16_t state)               { (void)state; return false; }
;;;3831   __WEAK  void      USBD_CDC0_ACM_DataReceived       (uint32_t len)                 { (void)len; }
000000  4770              BX       lr
;;;3832   __WEAK  void      USBD_CDC0_ACM_DataSent           (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_DataSent||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_DataSent PROC
;;;3831   __WEAK  void      USBD_CDC0_ACM_DataReceived       (uint32_t len)                 { (void)len; }
;;;3832   __WEAK  void      USBD_CDC0_ACM_DataSent           (void)                         { }
000000  4770              BX       lr
;;;3833   __WEAK  void      USBD_CDC0_NCM_Initialize         (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_GetEncapsulatedResponse||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_GetEncapsulatedResponse PROC
;;;3826   __WEAK  bool      USBD_CDC0_ACM_SendEncapsulatedCommand (            const uint8_t  *buf, uint16_t  len)  {                (void)buf; (void)len; return false; }
;;;3827   __WEAK  bool      USBD_CDC0_ACM_GetEncapsulatedResponse (uint16_t max_len, uint8_t **buf, uint16_t *len)  { (void)max_len; (void)buf; (void)len; return false; }
000000  4603              MOV      r3,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3828   __WEAK  bool      USBD_CDC0_ACM_SetLineCoding      (const CDC_LINE_CODING *line_coding) { (void)line_coding; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_GetLineCoding||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_GetLineCoding PROC
;;;3828   __WEAK  bool      USBD_CDC0_ACM_SetLineCoding      (const CDC_LINE_CODING *line_coding) { (void)line_coding; return false; }
;;;3829   __WEAK  bool      USBD_CDC0_ACM_GetLineCoding      (      CDC_LINE_CODING *line_coding) { (void)line_coding; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3830   __WEAK  bool      USBD_CDC0_ACM_SetControlLineState(uint16_t state)               { (void)state; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_Initialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_Initialize PROC
;;;3822   #else
;;;3823   __WEAK  void      USBD_CDC0_ACM_Initialize         (void)                         { }
000000  4770              BX       lr
;;;3824   __WEAK  void      USBD_CDC0_ACM_Uninitialize       (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_Reset||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_Reset PROC
;;;3824   __WEAK  void      USBD_CDC0_ACM_Uninitialize       (void)                         { }
;;;3825   __WEAK  void      USBD_CDC0_ACM_Reset              (void)                         { }
000000  4770              BX       lr
;;;3826   __WEAK  bool      USBD_CDC0_ACM_SendEncapsulatedCommand (            const uint8_t  *buf, uint16_t  len)  {                (void)buf; (void)len; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_SendEncapsulatedCommand||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_SendEncapsulatedCommand PROC
;;;3825   __WEAK  void      USBD_CDC0_ACM_Reset              (void)                         { }
;;;3826   __WEAK  bool      USBD_CDC0_ACM_SendEncapsulatedCommand (            const uint8_t  *buf, uint16_t  len)  {                (void)buf; (void)len; return false; }
000000  4602              MOV      r2,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3827   __WEAK  bool      USBD_CDC0_ACM_GetEncapsulatedResponse (uint16_t max_len, uint8_t **buf, uint16_t *len)  { (void)max_len; (void)buf; (void)len; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_SetControlLineState||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_SetControlLineState PROC
;;;3829   __WEAK  bool      USBD_CDC0_ACM_GetLineCoding      (      CDC_LINE_CODING *line_coding) { (void)line_coding; return false; }
;;;3830   __WEAK  bool      USBD_CDC0_ACM_SetControlLineState(uint16_t state)               { (void)state; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3831   __WEAK  void      USBD_CDC0_ACM_DataReceived       (uint32_t len)                 { (void)len; }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_SetLineCoding||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_SetLineCoding PROC
;;;3827   __WEAK  bool      USBD_CDC0_ACM_GetEncapsulatedResponse (uint16_t max_len, uint8_t **buf, uint16_t *len)  { (void)max_len; (void)buf; (void)len; return false; }
;;;3828   __WEAK  bool      USBD_CDC0_ACM_SetLineCoding      (const CDC_LINE_CODING *line_coding) { (void)line_coding; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3829   __WEAK  bool      USBD_CDC0_ACM_GetLineCoding      (      CDC_LINE_CODING *line_coding) { (void)line_coding; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_ACM_Uninitialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_ACM_Uninitialize PROC
;;;3823   __WEAK  void      USBD_CDC0_ACM_Initialize         (void)                         { }
;;;3824   __WEAK  void      USBD_CDC0_ACM_Uninitialize       (void)                         { }
000000  4770              BX       lr
;;;3825   __WEAK  void      USBD_CDC0_ACM_Reset              (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_GetCrcMode||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_GetCrcMode PROC
;;;3851   __WEAK  bool      USBD_CDC0_NCM_SetMaxDatagramSize (uint16_t  max_datagram_size)  { (void)max_datagram_size; return false; }
;;;3852   __WEAK  bool      USBD_CDC0_NCM_GetCrcMode         (uint16_t *mode)               { (void)mode; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3853   __WEAK  bool      USBD_CDC0_NCM_SetCrcMode         (uint16_t  mode)               { (void)mode; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_GetEthernetPowerManagementPatternFilter||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_GetEthernetPowerManagementPatternFilter PROC
;;;3839   __WEAK  bool      USBD_CDC0_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size) { (void)filter_number; (void)pattern_filter; (void)pattern_filter_size; return false; }
;;;3840   __WEAK  bool      USBD_CDC0_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active)                                    { (void)filter_number; (void)pattern_active; return false; }
000000  4602              MOV      r2,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3841   __WEAK  bool      USBD_CDC0_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap)                                                       { (void)packet_filter_bitmap; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_GetEthernetStatistic||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_GetEthernetStatistic PROC
;;;3841   __WEAK  bool      USBD_CDC0_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap)                                                       { (void)packet_filter_bitmap; return false; }
;;;3842   __WEAK  bool      USBD_CDC0_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data)                                           { (void)feature_selector, (void)data; return false; }
000000  4602              MOV      r2,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3843   __WEAK  bool      USBD_CDC0_NCM_GetNtbParameters   (CDC_NCM_NTB_PARAM *ntb_params){ (void)ntb_params; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_GetMaxDatagramSize||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_GetMaxDatagramSize PROC
;;;3849   __WEAK  bool      USBD_CDC0_NCM_SetNtbInputSize    (uint32_t  ntb_input_size)     { (void)ntb_input_size; return false; }
;;;3850   __WEAK  bool      USBD_CDC0_NCM_GetMaxDatagramSize (uint16_t *max_datagram_size)  { (void)max_datagram_size; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3851   __WEAK  bool      USBD_CDC0_NCM_SetMaxDatagramSize (uint16_t  max_datagram_size)  { (void)max_datagram_size; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_GetNetAddress||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_GetNetAddress PROC
;;;3843   __WEAK  bool      USBD_CDC0_NCM_GetNtbParameters   (CDC_NCM_NTB_PARAM *ntb_params){ (void)ntb_params; return false; }
;;;3844   __WEAK  bool      USBD_CDC0_NCM_GetNetAddress      (uint8_t *addr)                { (void)addr; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3845   __WEAK  bool      USBD_CDC0_NCM_SetNetAddress      (const uint8_t *addr)          { (void)addr; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_GetNtbFormat||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_GetNtbFormat PROC
;;;3845   __WEAK  bool      USBD_CDC0_NCM_SetNetAddress      (const uint8_t *addr)          { (void)addr; return false; }
;;;3846   __WEAK  bool      USBD_CDC0_NCM_GetNtbFormat       (uint16_t *ntb_format)         { (void)ntb_format; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3847   __WEAK  bool      USBD_CDC0_NCM_SetNtbFormat       (uint16_t  ntb_format)         { (void)ntb_format; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_GetNtbInputSize||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_GetNtbInputSize PROC
;;;3847   __WEAK  bool      USBD_CDC0_NCM_SetNtbFormat       (uint16_t  ntb_format)         { (void)ntb_format; return false; }
;;;3848   __WEAK  bool      USBD_CDC0_NCM_GetNtbInputSize    (uint32_t *ntb_input_size)     { (void)ntb_input_size; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3849   __WEAK  bool      USBD_CDC0_NCM_SetNtbInputSize    (uint32_t  ntb_input_size)     { (void)ntb_input_size; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_GetNtbParameters||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_GetNtbParameters PROC
;;;3842   __WEAK  bool      USBD_CDC0_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data)                                           { (void)feature_selector, (void)data; return false; }
;;;3843   __WEAK  bool      USBD_CDC0_NCM_GetNtbParameters   (CDC_NCM_NTB_PARAM *ntb_params){ (void)ntb_params; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3844   __WEAK  bool      USBD_CDC0_NCM_GetNetAddress      (uint8_t *addr)                { (void)addr; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_Initialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_Initialize PROC
;;;3832   __WEAK  void      USBD_CDC0_ACM_DataSent           (void)                         { }
;;;3833   __WEAK  void      USBD_CDC0_NCM_Initialize         (void)                         { }
000000  4770              BX       lr
;;;3834   __WEAK  void      USBD_CDC0_NCM_Uninitialize       (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_NTB_IN_Sent||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_NTB_IN_Sent PROC
;;;3853   __WEAK  bool      USBD_CDC0_NCM_SetCrcMode         (uint16_t  mode)               { (void)mode; return false; }
;;;3854   __WEAK  void      USBD_CDC0_NCM_NTB_IN_Sent        (void)                         { }
000000  4770              BX       lr
;;;3855   __WEAK  void      USBD_CDC0_NCM_NTB_OUT_Received   (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_NTB_OUT_Received||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_NTB_OUT_Received PROC
;;;3854   __WEAK  void      USBD_CDC0_NCM_NTB_IN_Sent        (void)                         { }
;;;3855   __WEAK  void      USBD_CDC0_NCM_NTB_OUT_Received   (void)                         { }
000000  4770              BX       lr
;;;3856   #ifdef  RTE_USB_Device_CDC_1
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_Reset||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_Reset PROC
;;;3834   __WEAK  void      USBD_CDC0_NCM_Uninitialize       (void)                         { }
;;;3835   __WEAK  void      USBD_CDC0_NCM_Reset              (void)                         { }
000000  4770              BX       lr
;;;3836   __WEAK  void      USBD_CDC0_NCM_Start              (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_SetCrcMode||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_SetCrcMode PROC
;;;3852   __WEAK  bool      USBD_CDC0_NCM_GetCrcMode         (uint16_t *mode)               { (void)mode; return false; }
;;;3853   __WEAK  bool      USBD_CDC0_NCM_SetCrcMode         (uint16_t  mode)               { (void)mode; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3854   __WEAK  void      USBD_CDC0_NCM_NTB_IN_Sent        (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_SetEthernetMulticastFilters||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_SetEthernetMulticastFilters PROC
;;;3837   __WEAK  void      USBD_CDC0_NCM_Stop               (void)                         { }
;;;3838   __WEAK  bool      USBD_CDC0_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters)                                   { (void)addr_list; (void)num_of_filters; return false; }
000000  4602              MOV      r2,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3839   __WEAK  bool      USBD_CDC0_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size) { (void)filter_number; (void)pattern_filter; (void)pattern_filter_size; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_SetEthernetPacketFilter||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_SetEthernetPacketFilter PROC
;;;3840   __WEAK  bool      USBD_CDC0_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active)                                    { (void)filter_number; (void)pattern_active; return false; }
;;;3841   __WEAK  bool      USBD_CDC0_NCM_SetEthernetPacketFilter                 (uint16_t packet_filter_bitmap)                                                       { (void)packet_filter_bitmap; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3842   __WEAK  bool      USBD_CDC0_NCM_GetEthernetStatistic                    (uint16_t feature_selector, uint32_t *data)                                           { (void)feature_selector, (void)data; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_SetEthernetPowerManagementPatternFilter||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_SetEthernetPowerManagementPatternFilter PROC
;;;3838   __WEAK  bool      USBD_CDC0_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters)                                   { (void)addr_list; (void)num_of_filters; return false; }
;;;3839   __WEAK  bool      USBD_CDC0_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size) { (void)filter_number; (void)pattern_filter; (void)pattern_filter_size; return false; }
000000  4603              MOV      r3,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3840   __WEAK  bool      USBD_CDC0_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active)                                    { (void)filter_number; (void)pattern_active; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_SetMaxDatagramSize||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_SetMaxDatagramSize PROC
;;;3850   __WEAK  bool      USBD_CDC0_NCM_GetMaxDatagramSize (uint16_t *max_datagram_size)  { (void)max_datagram_size; return false; }
;;;3851   __WEAK  bool      USBD_CDC0_NCM_SetMaxDatagramSize (uint16_t  max_datagram_size)  { (void)max_datagram_size; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3852   __WEAK  bool      USBD_CDC0_NCM_GetCrcMode         (uint16_t *mode)               { (void)mode; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_SetNetAddress||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_SetNetAddress PROC
;;;3844   __WEAK  bool      USBD_CDC0_NCM_GetNetAddress      (uint8_t *addr)                { (void)addr; return false; }
;;;3845   __WEAK  bool      USBD_CDC0_NCM_SetNetAddress      (const uint8_t *addr)          { (void)addr; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3846   __WEAK  bool      USBD_CDC0_NCM_GetNtbFormat       (uint16_t *ntb_format)         { (void)ntb_format; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_SetNtbFormat||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_SetNtbFormat PROC
;;;3846   __WEAK  bool      USBD_CDC0_NCM_GetNtbFormat       (uint16_t *ntb_format)         { (void)ntb_format; return false; }
;;;3847   __WEAK  bool      USBD_CDC0_NCM_SetNtbFormat       (uint16_t  ntb_format)         { (void)ntb_format; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3848   __WEAK  bool      USBD_CDC0_NCM_GetNtbInputSize    (uint32_t *ntb_input_size)     { (void)ntb_input_size; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_SetNtbInputSize||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_SetNtbInputSize PROC
;;;3848   __WEAK  bool      USBD_CDC0_NCM_GetNtbInputSize    (uint32_t *ntb_input_size)     { (void)ntb_input_size; return false; }
;;;3849   __WEAK  bool      USBD_CDC0_NCM_SetNtbInputSize    (uint32_t  ntb_input_size)     { (void)ntb_input_size; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3850   __WEAK  bool      USBD_CDC0_NCM_GetMaxDatagramSize (uint16_t *max_datagram_size)  { (void)max_datagram_size; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_Start||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_Start PROC
;;;3835   __WEAK  void      USBD_CDC0_NCM_Reset              (void)                         { }
;;;3836   __WEAK  void      USBD_CDC0_NCM_Start              (void)                         { }
000000  4770              BX       lr
;;;3837   __WEAK  void      USBD_CDC0_NCM_Stop               (void)                         { }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_Stop||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_Stop PROC
;;;3836   __WEAK  void      USBD_CDC0_NCM_Start              (void)                         { }
;;;3837   __WEAK  void      USBD_CDC0_NCM_Stop               (void)                         { }
000000  4770              BX       lr
;;;3838   __WEAK  bool      USBD_CDC0_NCM_SetEthernetMulticastFilters             (const uint8_t *addr_list, uint16_t num_of_filters)                                   { (void)addr_list; (void)num_of_filters; return false; }
                          ENDP


                          AREA ||i.USBD_CDC0_NCM_Uninitialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC0_NCM_Uninitialize PROC
;;;3833   __WEAK  void      USBD_CDC0_NCM_Initialize         (void)                         { }
;;;3834   __WEAK  void      USBD_CDC0_NCM_Uninitialize       (void)                         { }
000000  4770              BX       lr
;;;3835   __WEAK  void      USBD_CDC0_NCM_Reset              (void)                         { }
                          ENDP


                          AREA ||i.USBD_ClassInitialize||, CODE, READONLY, ALIGN=2

                  USBD_ClassInitialize PROC
;;;5565   
;;;5566   usbStatus USBD_ClassInitialize (uint8_t device) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;5567     uint8_t   instance;
;;;5568     usbStatus status_ret, status;
;;;5569   
;;;5570     status_ret = usbOK;
000006  2700              MOVS     r7,#0
;;;5571   #if (USBD_CUSTOM_CLASS_NUM > 0)
;;;5572     for (instance = 0; instance < usbd_custom_class_num; instance++) {
;;;5573       if (usbd_custom_class_ptr[instance] != NULL) {
;;;5574         if (usbd_custom_class_ptr[instance]->dev_num == device) {
;;;5575           status = USBD_CustomClass_Initialize (instance);
;;;5576           if (status) status_ret = status;
;;;5577         }
;;;5578       }
;;;5579     }
;;;5580   #endif
;;;5581   
;;;5582   #if (USBD_ADC_NUM > 0)
;;;5583     for (instance = 0; instance < usbd_adc_num; instance++) {
;;;5584       if ((usbd_adc_ptr[instance]->spkr_data_ptr != NULL) || (usbd_adc_ptr[instance]->mic_data_ptr != NULL)) {
;;;5585         if (usbd_adc_ptr[instance]->dev_num == device) {
;;;5586           status = USBD_ADC_Initialize (instance);
;;;5587           if (status) status_ret = status;
;;;5588         }
;;;5589       }
;;;5590     }
;;;5591   #endif
;;;5592   
;;;5593   #if (USBD_CDC_NUM > 0)
;;;5594     for (instance = 0; instance < usbd_cdc_num; instance++) {
000008  2400              MOVS     r4,#0
00000a  e012              B        |L36.50|
                  |L36.12|
;;;5595       if (usbd_cdc_ptr[instance]->data_ptr != NULL) {
00000c  480b              LDR      r0,|L36.60|
00000e  f8500024          LDR      r0,[r0,r4,LSL #2]
000012  6940              LDR      r0,[r0,#0x14]
000014  b158              CBZ      r0,|L36.46|
;;;5596         if (usbd_cdc_ptr[instance]->dev_num == device) {
000016  4809              LDR      r0,|L36.60|
000018  f8500024          LDR      r0,[r0,r4,LSL #2]
00001c  7e00              LDRB     r0,[r0,#0x18]
00001e  42b0              CMP      r0,r6
000020  d105              BNE      |L36.46|
;;;5597           status = USBD_CDC_Initialize (instance);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       USBD_CDC_Initialize
000028  4605              MOV      r5,r0
;;;5598           if (status) status_ret = status;
00002a  b105              CBZ      r5,|L36.46|
00002c  462f              MOV      r7,r5
                  |L36.46|
00002e  1c60              ADDS     r0,r4,#1              ;5594
000030  b2c4              UXTB     r4,r0                 ;5594
                  |L36.50|
000032  2c01              CMP      r4,#1                 ;5594
000034  dbea              BLT      |L36.12|
;;;5599         }
;;;5600       }
;;;5601     }
;;;5602   #endif
;;;5603   
;;;5604   #if (USBD_HID_NUM > 0)
;;;5605     for (instance = 0; instance < usbd_hid_num; instance++) {
;;;5606       if (usbd_hid_ptr[instance]->data_ptr != NULL) {
;;;5607         if (usbd_hid_ptr[instance]->dev_num == device) {
;;;5608           status = USBD_HID_Initialize (instance);
;;;5609           if (status) status_ret = status;
;;;5610         }
;;;5611       }
;;;5612     }
;;;5613   #endif
;;;5614   
;;;5615   #if (USBD_MSC_NUM > 0)
;;;5616     for (instance = 0; instance < usbd_msc_num; instance++) {
;;;5617       if (usbd_msc_ptr[instance]->data_ptr != NULL) {
;;;5618         if (usbd_msc_ptr[instance]->dev_num == device) {
;;;5619           status = USBD_MSC_Initialize (instance);
;;;5620           if (status) status_ret = status;
;;;5621         }
;;;5622       }
;;;5623     }
;;;5624   #endif
;;;5625   
;;;5626     return status_ret;
000036  4638              MOV      r0,r7
;;;5627   }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;5628   
                          ENDP

                  |L36.60|
                          DCD      usbd_cdc_ptr

                          AREA ||i.USBD_ClassUninitialize||, CODE, READONLY, ALIGN=2

                  USBD_ClassUninitialize PROC
;;;5628   
;;;5629   usbStatus USBD_ClassUninitialize (uint8_t device) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;5630     uint8_t   instance;
;;;5631     usbStatus status_ret, status;
;;;5632   
;;;5633     status_ret = usbOK;
000006  2700              MOVS     r7,#0
;;;5634   #if (USBD_CUSTOM_CLASS_NUM > 0)
;;;5635     for (instance = 0; instance < usbd_custom_class_num; instance++) {
;;;5636       if (usbd_custom_class_ptr[instance] != NULL) {
;;;5637         if (usbd_custom_class_ptr[instance]->dev_num == device) {
;;;5638           status = USBD_CustomClass_Uninitialize (instance);
;;;5639           if (status) status_ret = status;
;;;5640         }
;;;5641       }
;;;5642     }
;;;5643   #endif
;;;5644   
;;;5645   #if (USBD_ADC_NUM > 0)
;;;5646     for (instance = 0; instance < usbd_adc_num; instance++) {
;;;5647       if ((usbd_adc_ptr[instance]->spkr_data_ptr != NULL) || (usbd_adc_ptr[instance]->mic_data_ptr != NULL)) {
;;;5648         if (usbd_adc_ptr[instance]->dev_num == device) {
;;;5649           status = USBD_ADC_Uninitialize (instance);
;;;5650           if (status) status_ret = status;
;;;5651         }
;;;5652       }
;;;5653     }
;;;5654   #endif
;;;5655   
;;;5656   #if (USBD_CDC_NUM > 0)
;;;5657     for (instance = 0; instance < usbd_cdc_num; instance++) {
000008  2400              MOVS     r4,#0
00000a  e012              B        |L37.50|
                  |L37.12|
;;;5658       if (usbd_cdc_ptr[instance]->data_ptr != NULL) {
00000c  480b              LDR      r0,|L37.60|
00000e  f8500024          LDR      r0,[r0,r4,LSL #2]
000012  6940              LDR      r0,[r0,#0x14]
000014  b158              CBZ      r0,|L37.46|
;;;5659         if (usbd_cdc_ptr[instance]->dev_num == device) {
000016  4809              LDR      r0,|L37.60|
000018  f8500024          LDR      r0,[r0,r4,LSL #2]
00001c  7e00              LDRB     r0,[r0,#0x18]
00001e  42b0              CMP      r0,r6
000020  d105              BNE      |L37.46|
;;;5660           status = USBD_CDC_Uninitialize (instance);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       USBD_CDC_Uninitialize
000028  4605              MOV      r5,r0
;;;5661           if (status) status_ret = status;
00002a  b105              CBZ      r5,|L37.46|
00002c  462f              MOV      r7,r5
                  |L37.46|
00002e  1c60              ADDS     r0,r4,#1              ;5657
000030  b2c4              UXTB     r4,r0                 ;5657
                  |L37.50|
000032  2c01              CMP      r4,#1                 ;5657
000034  dbea              BLT      |L37.12|
;;;5662         }
;;;5663       }
;;;5664     }
;;;5665   #endif
;;;5666   
;;;5667   #if (USBD_HID_NUM > 0)
;;;5668     for (instance = 0; instance < usbd_hid_num; instance++) {
;;;5669       if (usbd_hid_ptr[instance]->data_ptr != NULL) {
;;;5670         if (usbd_hid_ptr[instance]->dev_num == device) {
;;;5671           status = USBD_HID_Uninitialize (instance);
;;;5672           if (status) status_ret = status;
;;;5673         }
;;;5674       }
;;;5675     }
;;;5676   #endif
;;;5677   
;;;5678   #if (USBD_MSC_NUM > 0)
;;;5679     for (instance = 0; instance < usbd_msc_num; instance++) {
;;;5680       if (usbd_msc_ptr[instance]->data_ptr != NULL) {
;;;5681         if (usbd_msc_ptr[instance]->dev_num == device) {
;;;5682           status = USBD_MSC_Uninitialize (instance);
;;;5683           if (status) status_ret = status;
;;;5684         }
;;;5685       }
;;;5686     }
;;;5687   #endif
;;;5688   
;;;5689     return status_ret;
000036  4638              MOV      r0,r7
;;;5690   }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;5691   
                          ENDP

                  |L37.60|
                          DCD      usbd_cdc_ptr

                          AREA ||i.USBD_Class_Endpoint0_InDataSent||, CODE, READONLY, ALIGN=1

                  USBD_Class_Endpoint0_InDataSent PROC
;;;3214           usbdRequestStatus USBD_Class_Endpoint0_InDataSent                 (uint8_t device);
;;;3215           usbdRequestStatus USBD_Class_Endpoint0_InDataSent                 (uint8_t device)                                                     { (void)device; return usbdRequestNotProcessed; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3216   #else
                          ENDP


                          AREA ||i.USBD_Class_Endpoint0_OutDataReceived||, CODE, READONLY, ALIGN=1

                  USBD_Class_Endpoint0_OutDataReceived PROC
;;;3212           usbdRequestStatus USBD_Class_Endpoint0_OutDataReceived            (uint8_t device);
;;;3213           usbdRequestStatus USBD_Class_Endpoint0_OutDataReceived            (uint8_t device)                                                     { (void)device; return usbdRequestNotProcessed; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3214           usbdRequestStatus USBD_Class_Endpoint0_InDataSent                 (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Class_Endpoint0_SetupPacketProcessed||, CODE, READONLY, ALIGN=1

                  USBD_Class_Endpoint0_SetupPacketProcessed PROC
;;;3210           void              USBD_Class_Endpoint0_SetupPacketProcessed       (uint8_t device);
;;;3211           void              USBD_Class_Endpoint0_SetupPacketProcessed       (uint8_t device)                                                     { (void)device;                                 }
000000  4770              BX       lr
;;;3212           usbdRequestStatus USBD_Class_Endpoint0_OutDataReceived            (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Class_Endpoint0_SetupPacketReceived||, CODE, READONLY, ALIGN=1

                  USBD_Class_Endpoint0_SetupPacketReceived PROC
;;;3208           usbdRequestStatus USBD_Class_Endpoint0_SetupPacketReceived        (uint8_t device);
;;;3209           usbdRequestStatus USBD_Class_Endpoint0_SetupPacketReceived        (uint8_t device)                                                     { (void)device; return usbdRequestNotProcessed; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3210           void              USBD_Class_Endpoint0_SetupPacketProcessed       (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Delay||, CODE, READONLY, ALIGN=1

                  USBD_Delay PROC
;;;1803   ///                value < 0:           delay failed
;;;1804   int32_t USBD_Delay (uint32_t millisec) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1805     return (-osDelay (millisec));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       osDelay
00000a  4240              RSBS     r0,r0,#0
;;;1806   }
00000c  bd10              POP      {r4,pc}
;;;1807   
                          ENDP


                          AREA ||i.USBD_Device0_ConfigurationChanged||, CODE, READONLY, ALIGN=1

                  USBD_Device0_ConfigurationChanged PROC
;;;5306   __WEAK  void              USBD_Device0_Resumed                       (void)                                                               { }
;;;5307   __WEAK  void              USBD_Device0_ConfigurationChanged          (uint8_t val)                                                        { (void)val; }
000000  4770              BX       lr
;;;5308   __WEAK  void              USBD_Device0_EnableRemoteWakeup            (void)                                                               { }
                          ENDP


                          AREA ||i.USBD_Device0_DisableRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USBD_Device0_DisableRemoteWakeup PROC
;;;5308   __WEAK  void              USBD_Device0_EnableRemoteWakeup            (void)                                                               { }
;;;5309   __WEAK  void              USBD_Device0_DisableRemoteWakeup           (void)                                                               { }
000000  4770              BX       lr
;;;5310   __WEAK  usbdRequestStatus USBD_Device0_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len) { (void)setup_packet; (void)buf; (void)len; return usbdRequestNotProcessed; }
                          ENDP


                          AREA ||i.USBD_Device0_EnableRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USBD_Device0_EnableRemoteWakeup PROC
;;;5307   __WEAK  void              USBD_Device0_ConfigurationChanged          (uint8_t val)                                                        { (void)val; }
;;;5308   __WEAK  void              USBD_Device0_EnableRemoteWakeup            (void)                                                               { }
000000  4770              BX       lr
;;;5309   __WEAK  void              USBD_Device0_DisableRemoteWakeup           (void)                                                               { }
                          ENDP


                          AREA ||i.USBD_Device0_Endpoint0_InDataSent||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Endpoint0_InDataSent PROC
;;;5312   __WEAK  usbdRequestStatus USBD_Device0_Endpoint0_OutDataReceived     (uint32_t len)                                                       { (void)len; return usbdRequestNotProcessed; }
;;;5313   __WEAK  usbdRequestStatus USBD_Device0_Endpoint0_InDataSent          (uint32_t len)                                                       { (void)len; return usbdRequestNotProcessed; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;5314   #ifdef  RTE_USB_Device_1
                          ENDP


                          AREA ||i.USBD_Device0_Endpoint0_OutDataReceived||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Endpoint0_OutDataReceived PROC
;;;5311   __WEAK  void              USBD_Device0_Endpoint0_SetupPacketProcessed(const USB_SETUP_PACKET *setup_packet)                               { (void)setup_packet;                                                       }
;;;5312   __WEAK  usbdRequestStatus USBD_Device0_Endpoint0_OutDataReceived     (uint32_t len)                                                       { (void)len; return usbdRequestNotProcessed; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;5313   __WEAK  usbdRequestStatus USBD_Device0_Endpoint0_InDataSent          (uint32_t len)                                                       { (void)len; return usbdRequestNotProcessed; }
                          ENDP


                          AREA ||i.USBD_Device0_Endpoint0_SetupPacketProcessed||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Endpoint0_SetupPacketProcessed PROC
;;;5310   __WEAK  usbdRequestStatus USBD_Device0_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len) { (void)setup_packet; (void)buf; (void)len; return usbdRequestNotProcessed; }
;;;5311   __WEAK  void              USBD_Device0_Endpoint0_SetupPacketProcessed(const USB_SETUP_PACKET *setup_packet)                               { (void)setup_packet;                                                       }
000000  4770              BX       lr
;;;5312   __WEAK  usbdRequestStatus USBD_Device0_Endpoint0_OutDataReceived     (uint32_t len)                                                       { (void)len; return usbdRequestNotProcessed; }
                          ENDP


                          AREA ||i.USBD_Device0_Endpoint0_SetupPacketReceived||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Endpoint0_SetupPacketReceived PROC
;;;5309   __WEAK  void              USBD_Device0_DisableRemoteWakeup           (void)                                                               { }
;;;5310   __WEAK  usbdRequestStatus USBD_Device0_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len) { (void)setup_packet; (void)buf; (void)len; return usbdRequestNotProcessed; }
000000  4603              MOV      r3,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;5311   __WEAK  void              USBD_Device0_Endpoint0_SetupPacketProcessed(const USB_SETUP_PACKET *setup_packet)                               { (void)setup_packet;                                                       }
                          ENDP


                          AREA ||i.USBD_Device0_EventReset||, CODE, READONLY, ALIGN=1

                  USBD_Device0_EventReset PROC
;;;5301   extern  void              USBD_Device0_EventReset                    (void);
;;;5302   __WEAK  void              USBD_Device0_EventReset                    (void)         /* Deprecated */                                      { }
000000  4770              BX       lr
;;;5303   __WEAK  void              USBD_Device0_Reset                         (void)                                                               { USBD_Device0_EventReset (); }
                          ENDP


                          AREA ||i.USBD_Device0_HighSpeedActivated||, CODE, READONLY, ALIGN=1

                  USBD_Device0_HighSpeedActivated PROC
;;;5303   __WEAK  void              USBD_Device0_Reset                         (void)                                                               { USBD_Device0_EventReset (); }
;;;5304   __WEAK  void              USBD_Device0_HighSpeedActivated            (void)                                                               { }
000000  4770              BX       lr
;;;5305   __WEAK  void              USBD_Device0_Suspended                     (void)                                                               { }
                          ENDP


                          AREA ||i.USBD_Device0_Initialize||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Initialize PROC
;;;5297   
;;;5298   __WEAK  void              USBD_Device0_Initialize                    (void)                                                               { }
000000  4770              BX       lr
;;;5299   __WEAK  void              USBD_Device0_Uninitialize                  (void)                                                               { }
                          ENDP


                          AREA ||i.USBD_Device0_Reset||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Reset PROC
;;;5302   __WEAK  void              USBD_Device0_EventReset                    (void)         /* Deprecated */                                      { }
;;;5303   __WEAK  void              USBD_Device0_Reset                         (void)                                                               { USBD_Device0_EventReset (); }
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       USBD_Device0_EventReset
000006  bd10              POP      {r4,pc}
;;;5304   __WEAK  void              USBD_Device0_HighSpeedActivated            (void)                                                               { }
                          ENDP


                          AREA ||i.USBD_Device0_Resumed||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Resumed PROC
;;;5305   __WEAK  void              USBD_Device0_Suspended                     (void)                                                               { }
;;;5306   __WEAK  void              USBD_Device0_Resumed                       (void)                                                               { }
000000  4770              BX       lr
;;;5307   __WEAK  void              USBD_Device0_ConfigurationChanged          (uint8_t val)                                                        { (void)val; }
                          ENDP


                          AREA ||i.USBD_Device0_Suspended||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Suspended PROC
;;;5304   __WEAK  void              USBD_Device0_HighSpeedActivated            (void)                                                               { }
;;;5305   __WEAK  void              USBD_Device0_Suspended                     (void)                                                               { }
000000  4770              BX       lr
;;;5306   __WEAK  void              USBD_Device0_Resumed                       (void)                                                               { }
                          ENDP


                          AREA ||i.USBD_Device0_Uninitialize||, CODE, READONLY, ALIGN=1

                  USBD_Device0_Uninitialize PROC
;;;5298   __WEAK  void              USBD_Device0_Initialize                    (void)                                                               { }
;;;5299   __WEAK  void              USBD_Device0_Uninitialize                  (void)                                                               { }
000000  4770              BX       lr
;;;5300   __WEAK  void              USBD_Device0_VbusChanged                   (bool level)                                                         { (void)level; }
                          ENDP


                          AREA ||i.USBD_Device0_VbusChanged||, CODE, READONLY, ALIGN=1

                  USBD_Device0_VbusChanged PROC
;;;5299   __WEAK  void              USBD_Device0_Uninitialize                  (void)                                                               { }
;;;5300   __WEAK  void              USBD_Device0_VbusChanged                   (bool level)                                                         { (void)level; }
000000  4770              BX       lr
;;;5301   extern  void              USBD_Device0_EventReset                    (void);
                          ENDP


                          AREA ||i.USBD_Endpoint0_ClearFeatureStall_MSC||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_ClearFeatureStall_MSC PROC
;;;5096           void      USBD_Endpoint0_ClearFeatureStall_MSC    (uint8_t device, uint8_t ep_addr);
;;;5097           void      USBD_Endpoint0_ClearFeatureStall_MSC    (uint8_t device, uint8_t ep_addr)                             { (void)device; (void)ep_addr; }
000000  4770              BX       lr
;;;5098           bool      USBD_Endpoint0_Setup_MSC_ReqToIF        (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Endpoint0_Out_ADC_ReqToEP||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_Out_ADC_ReqToEP PROC
;;;3559           bool      USBD_Endpoint0_Out_ADC_ReqToEP      (uint8_t device);
;;;3560           bool      USBD_Endpoint0_Out_ADC_ReqToEP      (uint8_t device)               { (void)device; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3561   #else
                          ENDP


                          AREA ||i.USBD_Endpoint0_Out_ADC_ReqToIF||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_Out_ADC_ReqToIF PROC
;;;3555           bool      USBD_Endpoint0_Out_ADC_ReqToIF      (uint8_t device);
;;;3556           bool      USBD_Endpoint0_Out_ADC_ReqToIF      (uint8_t device)               { (void)device; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3557           bool      USBD_Endpoint0_Setup_ADC_ReqToEP    (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Endpoint0_Out_HID_ReqToIF||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_Out_HID_ReqToIF PROC
;;;4967           bool      USBD_Endpoint0_Out_HID_ReqToIF      (uint8_t device);
;;;4968           bool      USBD_Endpoint0_Out_HID_ReqToIF      (uint8_t device)                                                             { (void)device; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;4969   #else
                          ENDP


                          AREA ||i.USBD_Endpoint0_ReqGetDescriptor_HID||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_ReqGetDescriptor_HID PROC
;;;4963           bool      USBD_Endpoint0_ReqGetDescriptor_HID (uint8_t device, uint8_t **pD, uint32_t *len);
;;;4964           bool      USBD_Endpoint0_ReqGetDescriptor_HID (uint8_t device, uint8_t **pD, uint32_t *len)                                { (void)device; (void)pD; (void)len; return false; }
000000  4603              MOV      r3,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;4965           bool      USBD_Endpoint0_Setup_HID_ReqToIF    (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Endpoint0_ReqGetExtProp_CC||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_ReqGetExtProp_CC PROC
;;;3206           bool              USBD_Endpoint0_ReqGetExtProp_CC                 (uint8_t device, const uint8_t **pD);
;;;3207           bool              USBD_Endpoint0_ReqGetExtProp_CC                 (uint8_t device, const uint8_t **pD)                                 { (void)device; (void)pD; return false; }
000000  4602              MOV      r2,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3208           usbdRequestStatus USBD_Class_Endpoint0_SetupPacketReceived        (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Endpoint0_Setup_ADC_ReqToEP||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_Setup_ADC_ReqToEP PROC
;;;3557           bool      USBD_Endpoint0_Setup_ADC_ReqToEP    (uint8_t device);
;;;3558           bool      USBD_Endpoint0_Setup_ADC_ReqToEP    (uint8_t device)               { (void)device; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3559           bool      USBD_Endpoint0_Out_ADC_ReqToEP      (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Endpoint0_Setup_ADC_ReqToIF||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_Setup_ADC_ReqToIF PROC
;;;3553           bool      USBD_Endpoint0_Setup_ADC_ReqToIF    (uint8_t device);
;;;3554           bool      USBD_Endpoint0_Setup_ADC_ReqToIF    (uint8_t device)               { (void)device; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;3555           bool      USBD_Endpoint0_Out_ADC_ReqToIF      (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Endpoint0_Setup_HID_ReqToIF||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_Setup_HID_ReqToIF PROC
;;;4965           bool      USBD_Endpoint0_Setup_HID_ReqToIF    (uint8_t device);
;;;4966           bool      USBD_Endpoint0_Setup_HID_ReqToIF    (uint8_t device)                                                             { (void)device; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;4967           bool      USBD_Endpoint0_Out_HID_ReqToIF      (uint8_t device);
                          ENDP


                          AREA ||i.USBD_Endpoint0_Setup_MSC_ReqToIF||, CODE, READONLY, ALIGN=1

                  USBD_Endpoint0_Setup_MSC_ReqToIF PROC
;;;5098           bool      USBD_Endpoint0_Setup_MSC_ReqToIF        (uint8_t device);
;;;5099           bool      USBD_Endpoint0_Setup_MSC_ReqToIF        (uint8_t device)                                              { (void)device; return false; }
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  4770              BX       lr
;;;5100   #else
                          ENDP


                          AREA ||i.USBD_EndpointStart||, CODE, READONLY, ALIGN=2

                  USBD_EndpointStart PROC
;;;5765   
;;;5766   void USBD_EndpointStart (uint8_t device, uint8_t ep_addr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;5767     uint8_t instance;
;;;5768   
;;;5769   #if (USBD_CUSTOM_CLASS_NUM > 0)
;;;5770     uint8_t i;
;;;5771   
;;;5772     for (instance = 0; instance < usbd_custom_class_num; instance++) {
;;;5773       if (usbd_custom_class_ptr[instance] != NULL) {
;;;5774         if (usbd_custom_class_ptr[instance]->dev_num == device) {
;;;5775           for (i = 0U; i < 4U; i++) {
;;;5776             if (usbd_custom_class_ptr[instance]->cc[i].if_en) {
;;;5777               if (((usbd_custom_class_ptr[instance]->cc[i].if_ep0_en   != 0U)       &&
;;;5778                    (usbd_custom_class_ptr[instance]->cc[i].if_ep0_addr == ep_addr)) ||
;;;5779                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep1_en   != 0U)       &&
;;;5780                    (usbd_custom_class_ptr[instance]->cc[i].if_ep1_addr == ep_addr)) ||
;;;5781                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep2_en   != 0U)       &&
;;;5782                    (usbd_custom_class_ptr[instance]->cc[i].if_ep2_addr == ep_addr)) ||
;;;5783                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep3_en   != 0U)       &&
;;;5784                    (usbd_custom_class_ptr[instance]->cc[i].if_ep3_addr == ep_addr)) ||
;;;5785                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep4_en   != 0U)       &&
;;;5786                    (usbd_custom_class_ptr[instance]->cc[i].if_ep4_addr == ep_addr)) ||
;;;5787                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep5_en   != 0U)       &&
;;;5788                    (usbd_custom_class_ptr[instance]->cc[i].if_ep5_addr == ep_addr)) ||
;;;5789                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep6_en   != 0U)       &&
;;;5790                    (usbd_custom_class_ptr[instance]->cc[i].if_ep6_addr == ep_addr)) ||
;;;5791                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep7_en   != 0U)       &&
;;;5792                    (usbd_custom_class_ptr[instance]->cc[i].if_ep7_addr == ep_addr))) {
;;;5793                 USBD_CustomClass_EndpointStart (instance, ep_addr);
;;;5794               }
;;;5795             }
;;;5796           }
;;;5797         }
;;;5798       }
;;;5799     }
;;;5800   #endif
;;;5801   
;;;5802   #if (USBD_ADC_NUM > 0)
;;;5803     for (instance = 0; instance < usbd_adc_num; instance++) {
;;;5804       if (usbd_adc_ptr[instance]->dev_num == device) {
;;;5805         if ((usbd_adc_ptr[instance]->spkr_data_ptr != NULL) && (usbd_adc_ptr[instance]->out_cfg != NULL)) {
;;;5806           if ((usbd_adc_ptr[instance]->out_cfg->ep_iso) == ep_addr) {
;;;5807             USBD_ADC_EndpointStart (instance, ep_addr);
;;;5808           }
;;;5809         }
;;;5810         if ((usbd_adc_ptr[instance]->mic_data_ptr  != NULL) && (usbd_adc_ptr[instance]->in_cfg  != NULL)) {
;;;5811           if ((usbd_adc_ptr[instance]->in_cfg->ep_iso | 0x80) == ep_addr) {
;;;5812             USBD_ADC_EndpointStart (instance, ep_addr);
;;;5813           }
;;;5814         }
;;;5815       }
;;;5816     }
;;;5817   #endif
;;;5818   
;;;5819   #if (USBD_CDC_NUM > 0)
;;;5820     for (instance = 0; instance < usbd_cdc_num; instance++) {
000006  2400              MOVS     r4,#0
000008  e026              B        |L68.88|
                  |L68.10|
;;;5821       if (usbd_cdc_ptr[instance]->data_ptr != NULL) {
00000a  4815              LDR      r0,|L68.96|
00000c  f8500024          LDR      r0,[r0,r4,LSL #2]
000010  6940              LDR      r0,[r0,#0x14]
000012  b1f8              CBZ      r0,|L68.84|
;;;5822         if (usbd_cdc_ptr[instance]->dev_num == device) {
000014  4812              LDR      r0,|L68.96|
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  7e00              LDRB     r0,[r0,#0x18]
00001c  42b0              CMP      r0,r6
00001e  d119              BNE      |L68.84|
;;;5823           if (((usbd_cdc_ptr[instance]->ep_int_in  | 0x80) == ep_addr) ||
000020  480f              LDR      r0,|L68.96|
000022  f8500024          LDR      r0,[r0,r4,LSL #2]
000026  7f40              LDRB     r0,[r0,#0x1d]
000028  f0400080          ORR      r0,r0,#0x80
00002c  42a8              CMP      r0,r5
00002e  d00d              BEQ      |L68.76|
;;;5824               ((usbd_cdc_ptr[instance]->ep_bulk_in | 0x80) == ep_addr) ||
000030  480b              LDR      r0,|L68.96|
000032  f8500024          LDR      r0,[r0,r4,LSL #2]
000036  7f80              LDRB     r0,[r0,#0x1e]
000038  f0400080          ORR      r0,r0,#0x80
00003c  42a8              CMP      r0,r5
00003e  d005              BEQ      |L68.76|
;;;5825               ((usbd_cdc_ptr[instance]->ep_bulk_out      ) == ep_addr)) {
000040  4807              LDR      r0,|L68.96|
000042  f8500024          LDR      r0,[r0,r4,LSL #2]
000046  7fc0              LDRB     r0,[r0,#0x1f]
000048  42a8              CMP      r0,r5
00004a  d103              BNE      |L68.84|
                  |L68.76|
;;;5826             USBD_CDC_EndpointStart (instance, ep_addr);
00004c  4629              MOV      r1,r5
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       USBD_CDC_EndpointStart
                  |L68.84|
000054  1c60              ADDS     r0,r4,#1              ;5820
000056  b2c4              UXTB     r4,r0                 ;5820
                  |L68.88|
000058  2c01              CMP      r4,#1                 ;5820
00005a  dbd6              BLT      |L68.10|
;;;5827           }
;;;5828         }
;;;5829       }
;;;5830     }
;;;5831   #endif
;;;5832   
;;;5833   #if (USBD_HID_NUM > 0)
;;;5834     for (instance = 0; instance < usbd_hid_num; instance++) {
;;;5835       if (usbd_hid_ptr[instance]->data_ptr != NULL) {
;;;5836         if (usbd_hid_ptr[instance]->dev_num == device) {
;;;5837           if (((usbd_hid_ptr[instance]->ep_int_in | 0x80) == ep_addr) ||
;;;5838               ((usbd_hid_ptr[instance]->ep_int_out      ) == ep_addr)) {
;;;5839             USBD_HID_EndpointStart (instance, ep_addr);
;;;5840           }
;;;5841         }
;;;5842       }
;;;5843     }
;;;5844   #endif
;;;5845   
;;;5846   #if (USBD_MSC_NUM > 0)
;;;5847     for (instance = 0; instance < usbd_msc_num; instance++) {
;;;5848       if (usbd_msc_ptr[instance]->data_ptr != NULL) {
;;;5849         if (usbd_msc_ptr[instance]->dev_num == device) {
;;;5850           if (((usbd_msc_ptr[instance]->ep_bulk_in | 0x80) == ep_addr) ||
;;;5851               ((usbd_msc_ptr[instance]->ep_bulk_out      ) == ep_addr)) {
;;;5852             USBD_MSC_EndpointStart (instance, ep_addr);
;;;5853           }
;;;5854         }
;;;5855       }
;;;5856     }
;;;5857   #endif
;;;5858   }
00005c  bd70              POP      {r4-r6,pc}
;;;5859   
                          ENDP

00005e  0000              DCW      0x0000
                  |L68.96|
                          DCD      usbd_cdc_ptr

                          AREA ||i.USBD_EndpointStop||, CODE, READONLY, ALIGN=2

                  USBD_EndpointStop PROC
;;;5859   
;;;5860   void USBD_EndpointStop (uint8_t device, uint8_t ep_addr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;5861   #if ((USBD_CUSTOM_CLASS_NUM > 0) || (USBD_ADC_NUM > 0)  || (USBD_CDC_NUM > 0))
;;;5862     uint8_t instance;
;;;5863   #else
;;;5864     (void)device;
;;;5865     (void)ep_addr;
;;;5866   #endif
;;;5867   
;;;5868   #if (USBD_CUSTOM_CLASS_NUM > 0)
;;;5869     uint8_t i;
;;;5870   
;;;5871     for (instance = 0; instance < usbd_custom_class_num; instance++) {
;;;5872       if (usbd_custom_class_ptr[instance] != NULL) {
;;;5873         if (usbd_custom_class_ptr[instance]->dev_num == device) {
;;;5874           for (i = 0U; i < 4U; i++) {
;;;5875             if (usbd_custom_class_ptr[instance]->cc[i].if_en) {
;;;5876               if (((usbd_custom_class_ptr[instance]->cc[i].if_ep0_en   != 0U)       &&
;;;5877                    (usbd_custom_class_ptr[instance]->cc[i].if_ep0_addr == ep_addr)) ||
;;;5878                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep1_en   != 0U)       &&
;;;5879                    (usbd_custom_class_ptr[instance]->cc[i].if_ep1_addr == ep_addr)) ||
;;;5880                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep2_en   != 0U)       &&
;;;5881                    (usbd_custom_class_ptr[instance]->cc[i].if_ep2_addr == ep_addr)) ||
;;;5882                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep3_en   != 0U)       &&
;;;5883                    (usbd_custom_class_ptr[instance]->cc[i].if_ep3_addr == ep_addr)) ||
;;;5884                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep4_en   != 0U)       &&
;;;5885                    (usbd_custom_class_ptr[instance]->cc[i].if_ep4_addr == ep_addr)) ||
;;;5886                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep5_en   != 0U)       &&
;;;5887                    (usbd_custom_class_ptr[instance]->cc[i].if_ep5_addr == ep_addr)) ||
;;;5888                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep6_en   != 0U)       &&
;;;5889                    (usbd_custom_class_ptr[instance]->cc[i].if_ep6_addr == ep_addr)) ||
;;;5890                   ((usbd_custom_class_ptr[instance]->cc[i].if_ep7_en   != 0U)       &&
;;;5891                    (usbd_custom_class_ptr[instance]->cc[i].if_ep7_addr == ep_addr))) {
;;;5892                 USBD_CustomClass_EndpointStop (instance, ep_addr);
;;;5893               }
;;;5894             }
;;;5895           }
;;;5896         }
;;;5897       }
;;;5898     }
;;;5899   #endif
;;;5900   
;;;5901   #if (USBD_ADC_NUM > 0)
;;;5902     for (instance = 0; instance < usbd_adc_num; instance++) {
;;;5903       if (usbd_adc_ptr[instance]->dev_num == device) {
;;;5904         if ((usbd_adc_ptr[instance]->spkr_data_ptr != NULL) && (usbd_adc_ptr[instance]->out_cfg != NULL)) {
;;;5905           if ((usbd_adc_ptr[instance]->out_cfg->ep_iso) == ep_addr) {
;;;5906             USBD_ADC_EndpointStop (instance, ep_addr);
;;;5907           }
;;;5908         }
;;;5909         if ((usbd_adc_ptr[instance]->mic_data_ptr  != NULL) && (usbd_adc_ptr[instance]->in_cfg  != NULL)) {
;;;5910           if ((usbd_adc_ptr[instance]->in_cfg->ep_iso | 0x80) == ep_addr) {
;;;5911             USBD_ADC_EndpointStop (instance, ep_addr);
;;;5912           }
;;;5913         }
;;;5914       }
;;;5915     }
;;;5916   #endif
;;;5917   
;;;5918   #if (USBD_CDC_NUM > 0)
;;;5919     for (instance = 0; instance < usbd_cdc_num; instance++) {
000006  2400              MOVS     r4,#0
000008  e026              B        |L69.88|
                  |L69.10|
;;;5920       if (usbd_cdc_ptr[instance]->data_ptr != NULL) {
00000a  4815              LDR      r0,|L69.96|
00000c  f8500024          LDR      r0,[r0,r4,LSL #2]
000010  6940              LDR      r0,[r0,#0x14]
000012  b1f8              CBZ      r0,|L69.84|
;;;5921         if (usbd_cdc_ptr[instance]->dev_num == device) {
000014  4812              LDR      r0,|L69.96|
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  7e00              LDRB     r0,[r0,#0x18]
00001c  42b0              CMP      r0,r6
00001e  d119              BNE      |L69.84|
;;;5922           if (((usbd_cdc_ptr[instance]->ep_int_in  | 0x80) == ep_addr) ||
000020  480f              LDR      r0,|L69.96|
000022  f8500024          LDR      r0,[r0,r4,LSL #2]
000026  7f40              LDRB     r0,[r0,#0x1d]
000028  f0400080          ORR      r0,r0,#0x80
00002c  42a8              CMP      r0,r5
00002e  d00d              BEQ      |L69.76|
;;;5923               ((usbd_cdc_ptr[instance]->ep_bulk_in | 0x80) == ep_addr) ||
000030  480b              LDR      r0,|L69.96|
000032  f8500024          LDR      r0,[r0,r4,LSL #2]
000036  7f80              LDRB     r0,[r0,#0x1e]
000038  f0400080          ORR      r0,r0,#0x80
00003c  42a8              CMP      r0,r5
00003e  d005              BEQ      |L69.76|
;;;5924               ((usbd_cdc_ptr[instance]->ep_bulk_out      ) == ep_addr)) {
000040  4807              LDR      r0,|L69.96|
000042  f8500024          LDR      r0,[r0,r4,LSL #2]
000046  7fc0              LDRB     r0,[r0,#0x1f]
000048  42a8              CMP      r0,r5
00004a  d103              BNE      |L69.84|
                  |L69.76|
;;;5925             USBD_CDC_EndpointStop (instance, ep_addr);
00004c  4629              MOV      r1,r5
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       USBD_CDC_EndpointStop
                  |L69.84|
000054  1c60              ADDS     r0,r4,#1              ;5919
000056  b2c4              UXTB     r4,r0                 ;5919
                  |L69.88|
000058  2c01              CMP      r4,#1                 ;5919
00005a  dbd6              BLT      |L69.10|
;;;5926           }
;;;5927         }
;;;5928       }
;;;5929     }
;;;5930   #endif
;;;5931   }
00005c  bd70              POP      {r4-r6,pc}
;;;5932   #endif
                          ENDP

00005e  0000              DCW      0x0000
                  |L69.96|
                          DCD      usbd_cdc_ptr

                          AREA ||i.USBD_Reset||, CODE, READONLY, ALIGN=2

                  USBD_Reset PROC
;;;5691   
;;;5692   void USBD_Reset (uint8_t device) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;5693     uint8_t instance;
;;;5694   
;;;5695   #if (USBD_CUSTOM_CLASS_NUM > 0)
;;;5696     for (instance = 0; instance < usbd_custom_class_num; instance++) {
;;;5697       if (usbd_custom_class_ptr[instance] != NULL) {
;;;5698         if (usbd_custom_class_ptr[instance]->dev_num == device) {
;;;5699           USBD_CustomClass_Reset (instance);
;;;5700         }
;;;5701       }
;;;5702     }
;;;5703   #endif
;;;5704   
;;;5705   #if (USBD_ADC_NUM > 0)
;;;5706     for (instance = 0; instance < usbd_adc_num; instance++) {
;;;5707       if ((usbd_adc_ptr[instance]->spkr_data_ptr != NULL) || (usbd_adc_ptr[instance]->mic_data_ptr != NULL)){
;;;5708         if (usbd_adc_ptr[instance]->dev_num == device) {
;;;5709           USBD_ADC_Reset (instance);
;;;5710         }
;;;5711       }
;;;5712     }
;;;5713   #endif
;;;5714   
;;;5715   #if (USBD_CDC_NUM > 0)
;;;5716     for (instance = 0; instance < usbd_cdc_num; instance++) {
000004  2400              MOVS     r4,#0
000006  e00f              B        |L70.40|
                  |L70.8|
;;;5717       if (usbd_cdc_ptr[instance]->data_ptr != NULL) {
000008  4809              LDR      r0,|L70.48|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  6940              LDR      r0,[r0,#0x14]
000010  b140              CBZ      r0,|L70.36|
;;;5718         if (usbd_cdc_ptr[instance]->dev_num == device) {
000012  4807              LDR      r0,|L70.48|
000014  f8500024          LDR      r0,[r0,r4,LSL #2]
000018  7e00              LDRB     r0,[r0,#0x18]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L70.36|
;;;5719           USBD_CDC_Reset (instance);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       USBD_CDC_Reset
                  |L70.36|
000024  1c60              ADDS     r0,r4,#1              ;5716
000026  b2c4              UXTB     r4,r0                 ;5716
                  |L70.40|
000028  2c01              CMP      r4,#1                 ;5716
00002a  dbed              BLT      |L70.8|
;;;5720         }
;;;5721       }
;;;5722     }
;;;5723   #endif
;;;5724   
;;;5725   #if (USBD_HID_NUM > 0)
;;;5726     for (instance = 0; instance < usbd_hid_num; instance++) {
;;;5727       if (usbd_hid_ptr[instance]->data_ptr != NULL) {
;;;5728         if (usbd_hid_ptr[instance]->dev_num == device) {
;;;5729           USBD_HID_Reset (instance);
;;;5730         }
;;;5731       }
;;;5732     }
;;;5733   #endif
;;;5734   
;;;5735   #if (USBD_MSC_NUM > 0)
;;;5736     for (instance = 0; instance < usbd_msc_num; instance++) {
;;;5737       if (usbd_msc_ptr[instance]->data_ptr != NULL) {
;;;5738         if (usbd_msc_ptr[instance]->dev_num == device) {
;;;5739           USBD_MSC_Reset (instance);
;;;5740         }
;;;5741       }
;;;5742     }
;;;5743   #endif
;;;5744   }
00002c  bd70              POP      {r4-r6,pc}
;;;5745   
                          ENDP

00002e  0000              DCW      0x0000
                  |L70.48|
                          DCD      usbd_cdc_ptr

                          AREA ||i.USBD_SemaphoreAcquire||, CODE, READONLY, ALIGN=1

                  USBD_SemaphoreAcquire PROC
;;;1920   ///                value < 0:           token acquire failed
;;;1921   int32_t USBD_SemaphoreAcquire (void *semaphore_hndl, uint32_t millisec) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1922     int32_t result;
;;;1923   
;;;1924     if (semaphore_hndl == NULL) { return -1; }
000006  b915              CBNZ     r5,|L71.14|
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L71.12|
;;;1925     result = osSemaphoreWait ((osSemaphoreId)semaphore_hndl, millisec);
;;;1926     if (result == 1) {
;;;1927       return  0;
;;;1928     } else {
;;;1929       return -1;
;;;1930     }
;;;1931   }
00000c  bd70              POP      {r4-r6,pc}
                  |L71.14|
00000e  4631              MOV      r1,r6                 ;1925
000010  4628              MOV      r0,r5                 ;1925
000012  f7fffffe          BL       osSemaphoreWait
000016  4604              MOV      r4,r0                 ;1925
000018  2c01              CMP      r4,#1                 ;1926
00001a  d101              BNE      |L71.32|
00001c  2000              MOVS     r0,#0                 ;1927
00001e  e7f5              B        |L71.12|
                  |L71.32|
000020  f04f30ff          MOV      r0,#0xffffffff        ;1929
000024  e7f2              B        |L71.12|
;;;1932   
                          ENDP


                          AREA ||i.USBD_SemaphoreCreate||, CODE, READONLY, ALIGN=2

                  USBD_SemaphoreCreate PROC
;;;1889   ///                value = 0:           semaphore creation failed
;;;1890   void *USBD_SemaphoreCreate (usbdSemaphore_t semaphore, uint8_t index1, uint8_t index2) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1891     switch (semaphore) {
000008  b126              CBZ      r6,|L72.20|
00000a  2e01              CMP      r6,#1
00000c  d00d              BEQ      |L72.42|
00000e  2e02              CMP      r6,#2
000010  d120              BNE      |L72.84|
000012  e01d              B        |L72.80|
                  |L72.20|
;;;1892       case usbdSemaphoreCore:
;;;1893         if (index1 >= USBD_DEV_NUM)       { return NULL; }
000014  2c01              CMP      r4,#1
000016  db01              BLT      |L72.28|
000018  2000              MOVS     r0,#0
                  |L72.26|
;;;1894         return ((void *)osSemaphoreCreate (usbd_driver_semaphore_def_ptr[index1],            1U));
;;;1895   
;;;1896       case usbdSemaphoreEndpoint:
;;;1897         if (index1 >=  USBD_DEV_NUM)      { return NULL; }
;;;1898         if (index2 >= (USBD_EP_NUM * 2U)) { return NULL; }
;;;1899         return ((void *)osSemaphoreCreate (usbd_driver_ep_semaphore_def_ptr[index1][index2], 1U));
;;;1900   
;;;1901       case usbdSemaphoreHID:
;;;1902   #if (USBD_HID_NUM > 0)
;;;1903         if (index1 >= USBD_HID_NUM)       { return NULL; }
;;;1904         return ((void *)osSemaphoreCreate (usbd_hid_semaphore_def_ptr[index1],               1U));
;;;1905   #else
;;;1906         (void)semaphore;
;;;1907         (void) index1;
;;;1908         (void)index2;
;;;1909         return NULL;
;;;1910   #endif
;;;1911     }
;;;1912     return NULL;
;;;1913   }
00001a  bd70              POP      {r4-r6,pc}
                  |L72.28|
00001c  490e              LDR      r1,|L72.88|
00001e  f8510024          LDR      r0,[r1,r4,LSL #2]     ;1894
000022  2101              MOVS     r1,#1                 ;1894
000024  f7fffffe          BL       osSemaphoreCreate
000028  e7f7              B        |L72.26|
                  |L72.42|
00002a  2c01              CMP      r4,#1                 ;1897
00002c  db01              BLT      |L72.50|
00002e  2000              MOVS     r0,#0                 ;1897
000030  e7f3              B        |L72.26|
                  |L72.50|
000032  2d06              CMP      r5,#6                 ;1898
000034  d301              BCC      |L72.58|
000036  2000              MOVS     r0,#0                 ;1898
000038  e7ef              B        |L72.26|
                  |L72.58|
00003a  eb040144          ADD      r1,r4,r4,LSL #1       ;1899
00003e  4a07              LDR      r2,|L72.92|
000040  eb0201c1          ADD      r1,r2,r1,LSL #3       ;1899
000044  f8510025          LDR      r0,[r1,r5,LSL #2]     ;1899
000048  2101              MOVS     r1,#1                 ;1899
00004a  f7fffffe          BL       osSemaphoreCreate
00004e  e7e4              B        |L72.26|
                  |L72.80|
000050  2000              MOVS     r0,#0                 ;1909
000052  e7e2              B        |L72.26|
                  |L72.84|
000054  2000              MOVS     r0,#0                 ;1912
000056  e7e0              B        |L72.26|
;;;1914   
                          ENDP

                  |L72.88|
                          DCD      usbd_driver_semaphore_def_ptr
                  |L72.92|
                          DCD      usbd_driver_ep_semaphore_def_ptr

                          AREA ||i.USBD_SemaphoreDelete||, CODE, READONLY, ALIGN=1

                  USBD_SemaphoreDelete PROC
;;;1947   ///                value < 0:           semaphore deletion failed
;;;1948   int32_t USBD_SemaphoreDelete (void *semaphore_hndl) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1949     if (semaphore_hndl == NULL) { return -1; }
000004  b914              CBNZ     r4,|L73.12|
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L73.10|
;;;1950     return (-osSemaphoreDelete ((osSemaphoreId)semaphore_hndl));
;;;1951   }
00000a  bd10              POP      {r4,pc}
                  |L73.12|
00000c  4620              MOV      r0,r4                 ;1950
00000e  f7fffffe          BL       osSemaphoreDelete
000012  4240              RSBS     r0,r0,#0              ;1950
000014  e7f9              B        |L73.10|
;;;3103   #else
                          ENDP


                          AREA ||i.USBD_SemaphoreRelease||, CODE, READONLY, ALIGN=1

                  USBD_SemaphoreRelease PROC
;;;1937   ///                value < 0:           token release failed
;;;1938   int32_t USBD_SemaphoreRelease (void *semaphore_hndl) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1939     if (semaphore_hndl == NULL) { return -1; }
000004  b914              CBNZ     r4,|L74.12|
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L74.10|
;;;1940     return (-osSemaphoreRelease ((osSemaphoreId)semaphore_hndl));
;;;1941   }
00000a  bd10              POP      {r4,pc}
                  |L74.12|
00000c  4620              MOV      r0,r4                 ;1940
00000e  f7fffffe          BL       osSemaphoreRelease
000012  4240              RSBS     r0,r0,#0              ;1940
000014  e7f9              B        |L74.10|
;;;1942   
                          ENDP


                          AREA ||i.USBD_SetConfiguration||, CODE, READONLY, ALIGN=1

                  USBD_SetConfiguration PROC
;;;5745   
;;;5746   void USBD_SetConfiguration (uint8_t device, uint8_t configuration) {
000000  4770              BX       lr
;;;5747   
;;;5748   #if (USBD_HID_NUM > 0)
;;;5749     uint8_t instance;
;;;5750   
;;;5751     if (configuration != 0U) {
;;;5752       for (instance = 0; instance < usbd_hid_num; instance++) {
;;;5753         if (usbd_hid_ptr[instance]->data_ptr != NULL) {
;;;5754           if (usbd_hid_ptr[instance]->dev_num == device) {
;;;5755             USBD_HID_SetConfiguration (instance);
;;;5756           }
;;;5757         }
;;;5758       }
;;;5759     }
;;;5760   #else
;;;5761     (void)device;
;;;5762     (void)configuration;
;;;5763   #endif
;;;5764   }
;;;5765   
                          ENDP


                          AREA ||i.USBD_ThreadCreate||, CODE, READONLY, ALIGN=2

                  USBD_ThreadCreate PROC
;;;1730   ///                value = 0:           thread creation failed
;;;1731   void *USBD_ThreadCreate (usbdThread_t thread, uint8_t index) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1732     (void)index;
;;;1733   
;;;1734     switch (thread) {
000006  2d07              CMP      r5,#7
000008  d22e              BCS      |L76.104|
00000a  e8dff005          TBB      [pc,r5]
00000e  040f              DCB      0x04,0x0f
000010  11131e29          DCB      0x11,0x13,0x1e,0x29
000014  2b00              DCB      0x2b,0x00
;;;1735       case usbdThreadCore:
;;;1736         if (index >= USBD_DEV_NUM) { return NULL; }
000016  2c01              CMP      r4,#1
000018  db01              BLT      |L76.30|
00001a  2000              MOVS     r0,#0
                  |L76.28|
;;;1737         return ((void *)osThreadCreate (usbd_core_thread_def_ptr[index],            NULL));
;;;1738   
;;;1739       case usbdThreadCC:
;;;1740   #if (USBD_CUSTOM_CLASS_NUM > 0)
;;;1741         if (index >= (USBD_CUSTOM_CLASS_NUM * USBD_EP_NUM)) { return NULL; }
;;;1742         return ((void *)osThreadCreate (usbd_custom_class_ep_thread_def_ptr[index], NULL));
;;;1743   #else
;;;1744         return NULL;
;;;1745   #endif
;;;1746   
;;;1747       case usbdThreadADC:
;;;1748   #if (USBD_ADC_NUM > 0)
;;;1749         if (index >= USBD_ADC_NUM) { return NULL; }
;;;1750         return ((void *)osThreadCreate (usbd_adc_thread_def_ptr[index],             NULL));
;;;1751   #else
;;;1752         return NULL;
;;;1753   #endif
;;;1754   
;;;1755       case usbdThreadCDC_Int:
;;;1756   #if (USBD_CDC_NUM > 0)
;;;1757         if (index >= USBD_CDC_NUM) { return NULL; }
;;;1758         return ((void *)osThreadCreate (usbd_cdc_int_thread_def_ptr[index],         NULL));
;;;1759   #else
;;;1760         return NULL;
;;;1761   #endif
;;;1762       case usbdThreadCDC_Bulk:
;;;1763   #if (USBD_CDC_NUM > 0)
;;;1764         if (index >= USBD_CDC_NUM) { return NULL; }
;;;1765         return ((void *)osThreadCreate (usbd_cdc_bulk_thread_def_ptr[index],        NULL));
;;;1766   #else
;;;1767         return NULL;
;;;1768   #endif
;;;1769   
;;;1770       case usbdThreadHID:
;;;1771   #if (USBD_HID_NUM > 0)
;;;1772         if (index >= USBD_HID_NUM) { return NULL; }
;;;1773         return ((void *)osThreadCreate (usbd_hid_thread_def_ptr[index],             NULL));
;;;1774   #else
;;;1775         return NULL;
;;;1776   #endif
;;;1777   
;;;1778       case usbdThreadMSC:
;;;1779   #if (USBD_MSC_NUM > 0)
;;;1780         if (index >= USBD_MSC_NUM) { return NULL; }
;;;1781         return ((void *)osThreadCreate (usbd_msc_thread_def_ptr[index],             NULL));
;;;1782   #else
;;;1783         return NULL;
;;;1784   #endif
;;;1785     }
;;;1786     return NULL;
;;;1787   }
00001c  bd70              POP      {r4-r6,pc}
                  |L76.30|
00001e  4913              LDR      r1,|L76.108|
000020  f8510024          LDR      r0,[r1,r4,LSL #2]     ;1737
000024  2100              MOVS     r1,#0                 ;1737
000026  f7fffffe          BL       osThreadCreate
00002a  e7f7              B        |L76.28|
00002c  2000              MOVS     r0,#0                 ;1744
00002e  e7f5              B        |L76.28|
000030  2000              MOVS     r0,#0                 ;1752
000032  e7f3              B        |L76.28|
000034  2c01              CMP      r4,#1                 ;1757
000036  db01              BLT      |L76.60|
000038  2000              MOVS     r0,#0                 ;1757
00003a  e7ef              B        |L76.28|
                  |L76.60|
00003c  490c              LDR      r1,|L76.112|
00003e  f8510024          LDR      r0,[r1,r4,LSL #2]     ;1758
000042  2100              MOVS     r1,#0                 ;1758
000044  f7fffffe          BL       osThreadCreate
000048  e7e8              B        |L76.28|
00004a  2c01              CMP      r4,#1                 ;1764
00004c  db01              BLT      |L76.82|
00004e  2000              MOVS     r0,#0                 ;1764
000050  e7e4              B        |L76.28|
                  |L76.82|
000052  4908              LDR      r1,|L76.116|
000054  f8510024          LDR      r0,[r1,r4,LSL #2]     ;1765
000058  2100              MOVS     r1,#0                 ;1765
00005a  f7fffffe          BL       osThreadCreate
00005e  e7dd              B        |L76.28|
000060  2000              MOVS     r0,#0                 ;1775
000062  e7db              B        |L76.28|
000064  2000              MOVS     r0,#0                 ;1783
000066  e7d9              B        |L76.28|
                  |L76.104|
000068  2000              MOVS     r0,#0                 ;1786
00006a  e7d7              B        |L76.28|
;;;1788   
                          ENDP

                  |L76.108|
                          DCD      usbd_core_thread_def_ptr
                  |L76.112|
                          DCD      usbd_cdc_int_thread_def_ptr
                  |L76.116|
                          DCD      usbd_cdc_bulk_thread_def_ptr

                          AREA ||i.USBD_ThreadFlagsSet||, CODE, READONLY, ALIGN=1

                  USBD_ThreadFlagsSet PROC
;;;1858   ///                value >= 0x80000000: setting of flags failed
;;;1859   uint32_t USBD_ThreadFlagsSet (void *thread_hndl, uint32_t flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1860     if (thread_hndl == NULL) { return 0x80000000U; }
000006  b914              CBNZ     r4,|L77.14|
000008  f04f4000          MOV      r0,#0x80000000
                  |L77.12|
;;;1861     return ((uint32_t)osSignalSet ((osThreadId)thread_hndl, (int32_t)flags));
;;;1862   }
00000c  bd70              POP      {r4-r6,pc}
                  |L77.14|
00000e  4629              MOV      r1,r5                 ;1861
000010  4620              MOV      r0,r4                 ;1861
000012  f7fffffe          BL       osSignalSet
000016  e7f9              B        |L77.12|
;;;1863   
                          ENDP


                          AREA ||i.USBD_ThreadFlagsWait||, CODE, READONLY, ALIGN=1

                  USBD_ThreadFlagsWait PROC
;;;1869   ///                value >= 0x80000000: error
;;;1870   uint32_t USBD_ThreadFlagsWait (uint32_t millisec) {
000000  b53e              PUSH     {r1-r5,lr}
000002  4604              MOV      r4,r0
;;;1871     osEvent event;
;;;1872   
;;;1873     event = osSignalWait (0U, millisec);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       osSignalWait
00000c  e88d0007          STM      sp,{r0-r2}
;;;1874     if (event.status == osEventSignal) {
000010  9800              LDR      r0,[sp,#0]
000012  2808              CMP      r0,#8
000014  d101              BNE      |L78.26|
;;;1875       return ((uint32_t)event.value.signals);
000016  9801              LDR      r0,[sp,#4]
                  |L78.24|
;;;1876     } else if (event.status == osEventTimeout) {
;;;1877       return 0U;
;;;1878     } else {
;;;1879       return 0x80000000U;
;;;1880     }
;;;1881   }
000018  bd3e              POP      {r1-r5,pc}
                  |L78.26|
00001a  9800              LDR      r0,[sp,#0]            ;1876
00001c  2840              CMP      r0,#0x40              ;1876
00001e  d101              BNE      |L78.36|
000020  2000              MOVS     r0,#0                 ;1877
000022  e7f9              B        |L78.24|
                  |L78.36|
000024  f04f4000          MOV      r0,#0x80000000        ;1879
000028  e7f6              B        |L78.24|
;;;1882   
                          ENDP


                          AREA ||i.USBD_ThreadTerminate||, CODE, READONLY, ALIGN=1

                  USBD_ThreadTerminate PROC
;;;1793   ///                value < 0:           thread termination failed
;;;1794   int32_t USBD_ThreadTerminate (void *thread_hndl) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1795     if (thread_hndl == NULL) { return -1; }
000004  b914              CBNZ     r4,|L79.12|
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L79.10|
;;;1796     return (-osThreadTerminate ((osThreadId)thread_hndl));
;;;1797   }
00000a  bd10              POP      {r4,pc}
                  |L79.12|
00000c  4620              MOV      r0,r4                 ;1796
00000e  f7fffffe          BL       osThreadTerminate
000012  4240              RSBS     r0,r0,#0              ;1796
000014  e7f9              B        |L79.10|
;;;1798   
                          ENDP


                          AREA ||i.USBD_TimerCreate||, CODE, READONLY, ALIGN=1

                  USBD_TimerCreate PROC
;;;1812   ///                value = 0:           timer creation failed
;;;1813   void *USBD_TimerCreate (uint8_t instance) {
000000  4601              MOV      r1,r0
;;;1814   #if (USBD_HID_NUM > 0)
;;;1815     if (instance >= USBD_HID_NUM) { return NULL; }
;;;1816     return ((void *)osTimerCreate (usbd_hid_timer_def_ptr[instance], osTimerPeriodic, (void *)(uint32_t)instance));
;;;1817   #else
;;;1818     (void)instance;
;;;1819     return NULL;
000002  2000              MOVS     r0,#0
;;;1820   #endif
;;;1821   }
000004  4770              BX       lr
;;;1822   
                          ENDP


                          AREA ||i.USBD_TimerDelete||, CODE, READONLY, ALIGN=1

                  USBD_TimerDelete PROC
;;;1847   ///                value < 0:           timer deletion failed
;;;1848   int32_t USBD_TimerDelete (void *timer_hndl) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1849     if (timer_hndl == NULL) { return -1; }
000004  b914              CBNZ     r4,|L81.12|
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L81.10|
;;;1850     return (-osTimerDelete ((osTimerId)timer_hndl));
;;;1851   }
00000a  bd10              POP      {r4,pc}
                  |L81.12|
00000c  4620              MOV      r0,r4                 ;1850
00000e  f7fffffe          BL       osTimerDelete
000012  4240              RSBS     r0,r0,#0              ;1850
000014  e7f9              B        |L81.10|
;;;1852   
                          ENDP


                          AREA ||i.USBD_TimerStart||, CODE, READONLY, ALIGN=1

                  USBD_TimerStart PROC
;;;1827   ///                value < 0:           timer start or restart failed
;;;1828   int32_t USBD_TimerStart (void *timer_hndl, uint32_t millisec) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1829     if (timer_hndl == NULL) { return -1; }
000006  b914              CBNZ     r4,|L82.14|
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L82.12|
;;;1830     return (-osTimerStart ((osTimerId)timer_hndl, millisec));
;;;1831   }
00000c  bd70              POP      {r4-r6,pc}
                  |L82.14|
00000e  4629              MOV      r1,r5                 ;1830
000010  4620              MOV      r0,r4                 ;1830
000012  f7fffffe          BL       osTimerStart
000016  4240              RSBS     r0,r0,#0              ;1830
000018  e7f8              B        |L82.12|
;;;1832   
                          ENDP


                          AREA ||i.USBD_TimerStop||, CODE, READONLY, ALIGN=1

                  USBD_TimerStop PROC
;;;1837   ///                value < 0:           timer stop failed
;;;1838   int32_t USBD_TimerStop (void *timer_hndl) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1839     if (timer_hndl == NULL) { return -1; }
000004  b914              CBNZ     r4,|L83.12|
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L83.10|
;;;1840     return (-osTimerStop ((osTimerId)timer_hndl));
;;;1841   }
00000a  bd10              POP      {r4,pc}
                  |L83.12|
00000c  4620              MOV      r0,r4                 ;1840
00000e  f7fffffe          BL       osTimerStop
000012  4240              RSBS     r0,r0,#0              ;1840
000014  e7f9              B        |L83.10|
;;;1842   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=5

                  usbd0_ep0_buf
                          %        128
                  usbd0_data
                          %        176
                  usbd_driver_ep_semaphore_id
                          %        24
                  usbd_cdc0_send_buf
                          %        1024
                  usbd_cdc0_receive_buf
                          %        2048
                  usbd_cdc0_notify_buf
                          %        12
                  usbd_cdc0_send_mps_buf
                          %        524
                  usbd_cdc0_receive_mps_buf
                          %        512
                  usbd_cdc_data
                          %        132
                  usbd0_ser_num_string_descriptor
                          %        34

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  usbd0_dev
                          DCD      Driver_USBD0
                          DCD      usbd0_alt_setting
                          DCD      usbd0_ep0_buf
                          DCD      usbd0_data
000010  8000              DCB      0x80,0x00
000012  0002              DCW      0x0002
000014  0308              DCB      0x03,0x08
000016  0010              DCW      0x0010
000018  0100              DCB      0x01,0x00
00001a  0080              DCW      0x0080
                  os_thread_def_USBD0_Core_Thread
                          DCD      USBD0_Core_Thread
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000200
                  usbd_dev_num
00002c  01000000          DCB      0x01,0x00,0x00,0x00
                  usbd_dev_ptr
                          DCD      usbd0_dev
                  usbd_cdc_num
000034  01000000          DCB      0x01,0x00,0x00,0x00
                  usbd_cdc
                          DCD      usbd_cdc0_send_buf
                          DCD      usbd_cdc0_receive_buf
                          DCD      usbd_cdc0_notify_buf
                          DCD      usbd_cdc0_send_mps_buf
                          DCD      usbd_cdc0_receive_mps_buf
                          DCD      usbd_cdc_data
000050  00010000          DCB      0x00,0x01,0x00,0x00
000054  01010202          DCB      0x01,0x01,0x02,0x02
000058  04000800          DCW      0x0400,0x0800
00005c  00100010          DCW      0x0010,0x0010
000060  00400200          DCW      0x0040,0x0200
000064  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
000070  00000000          DCW      0x0000,0x0000
000074  00000000          DCW      0x0000,0x0000
000078  00000000          DCW      0x0000,0x0000
00007c  00000000          DCW      0x0000,0x0000
                  usbd_cdc_ptr
                          DCD      usbd_cdc
                  usbd_core_thread_def_ptr
                          DCD      os_thread_def_USBD0_Core_Thread
                  os_thread_def_USBD_CDC0_Int_Thread
                          DCD      USBD_CDC0_Int_Thread
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000200
                  os_thread_def_USBD_CDC0_Bulk_Thread
                          DCD      USBD_CDC0_Bulk_Thread
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000200
                  usbd_cdc_int_thread_def_ptr
                          DCD      os_thread_def_USBD_CDC0_Int_Thread
                  usbd_cdc_bulk_thread_def_ptr
                          DCD      os_thread_def_USBD_CDC0_Bulk_Thread
                  os_semaphore_def_usbd0_driver_semaphore
                          DCD      os_semaphore_cb_usbd0_driver_semaphore
                  os_semaphore_def_usbd0_driver_ep0out_semaphore
                          DCD      os_semaphore_cb_usbd0_driver_ep0out_semaphore
                  os_semaphore_def_usbd0_driver_ep0in_semaphore
                          DCD      os_semaphore_cb_usbd0_driver_ep0in_semaphore
                  os_semaphore_def_usbd0_driver_ep1out_semaphore
                          DCD      os_semaphore_cb_usbd0_driver_ep1out_semaphore
                  os_semaphore_def_usbd0_driver_ep1in_semaphore
                          DCD      os_semaphore_cb_usbd0_driver_ep1in_semaphore
                  os_semaphore_def_usbd0_driver_ep2out_semaphore
                          DCD      os_semaphore_cb_usbd0_driver_ep2out_semaphore
                  os_semaphore_def_usbd0_driver_ep2in_semaphore
                          DCD      os_semaphore_cb_usbd0_driver_ep2in_semaphore
                  usbd_driver_semaphore_def_ptr
                          DCD      os_semaphore_def_usbd0_driver_semaphore
                  usbd_driver_ep_semaphore_def_ptr
                          DCD      os_semaphore_def_usbd0_driver_ep0out_semaphore
                          DCD      os_semaphore_def_usbd0_driver_ep1out_semaphore
                          DCD      os_semaphore_def_usbd0_driver_ep2out_semaphore
                          DCD      os_semaphore_def_usbd0_driver_ep0in_semaphore
                          DCD      os_semaphore_def_usbd0_driver_ep1in_semaphore
                          DCD      os_semaphore_def_usbd0_driver_ep2in_semaphore
                  usbd_ep_max_num
0000e8  03000000          DCB      0x03,0x00,0x00,0x00
                  usbd_cb_device_event_ptr
                          DCD      USBD0_SignalDeviceEvent
                  usbd_cb_endpoint_event_ptr
                          DCD      USBD0_SignalEndpointEvent
                  fpUSBD_CDC_ACM_Initialize
                          DCD      USBD_CDC0_ACM_Initialize
                  fpUSBD_CDC_ACM_Uninitialize
                          DCD      USBD_CDC0_ACM_Uninitialize
                  fpUSBD_CDC_ACM_Reset
                          DCD      USBD_CDC0_ACM_Reset
                  fpUSBD_CDC_ACM_SendEncapsulatedCommand
                          DCD      USBD_CDC0_ACM_SendEncapsulatedCommand
                  fpUSBD_CDC_ACM_GetEncapsulatedResponse
                          DCD      USBD_CDC0_ACM_GetEncapsulatedResponse
                  fpUSBD_CDC_ACM_SetLineCoding
                          DCD      USBD_CDC0_ACM_SetLineCoding
                  fpUSBD_CDC_ACM_GetLineCoding
                          DCD      USBD_CDC0_ACM_GetLineCoding
                  fpUSBD_CDC_ACM_SetControlLineState
                          DCD      USBD_CDC0_ACM_SetControlLineState
                  fpUSBD_CDC_ACM_DataReceived
                          DCD      USBD_CDC0_ACM_DataReceived
                  fpUSBD_CDC_ACM_DataSent
                          DCD      USBD_CDC0_ACM_DataSent
                  fpUSBD_CDC_NCM_Initialize
                          DCD      USBD_CDC0_NCM_Initialize
                  fpUSBD_CDC_NCM_Uninitialize
                          DCD      USBD_CDC0_NCM_Uninitialize
                  fpUSBD_CDC_NCM_Reset
                          DCD      USBD_CDC0_NCM_Reset
                  fpUSBD_CDC_NCM_Start
                          DCD      USBD_CDC0_NCM_Start
                  fpUSBD_CDC_NCM_Stop
                          DCD      USBD_CDC0_NCM_Stop
                  fpUSBD_CDC_NCM_SetEthernetMulticastFilters
                          DCD      USBD_CDC0_NCM_SetEthernetMulticastFilters
                  fpUSBD_CDC_NCM_SetEthernetPowerManagementPatternFilter
                          DCD      USBD_CDC0_NCM_SetEthernetPowerManagementPatternFilter
                  fpUSBD_CDC_NCM_GetEthernetPowerManagementPatternFilter
                          DCD      USBD_CDC0_NCM_GetEthernetPowerManagementPatternFilter
                  fpUSBD_CDC_NCM_SetEthernetPacketFilter
                          DCD      USBD_CDC0_NCM_SetEthernetPacketFilter
                  fpUSBD_CDC_NCM_GetEthernetStatistic
                          DCD      USBD_CDC0_NCM_GetEthernetStatistic
                  fpUSBD_CDC_NCM_GetNtbParameters
                          DCD      USBD_CDC0_NCM_GetNtbParameters
                  fpUSBD_CDC_NCM_GetNetAddress
                          DCD      USBD_CDC0_NCM_GetNetAddress
                  fpUSBD_CDC_NCM_SetNetAddress
                          DCD      USBD_CDC0_NCM_SetNetAddress
                  fpUSBD_CDC_NCM_GetNtbFormat
                          DCD      USBD_CDC0_NCM_GetNtbFormat
                  fpUSBD_CDC_NCM_SetNtbFormat
                          DCD      USBD_CDC0_NCM_SetNtbFormat
                  fpUSBD_CDC_NCM_GetNtbInputSize
                          DCD      USBD_CDC0_NCM_GetNtbInputSize
                  fpUSBD_CDC_NCM_SetNtbInputSize
                          DCD      USBD_CDC0_NCM_SetNtbInputSize
                  fpUSBD_CDC_NCM_GetMaxDatagramSize
                          DCD      USBD_CDC0_NCM_GetMaxDatagramSize
                  fpUSBD_CDC_NCM_SetMaxDatagramSize
                          DCD      USBD_CDC0_NCM_SetMaxDatagramSize
                  fpUSBD_CDC_NCM_GetCrcMode
                          DCD      USBD_CDC0_NCM_GetCrcMode
                  fpUSBD_CDC_NCM_SetCrcMode
                          DCD      USBD_CDC0_NCM_SetCrcMode
                  fpUSBD_CDC_NCM_NTB_IN_Sent
                          DCD      USBD_CDC0_NCM_NTB_IN_Sent
                  fpUSBD_CDC_NCM_NTB_OUT_Received
                          DCD      USBD_CDC0_NCM_NTB_OUT_Received
                  fpUSBD_Device_Initialize
                          DCD      USBD_Device0_Initialize
                  fpUSBD_Device_Uninitialize
                          DCD      USBD_Device0_Uninitialize
                  fpUSBD_Device_VbusChanged
                          DCD      USBD_Device0_VbusChanged
                  fpUSBD_Device_Reset
                          DCD      USBD_Device0_Reset
                  fpUSBD_Device_HighSpeedActivated
                          DCD      USBD_Device0_HighSpeedActivated
                  fpUSBD_Device_Suspended
                          DCD      USBD_Device0_Suspended
                  fpUSBD_Device_Resumed
                          DCD      USBD_Device0_Resumed
                  fpUSBD_Device_ConfigurationChanged
                          DCD      USBD_Device0_ConfigurationChanged
                  fpUSBD_Device_EnableRemoteWakeup
                          DCD      USBD_Device0_EnableRemoteWakeup
                  fpUSBD_Device_DisableRemoteWakeup
                          DCD      USBD_Device0_DisableRemoteWakeup
                  fpUSBD_Device_Endpoint0_SetupPacketReceived
                          DCD      USBD_Device0_Endpoint0_SetupPacketReceived
                  fpUSBD_Device_Endpoint0_SetupPacketProcessed
                          DCD      USBD_Device0_Endpoint0_SetupPacketProcessed
                  fpUSBD_Device_Endpoint0_OutDataReceived
                          DCD      USBD_Device0_Endpoint0_OutDataReceived
                  fpUSBD_Device_Endpoint0_InDataSent
                          DCD      USBD_Device0_Endpoint0_InDataSent
                  usbd0_ep0_descriptor
0001b0  07050000          DCB      0x07,0x05,0x00,0x00
0001b4  08000000          DCB      0x08,0x00,0x00,0x00
                  usbd0_device_descriptor
0001b8  12011001          DCB      0x12,0x01,0x10,0x01
0001bc  02000008          DCB      0x02,0x00,0x00,0x08
0001c0  51c20000          DCB      0x51,0xc2,0x00,0x00
0001c4  00010102          DCB      0x00,0x01,0x01,0x02
0001c8  03010000          DCB      0x03,0x01,0x00,0x00
                  usbd0_config_descriptor_fs
0001cc  09024300          DCB      0x09,0x02,0x43,0x00
0001d0  02010080          DCB      0x02,0x01,0x00,0x80
0001d4  fa090400          DCB      0xfa,0x09,0x04,0x00
0001d8  00010202          DCB      0x00,0x01,0x02,0x02
0001dc  00040524          DCB      0x00,0x04,0x05,0x24
0001e0  00100105          DCB      0x00,0x10,0x01,0x05
0001e4  24010301          DCB      0x24,0x01,0x03,0x01
0001e8  04240206          DCB      0x04,0x24,0x02,0x06
0001ec  05240600          DCB      0x05,0x24,0x06,0x00
0001f0  01070581          DCB      0x01,0x07,0x05,0x81
0001f4  03100002          DCB      0x03,0x10,0x00,0x02
0001f8  09040100          DCB      0x09,0x04,0x01,0x00
0001fc  020a0000          DCB      0x02,0x0a,0x00,0x00
000200  05070502          DCB      0x05,0x07,0x05,0x02
000204  02400000          DCB      0x02,0x40,0x00,0x00
000208  07058202          DCB      0x07,0x05,0x82,0x02
00020c  40000000          DCB      0x40,0x00,0x00,0x00
                  usbd0_device_qualifier_fs
000210  00                DCB      0x00
                  usbd0_device_qualifier_hs
000211  00                DCB      0x00
                  usbd0_config_descriptor_hs
000212  00                DCB      0x00
                  usbd0_other_speed_config_descriptor_fs
000213  00                DCB      0x00
                  usbd0_other_speed_config_descriptor_hs
000214  00000000          DCB      0x00,0x00,0x00,0x00
                  usbd0_string_descriptor
000218  0403              DCB      0x04,0x03
00021a  0409              DCW      0x0409
00021c  1c034b00          DCB      0x1c,0x03,0x4b,0x00
000220  65006900          DCB      0x65,0x00,0x69,0x00
000224  6c002000          DCB      0x6c,0x00,0x20,0x00
000228  53006f00          DCB      0x53,0x00,0x6f,0x00
00022c  66007400          DCB      0x66,0x00,0x74,0x00
000230  77006100          DCB      0x77,0x00,0x61,0x00
000234  72006500          DCB      0x72,0x00,0x65,0x00
000238  24034b00          DCB      0x24,0x03,0x4b,0x00
00023c  65006900          DCB      0x65,0x00,0x69,0x00
000240  6c002000          DCB      0x6c,0x00,0x20,0x00
000244  55005300          DCB      0x55,0x00,0x53,0x00
000248  42002000          DCB      0x42,0x00,0x20,0x00
00024c  44006500          DCB      0x44,0x00,0x65,0x00
000250  76006900          DCB      0x76,0x00,0x69,0x00
000254  63006500          DCB      0x63,0x00,0x65,0x00
000258  20003000          DCB      0x20,0x00,0x30,0x00
00025c  1a033000          DCB      0x1a,0x03,0x30,0x00
000260  30003000          DCB      0x30,0x00,0x30,0x00
000264  31004100          DCB      0x31,0x00,0x41,0x00
000268  30003000          DCB      0x30,0x00,0x30,0x00
00026c  30003000          DCB      0x30,0x00,0x30,0x00
000270  30003000          DCB      0x30,0x00,0x30,0x00
000274  30001603          DCB      0x30,0x00,0x16,0x03
000278  55005300          DCB      0x55,0x00,0x53,0x00
00027c  42005f00          DCB      0x42,0x00,0x5f,0x00
000280  43004400          DCB      0x43,0x00,0x44,0x00
000284  43003000          DCB      0x43,0x00,0x30,0x00
000288  5f003000          DCB      0x5f,0x00,0x30,0x00
00028c  16035500          DCB      0x16,0x03,0x55,0x00
000290  53004200          DCB      0x53,0x00,0x42,0x00
000294  5f004300          DCB      0x5f,0x00,0x43,0x00
000298  44004300          DCB      0x44,0x00,0x43,0x00
00029c  30005f00          DCB      0x30,0x00,0x5f,0x00
0002a0  31000000          DCB      0x31,0x00,0x00,0x00
                  usbd0_ms_os_string_descriptor
0002a4  12034d00          DCB      0x12,0x03,0x4d,0x00
0002a8  53004600          DCB      0x53,0x00,0x46,0x00
0002ac  54003100          DCB      0x54,0x00,0x31,0x00
0002b0  30003000          DCB      0x30,0x00,0x30,0x00
0002b4  0100              DCB      0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  usbd0_alt_setting
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  usbd_core_thread_id
                          DCD      0x00000000
                  usbd_driver_semaphore_id
                          DCD      0x00000000
                  usbd_cdc_int_thread_id
                          DCD      0x00000000
                  usbd_cdc_bulk_thread_id
                          DCD      0x00000000
                  os_semaphore_cb_usbd0_driver_semaphore
                          DCD      0x00000000
                          DCD      0x00000000
                  os_semaphore_cb_usbd0_driver_ep0out_semaphore
                          DCD      0x00000000
                          DCD      0x00000000
                  os_semaphore_cb_usbd0_driver_ep0in_semaphore
                          DCD      0x00000000
                          DCD      0x00000000
                  os_semaphore_cb_usbd0_driver_ep1out_semaphore
                          DCD      0x00000000
                          DCD      0x00000000
                  os_semaphore_cb_usbd0_driver_ep1in_semaphore
                          DCD      0x00000000
                          DCD      0x00000000
                  os_semaphore_cb_usbd0_driver_ep2out_semaphore
                          DCD      0x00000000
                          DCD      0x00000000
                  os_semaphore_cb_usbd0_driver_ep2in_semaphore
                          DCD      0x00000000
                          DCD      0x00000000
                  usbd_ep_thread_id_ptr
                          DCD      usbd_core_thread_id
                          DCD      usbd_cdc_int_thread_id
                          DCD      usbd_cdc_bulk_thread_id
                  usbd_drv_version
                          DCD      0x00000000
                  usbd_capabilities
                          DCD      0x00000000
                  usbd0_desc
                          DCD      usbd0_ep0_descriptor
                          DCD      usbd0_device_descriptor
                          DCD      usbd0_device_qualifier_fs
                          DCD      usbd0_device_qualifier_hs
                          DCD      usbd0_config_descriptor_fs
                          DCD      usbd0_config_descriptor_hs
                          DCD      usbd0_other_speed_config_descriptor_fs
                          DCD      usbd0_other_speed_config_descriptor_hs
                          DCD      usbd0_string_descriptor
                          DCD      usbd0_ser_num_string_descriptor
                          DCD      usbd0_ms_os_string_descriptor
                          DCD      0x00000000
                  usbd_desc_ptr
                          DCD      usbd0_desc

;*** Start embedded assembler ***

#line 1 "RTE\\USB\\USBD_Config_0.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_USBD_Config_0_c_2dd39ba2____REV16|
#line 492 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_USBD_Config_0_c_2dd39ba2____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_USBD_Config_0_c_2dd39ba2____REVSH|
#line 507
|__asm___15_USBD_Config_0_c_2dd39ba2____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_USBD_Config_0_c_2dd39ba2____RRX|
#line 694
|__asm___15_USBD_Config_0_c_2dd39ba2____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
